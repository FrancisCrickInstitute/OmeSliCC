{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OmeSliCC: Ome(ro) Slide Image Conversion and Compression pipeline","text":""},{"location":"overview/","title":"Overview","text":""},{"location":"overview/#omeslicc-omero-slide-image-conversion-and-compression-pipeline","title":"OmeSliCC: Ome(ro) Slide Image Conversion and Compression pipeline","text":"<p>OmeSliCC is designed to convert slides from common formats, to optimal OME formats for deep learning.</p> <p>This includes converting from Omero and extracting metadata as label information.</p> <p>For support and discussion, please use the Image.sc forum and post to the forum with the tag 'OmeSliCC'.</p>"},{"location":"overview/#main-features","title":"Main features","text":"<ul> <li>Import WSI files: Omero, Ome.Tiff, Tiff, Zarr, Ome.Zarr/NGFF, common slide formats, common image formats</li> <li>Export images: Tiff, Ome.Tiff, Zarr, Ome.Zarr, common image formats, thumbnails</li> <li>Integrated Dask support</li> <li>Zarr image compression (lossless/lossy)</li> <li>Image scaling using target pixel size</li> <li>Omero credentials helper</li> </ul> <p>For more info on OME/NGFF see OME NGFF</p>"},{"location":"overview/#running-omeslicc","title":"Running OmeSliCC","text":"<p>OmeSliCC is 100% Python and can be run as follows: - On a local environment using requirements.txt - With conda environment using the conda yaml file - As Docker container</p>"},{"location":"overview/#quickstart","title":"Quickstart","text":"<p>To start the conversion pipeline:</p> <pre><code>python run.py --params path/to/params.yml\n</code></pre> <p>See here for an example parameter file. The main sections are: - input: providing either a file/folder path, or Omero URL - output: specifying the location and desired format of the output - actions: which actions to perform:     - info: show input file information     - thumbnail: extract image thumbnail     - convert: convert to desired image output     - combine: combine separate channel images into multi-channel image(s)</p> <p>To encode credentials for Omero access:</p> <pre><code>python encode_omero_credentials.py --params path/to/params.yml\n</code></pre> <p>To extract Omero label metadata to text file:</p> <pre><code>python extract_omero_labels.py --params path/to/params.yml\n</code></pre>"},{"location":"references/","title":"References","text":""},{"location":"references/#OmeSliCC.BioSource","title":"<code>BioSource</code>","text":""},{"location":"references/#OmeSliCC.BioSource.javabridge_open","title":"<code>javabridge_open = False</code>  <code>module-attribute</code>","text":""},{"location":"references/#OmeSliCC.BioSource.BioSource","title":"<code>BioSource</code>","text":"<p>               Bases: <code>OmeSource</code></p> <p>bioformats compatible image source</p> Source code in <code>OmeSliCC\\BioSource.py</code> <pre><code>class BioSource(OmeSource):\n    \"\"\"bioformats compatible image source\"\"\"\n\n    filename: str\n    \"\"\"original filename\"\"\"\n    indexes: list\n    \"\"\"list of relevant series indexes\"\"\"\n\n    def __init__(self,\n                 filename: str,\n                 source_pixel_size: list = None,\n                 target_pixel_size: list = None,\n                 source_info_required: bool = False):\n\n        super().__init__()\n\n        open_javabridge()\n\n        xml_metadata = bioformats.get_omexml_metadata(filename)\n        self.bio_ome_metadata = bioformats.OMEXML(xml_metadata)\n        self.metadata = XmlDict.xml2dict(xml_metadata)\n        if 'OME' in self.metadata:\n            self.metadata = self.metadata['OME']\n            self.has_ome_metadata = True\n        self.reader = ImageReader(filename)\n\n        #self.reader.rdr.getSeriesCount()\n        # good images have StageLabel in metadata?\n        self.indexes = []\n        # TODO: use self.metadata instead of self.bio_ome_metadata\n        for i in range(self.bio_ome_metadata.get_image_count()):\n            pmetadata = self.bio_ome_metadata.image(i).Pixels\n            if pmetadata.PhysicalSizeX is not None:\n                dtype = np.dtype(pmetadata.PixelType)\n                self.indexes.append(i)\n                self.sizes.append((pmetadata.SizeX, pmetadata.SizeY))\n                self.sizes_xyzct.append((pmetadata.SizeX, pmetadata.SizeY, pmetadata.SizeZ, pmetadata.SizeC, pmetadata.SizeT))\n                self.pixel_types.append(dtype)\n                self.pixel_nbits.append(dtype.itemsize * 8)\n\n        self._init_metadata(filename,\n                            source_pixel_size=source_pixel_size,\n                            target_pixel_size=target_pixel_size,\n                            source_info_required=source_info_required)\n\n        self.is_rgb = self.get_nchannels() in (3, 4)\n\n        self.dimension_order = 'yx'\n        if self.get_nchannels() &gt; 1:\n            self.dimension_order += 'c'\n\n    def _find_metadata(self):\n        self._get_ome_metadata()\n\n    def _asarray_level(self, level: int, **slicing) -&gt; np.ndarray:\n        x0, x1 = slicing.get('x0', 0), slicing.get('x1', -1)\n        y0, y1 = slicing.get('y0', 0), slicing.get('y1', -1)\n        c, t, z = slicing.get('c'), slicing.get('t'), slicing.get('z')\n        if x1 &lt; 0 or y1 &lt; 0:\n            x1, y1 = self.sizes[level]\n        if t is None:\n            t = 0\n        if z is None:\n            z = 0\n        xywh = (x0, y0, x1 - x0, y1 - y0)\n        # don't 'rescale' to 0-1!\n        image = self.reader.read(series=self.indexes[level], XYWH=xywh, c=c, z=z, t=t, rescale=False)\n        out = redimension_data(image, self.dimension_order, self.get_dimension_order())\n        return out\n\n    def close(self):\n        self.reader.close()\n</code></pre>"},{"location":"references/#OmeSliCC.BioSource.BioSource.bio_ome_metadata","title":"<code>bio_ome_metadata = bioformats.OMEXML(xml_metadata)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.BioSource.BioSource.dimension_order","title":"<code>dimension_order = 'yx'</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.BioSource.BioSource.filename","title":"<code>filename</code>  <code>instance-attribute</code>","text":"<p>original filename</p>"},{"location":"references/#OmeSliCC.BioSource.BioSource.has_ome_metadata","title":"<code>has_ome_metadata = True</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.BioSource.BioSource.indexes","title":"<code>indexes = []</code>  <code>instance-attribute</code>","text":"<p>list of relevant series indexes</p>"},{"location":"references/#OmeSliCC.BioSource.BioSource.is_rgb","title":"<code>is_rgb = self.get_nchannels() in (3, 4)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.BioSource.BioSource.metadata","title":"<code>metadata = XmlDict.xml2dict(xml_metadata)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.BioSource.BioSource.reader","title":"<code>reader = ImageReader(filename)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.BioSource.BioSource.__init__","title":"<code>__init__(filename, source_pixel_size=None, target_pixel_size=None, source_info_required=False)</code>","text":"Source code in <code>OmeSliCC\\BioSource.py</code> <pre><code>def __init__(self,\n             filename: str,\n             source_pixel_size: list = None,\n             target_pixel_size: list = None,\n             source_info_required: bool = False):\n\n    super().__init__()\n\n    open_javabridge()\n\n    xml_metadata = bioformats.get_omexml_metadata(filename)\n    self.bio_ome_metadata = bioformats.OMEXML(xml_metadata)\n    self.metadata = XmlDict.xml2dict(xml_metadata)\n    if 'OME' in self.metadata:\n        self.metadata = self.metadata['OME']\n        self.has_ome_metadata = True\n    self.reader = ImageReader(filename)\n\n    #self.reader.rdr.getSeriesCount()\n    # good images have StageLabel in metadata?\n    self.indexes = []\n    # TODO: use self.metadata instead of self.bio_ome_metadata\n    for i in range(self.bio_ome_metadata.get_image_count()):\n        pmetadata = self.bio_ome_metadata.image(i).Pixels\n        if pmetadata.PhysicalSizeX is not None:\n            dtype = np.dtype(pmetadata.PixelType)\n            self.indexes.append(i)\n            self.sizes.append((pmetadata.SizeX, pmetadata.SizeY))\n            self.sizes_xyzct.append((pmetadata.SizeX, pmetadata.SizeY, pmetadata.SizeZ, pmetadata.SizeC, pmetadata.SizeT))\n            self.pixel_types.append(dtype)\n            self.pixel_nbits.append(dtype.itemsize * 8)\n\n    self._init_metadata(filename,\n                        source_pixel_size=source_pixel_size,\n                        target_pixel_size=target_pixel_size,\n                        source_info_required=source_info_required)\n\n    self.is_rgb = self.get_nchannels() in (3, 4)\n\n    self.dimension_order = 'yx'\n    if self.get_nchannels() &gt; 1:\n        self.dimension_order += 'c'\n</code></pre>"},{"location":"references/#OmeSliCC.BioSource.BioSource._asarray_level","title":"<code>_asarray_level(level, **slicing)</code>","text":"Source code in <code>OmeSliCC\\BioSource.py</code> <pre><code>def _asarray_level(self, level: int, **slicing) -&gt; np.ndarray:\n    x0, x1 = slicing.get('x0', 0), slicing.get('x1', -1)\n    y0, y1 = slicing.get('y0', 0), slicing.get('y1', -1)\n    c, t, z = slicing.get('c'), slicing.get('t'), slicing.get('z')\n    if x1 &lt; 0 or y1 &lt; 0:\n        x1, y1 = self.sizes[level]\n    if t is None:\n        t = 0\n    if z is None:\n        z = 0\n    xywh = (x0, y0, x1 - x0, y1 - y0)\n    # don't 'rescale' to 0-1!\n    image = self.reader.read(series=self.indexes[level], XYWH=xywh, c=c, z=z, t=t, rescale=False)\n    out = redimension_data(image, self.dimension_order, self.get_dimension_order())\n    return out\n</code></pre>"},{"location":"references/#OmeSliCC.BioSource.BioSource._find_metadata","title":"<code>_find_metadata()</code>","text":"Source code in <code>OmeSliCC\\BioSource.py</code> <pre><code>def _find_metadata(self):\n    self._get_ome_metadata()\n</code></pre>"},{"location":"references/#OmeSliCC.BioSource.BioSource.close","title":"<code>close()</code>","text":"Source code in <code>OmeSliCC\\BioSource.py</code> <pre><code>def close(self):\n    self.reader.close()\n</code></pre>"},{"location":"references/#OmeSliCC.BioSource.close_javabridge","title":"<code>close_javabridge()</code>","text":"Source code in <code>OmeSliCC\\BioSource.py</code> <pre><code>def close_javabridge():\n    javabridge.kill_vm()\n</code></pre>"},{"location":"references/#OmeSliCC.BioSource.open_javabridge","title":"<code>open_javabridge()</code>","text":"Source code in <code>OmeSliCC\\BioSource.py</code> <pre><code>def open_javabridge():\n    global javabridge_open\n\n    javabridge.start_vm(class_path=bioformats.JARS)\n\n    rootLoggerName = javabridge.get_static_field(\"org/slf4j/Logger\", \"ROOT_LOGGER_NAME\", \"Ljava/lang/String;\")\n    rootLogger = javabridge.static_call(\"org/slf4j/LoggerFactory\", \"getLogger\",\n                                        \"(Ljava/lang/String;)Lorg/slf4j/Logger;\", rootLoggerName)\n    logLevel = javabridge.get_static_field(\"ch/qos/logback/classic/Level\", 'WARN',\n                                           \"Lch/qos/logback/classic/Level;\")\n    javabridge.call(rootLogger, \"setLevel\", \"(Lch/qos/logback/classic/Level;)V\", logLevel)\n\n    javabridge_open = True\n</code></pre>"},{"location":"references/#OmeSliCC.GeneratorSource","title":"<code>GeneratorSource</code>","text":""},{"location":"references/#OmeSliCC.GeneratorSource.data","title":"<code>data = source.asdask(tile_size)</code>  <code>module-attribute</code>","text":""},{"location":"references/#OmeSliCC.GeneratorSource.dtype","title":"<code>dtype = np.uint8</code>  <code>module-attribute</code>","text":""},{"location":"references/#OmeSliCC.GeneratorSource.pixel_size","title":"<code>pixel_size = [(1, 'um')]</code>  <code>module-attribute</code>","text":""},{"location":"references/#OmeSliCC.GeneratorSource.seed","title":"<code>seed = 0</code>  <code>module-attribute</code>","text":""},{"location":"references/#OmeSliCC.GeneratorSource.shape","title":"<code>shape = list(reversed(size)) + [3]</code>  <code>module-attribute</code>","text":""},{"location":"references/#OmeSliCC.GeneratorSource.size","title":"<code>size = (256, 256, 256)</code>  <code>module-attribute</code>","text":""},{"location":"references/#OmeSliCC.GeneratorSource.source","title":"<code>source = GeneratorSource(size, tile_size, dtype, pixel_size, seed)</code>  <code>module-attribute</code>","text":""},{"location":"references/#OmeSliCC.GeneratorSource.tile_shape","title":"<code>tile_shape = list(reversed(tile_size[:2]))</code>  <code>module-attribute</code>","text":""},{"location":"references/#OmeSliCC.GeneratorSource.tile_size","title":"<code>tile_size = (256, 256, 1)</code>  <code>module-attribute</code>","text":""},{"location":"references/#OmeSliCC.GeneratorSource.GeneratorSource","title":"<code>GeneratorSource</code>","text":"<p>               Bases: <code>OmeSource</code></p> Source code in <code>OmeSliCC\\GeneratorSource.py</code> <pre><code>class GeneratorSource(OmeSource):\n    def __init__(self, size, tile_size, dtype=np.uint8, source_pixel_size: list = None, seed=None):\n        super().__init__()\n\n        size_xyzct = list(size)\n        tile_shape = list(np.flip(tile_size))\n        if len(size_xyzct) &lt; 3:\n            size_xyzct += [1]\n        if len(tile_shape) &lt; 3:\n            tile_shape += [1]\n        size_xyzct += [3]\n        tile_shape += [3]\n        if len(size_xyzct) &lt; 5:\n            size_xyzct += [1]\n        if len(tile_shape) &lt; 5:\n            tile_shape += [1]\n        self.size = size\n        self.sizes = [size[:2]]\n        self.sizes_xyzct = [size_xyzct]\n        self.tile_shape = tile_shape\n        dtype = np.dtype(dtype)\n        self.dtype = dtype\n        self.pixel_types = [dtype]\n        self.pixel_nbits.append(dtype.itemsize * 8)\n\n        self._init_metadata('generator', source_pixel_size=source_pixel_size)\n\n        if np.dtype(dtype).kind != 'f':\n            self.max_val = 2 ** (8 * np.dtype(dtype).itemsize) - 1\n        else:\n            self.max_val = 1\n\n        self.is_rgb = True\n\n        if seed is not None:\n            np.random.seed(seed)\n\n        self.color_value_table = [np.sin(np.divide(range(dim), dim, dtype=np.float32) * np.pi)\n                                  for dim in np.flip(size)]\n\n    def _find_metadata(self):\n        self._get_ome_metadata()\n\n    def calc_color(self, *args, **kwargs):\n        channels = []\n        channel = None\n        range0 = kwargs['range0']\n        for index, value in enumerate(reversed(args)):\n            #channel = np.sin((value + range0[index]) / self.size[index] * np.pi)\n            channel = self.color_value_table[index][value + range0[index]]\n            channels.append(channel)\n        while len(channels) &lt; 3:\n            channels.append(channel)\n        return np.stack(channels, axis=-1)\n\n    def get_tile(self, indices, tile_size=None):\n        # indices / tile size in x,y(,z,...)\n        if not tile_size:\n            tile_size = np.flip(self.tile_shape)\n        range0 = indices\n        range1 = np.min([np.array(indices) + np.array(tile_size), self.size], 0)\n        shape = list(reversed(range1 - range0))\n        tile = np.fromfunction(self.calc_color, shape, dtype=int, range0=range0)\n        # apply noise to each channel separately\n        for channeli in range(3):\n            noise = np.random.random(size=shape) - 0.5\n            tile[..., channeli] = np.clip(tile[..., channeli] + noise, 0, 1)\n        if self.dtype.kind != 'f':\n            tile *= self.max_val\n        tile = tile.astype(self.dtype)\n        return tile\n\n    def _asarray_level(self, level: int = None, **slicing) -&gt; np.ndarray:\n        # ignore level and c\n        slices = get_numpy_slicing('xyzt', **slicing)\n        indices, tile_size = [], []\n        for slice1, axis_size in zip(slices, self.size):\n            if axis_size &gt; 0:\n                if isinstance(slice1, slice):\n                    indices.append(slice1.start)\n                    tile_size.append(slice1.stop - slice1.start)\n                else:\n                    indices.append(slice1)\n                    tile_size.append(1)\n        data = self.get_tile(indices, tile_size)\n        if data.ndim &lt; 4:\n            data = np.expand_dims(data, 0)\n        data = np.moveaxis(data, -1, 0)\n        if data.ndim &lt; 5:\n            data = np.expand_dims(data, 0)\n        return data\n</code></pre>"},{"location":"references/#OmeSliCC.GeneratorSource.GeneratorSource.color_value_table","title":"<code>color_value_table = [np.sin(np.divide(range(dim), dim, dtype=np.float32) * np.pi) for dim in np.flip(size)]</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.GeneratorSource.GeneratorSource.dtype","title":"<code>dtype = dtype</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.GeneratorSource.GeneratorSource.is_rgb","title":"<code>is_rgb = True</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.GeneratorSource.GeneratorSource.max_val","title":"<code>max_val = 2 ** 8 * np.dtype(dtype).itemsize - 1</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.GeneratorSource.GeneratorSource.pixel_types","title":"<code>pixel_types = [dtype]</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.GeneratorSource.GeneratorSource.size","title":"<code>size = size</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.GeneratorSource.GeneratorSource.sizes","title":"<code>sizes = [size[:2]]</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.GeneratorSource.GeneratorSource.sizes_xyzct","title":"<code>sizes_xyzct = [size_xyzct]</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.GeneratorSource.GeneratorSource.tile_shape","title":"<code>tile_shape = tile_shape</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.GeneratorSource.GeneratorSource.__init__","title":"<code>__init__(size, tile_size, dtype=np.uint8, source_pixel_size=None, seed=None)</code>","text":"Source code in <code>OmeSliCC\\GeneratorSource.py</code> <pre><code>def __init__(self, size, tile_size, dtype=np.uint8, source_pixel_size: list = None, seed=None):\n    super().__init__()\n\n    size_xyzct = list(size)\n    tile_shape = list(np.flip(tile_size))\n    if len(size_xyzct) &lt; 3:\n        size_xyzct += [1]\n    if len(tile_shape) &lt; 3:\n        tile_shape += [1]\n    size_xyzct += [3]\n    tile_shape += [3]\n    if len(size_xyzct) &lt; 5:\n        size_xyzct += [1]\n    if len(tile_shape) &lt; 5:\n        tile_shape += [1]\n    self.size = size\n    self.sizes = [size[:2]]\n    self.sizes_xyzct = [size_xyzct]\n    self.tile_shape = tile_shape\n    dtype = np.dtype(dtype)\n    self.dtype = dtype\n    self.pixel_types = [dtype]\n    self.pixel_nbits.append(dtype.itemsize * 8)\n\n    self._init_metadata('generator', source_pixel_size=source_pixel_size)\n\n    if np.dtype(dtype).kind != 'f':\n        self.max_val = 2 ** (8 * np.dtype(dtype).itemsize) - 1\n    else:\n        self.max_val = 1\n\n    self.is_rgb = True\n\n    if seed is not None:\n        np.random.seed(seed)\n\n    self.color_value_table = [np.sin(np.divide(range(dim), dim, dtype=np.float32) * np.pi)\n                              for dim in np.flip(size)]\n</code></pre>"},{"location":"references/#OmeSliCC.GeneratorSource.GeneratorSource._asarray_level","title":"<code>_asarray_level(level=None, **slicing)</code>","text":"Source code in <code>OmeSliCC\\GeneratorSource.py</code> <pre><code>def _asarray_level(self, level: int = None, **slicing) -&gt; np.ndarray:\n    # ignore level and c\n    slices = get_numpy_slicing('xyzt', **slicing)\n    indices, tile_size = [], []\n    for slice1, axis_size in zip(slices, self.size):\n        if axis_size &gt; 0:\n            if isinstance(slice1, slice):\n                indices.append(slice1.start)\n                tile_size.append(slice1.stop - slice1.start)\n            else:\n                indices.append(slice1)\n                tile_size.append(1)\n    data = self.get_tile(indices, tile_size)\n    if data.ndim &lt; 4:\n        data = np.expand_dims(data, 0)\n    data = np.moveaxis(data, -1, 0)\n    if data.ndim &lt; 5:\n        data = np.expand_dims(data, 0)\n    return data\n</code></pre>"},{"location":"references/#OmeSliCC.GeneratorSource.GeneratorSource._find_metadata","title":"<code>_find_metadata()</code>","text":"Source code in <code>OmeSliCC\\GeneratorSource.py</code> <pre><code>def _find_metadata(self):\n    self._get_ome_metadata()\n</code></pre>"},{"location":"references/#OmeSliCC.GeneratorSource.GeneratorSource.calc_color","title":"<code>calc_color(*args, **kwargs)</code>","text":"Source code in <code>OmeSliCC\\GeneratorSource.py</code> <pre><code>def calc_color(self, *args, **kwargs):\n    channels = []\n    channel = None\n    range0 = kwargs['range0']\n    for index, value in enumerate(reversed(args)):\n        #channel = np.sin((value + range0[index]) / self.size[index] * np.pi)\n        channel = self.color_value_table[index][value + range0[index]]\n        channels.append(channel)\n    while len(channels) &lt; 3:\n        channels.append(channel)\n    return np.stack(channels, axis=-1)\n</code></pre>"},{"location":"references/#OmeSliCC.GeneratorSource.GeneratorSource.get_tile","title":"<code>get_tile(indices, tile_size=None)</code>","text":"Source code in <code>OmeSliCC\\GeneratorSource.py</code> <pre><code>def get_tile(self, indices, tile_size=None):\n    # indices / tile size in x,y(,z,...)\n    if not tile_size:\n        tile_size = np.flip(self.tile_shape)\n    range0 = indices\n    range1 = np.min([np.array(indices) + np.array(tile_size), self.size], 0)\n    shape = list(reversed(range1 - range0))\n    tile = np.fromfunction(self.calc_color, shape, dtype=int, range0=range0)\n    # apply noise to each channel separately\n    for channeli in range(3):\n        noise = np.random.random(size=shape) - 0.5\n        tile[..., channeli] = np.clip(tile[..., channeli] + noise, 0, 1)\n    if self.dtype.kind != 'f':\n        tile *= self.max_val\n    tile = tile.astype(self.dtype)\n    return tile\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource","title":"<code>OmeSource</code>","text":""},{"location":"references/#OmeSliCC.OmeSource.OmeSource","title":"<code>OmeSource</code>","text":"<p>OME-compatible image source (base class)</p> Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>class OmeSource:\n    \"\"\"OME-compatible image source (base class)\"\"\"\n    \"\"\"Internal image format is [TCZYX]\"\"\"\n\n    metadata: dict\n    \"\"\"metadata dictionary\"\"\"\n    has_ome_metadata: bool\n    \"\"\"has ome metadata\"\"\"\n    dimension_order: str\n    \"\"\"source dimension order\"\"\"\n    output_dimension_order: str\n    \"\"\"data dimension order\"\"\"\n    source_pixel_size: list\n    \"\"\"original source pixel size\"\"\"\n    target_pixel_size: list\n    \"\"\"target pixel size\"\"\"\n    sizes: list\n    \"\"\"x/y size pairs for all pages\"\"\"\n    sizes_xyzct: list\n    \"\"\"xyzct size for all pages\"\"\"\n    pixel_types: list\n    \"\"\"pixel types for all pages\"\"\"\n    pixel_nbits: list\n    \"\"\"#bits for all pages\"\"\"\n    channels: list\n    \"\"\"channel information for all image channels\"\"\"\n    position: list\n    \"\"\"source position information\"\"\"\n    rotation: float\n    \"\"\"source rotation information\"\"\"\n\n    default_properties_order = 'xyzct'\n    default_physical_unit = '\u00b5m'\n\n    def __init__(self):\n        self.metadata = {}\n        self.has_ome_metadata = False\n        self.dimension_order = ''\n        self.output_dimension_order = ''\n        self.source_pixel_size = []\n        self.target_pixel_size = []\n        self.sizes = []\n        self.sizes_xyzct = []\n        self.pixel_types = []\n        self.pixel_nbits = []\n        self.channels = []\n\n    def _init_metadata(self,\n                       source_reference: str,\n                       source_pixel_size: list = None,\n                       target_pixel_size: list = None,\n                       source_info_required: bool = False):\n\n        self.source_reference = source_reference\n        self.target_pixel_size = target_pixel_size\n        self._find_metadata()\n        if (len(self.source_pixel_size) == 0 or self.source_pixel_size[0][0] == 0\n                or self.source_pixel_size[0][1] == '' or self.source_pixel_size[0][1] == 'inch') \\\n                and source_pixel_size is not None:\n            # if pixel size is not set, or default/unspecified value\n            self.source_pixel_size = source_pixel_size\n        if len(self.source_pixel_size) == 0 or self.source_pixel_size[0][0] == 0:\n            msg = f'{source_reference}: No source pixel size in metadata or provided'\n            if source_info_required:\n                raise ValueError(msg)\n            else:\n                logging.warning(msg)\n        self._init_sizes()\n\n    def _get_ome_metadata(self):\n        images = ensure_list(self.metadata.get('Image', {}))[0]\n        pixels = images.get('Pixels', {})\n        self.source_pixel_size = []\n        size = float(pixels.get('PhysicalSizeX', 0))\n        if size &gt; 0:\n            self.source_pixel_size.append((size, pixels.get('PhysicalSizeXUnit', self.default_physical_unit)))\n        size = float(pixels.get('PhysicalSizeY', 0))\n        if size &gt; 0:\n            self.source_pixel_size.append((size, pixels.get('PhysicalSizeYUnit', self.default_physical_unit)))\n        size = float(pixels.get('PhysicalSizeZ', 0))\n        if size &gt; 0:\n            self.source_pixel_size.append((size, pixels.get('PhysicalSizeZUnit', self.default_physical_unit)))\n\n        position = []\n        for plane in ensure_list(pixels.get('Plane', [])):\n            position = []\n            if 'PositionX' in plane:\n                position.append((float(plane.get('PositionX')), plane.get('PositionXUnit', self.default_physical_unit)))\n            if 'PositionY' in plane:\n                position.append((float(plane.get('PositionY')), plane.get('PositionYUnit', self.default_physical_unit)))\n            if 'PositionZ' in plane:\n                position.append((float(plane.get('PositionZ')), plane.get('PositionZUnit', self.default_physical_unit)))\n            #c, z, t = plane.get('TheC'), plane.get('TheZ'), plane.get('TheT')\n            break\n        self.position = position\n\n        rotation = None\n        annotations = self.metadata.get('StructuredAnnotations')\n        if annotations is not None:\n            if not isinstance(annotations, (list, tuple)):\n                annotations = [annotations]\n            for annotation_item in annotations:\n                for annotations2 in annotation_item.values():\n                    if not isinstance(annotations2, (list, tuple)):\n                        annotations2 = [annotations2]\n                    for annotation in annotations2:\n                        value = annotation.get('Value')\n                        unit = None\n                        if isinstance(value, dict) and 'Modulo' in value:\n                            modulo = value.get('Modulo', {}).get('ModuloAlongZ', {})\n                            unit = modulo.get('Unit')\n                            value = modulo.get('Label')\n                        elif isinstance(value, str) and value.lower().startswith('angle'):\n                            if ':' in value:\n                                value = value.split(':')[1].split()\n                            elif '=' in value:\n                                value = value.split('=')[1].split()\n                            else:\n                                value = value.split()[1:]\n                            if len(value) &gt;= 2:\n                                unit = value[1]\n                            value = value[0]\n                        else:\n                            value = None\n                        if value is not None:\n                            rotation = float(value)\n                            if 'rad' in unit.lower():\n                                rotation = np.rad2deg(rotation)\n        self.rotation = rotation\n\n        self.source_mag = 0\n        objective_id = images.get('ObjectiveSettings', {}).get('ID', '')\n        for objective in ensure_list(self.metadata.get('Instrument', {}).get('Objective', [])):\n            if objective.get('ID', '') == objective_id:\n                self.source_mag = float(objective.get('NominalMagnification', 0))\n        nchannels = self.get_nchannels()\n        channels = []\n        for channel0 in ensure_list(pixels.get('Channel', [])):\n            channel = {'label': channel0.get('Name', '')}\n            color = channel0.get('Color')\n            if color:\n                channel['color'] = int_to_rgba(int(color))\n            channels.append(channel)\n        if len(channels) == 0:\n            if nchannels == 3:\n                channels = [{'label': ''}]\n            else:\n                channels = [{'label': str(channeli)} for channeli in range(nchannels)]\n        self.channels = channels\n\n    def _init_sizes(self):\n        # normalise source pixel sizes\n        standard_units = {'nano': 'nm', 'micro': '\u00b5m', 'milli': 'mm', 'centi': 'cm'}\n        pixel_size = []\n        for pixel_size0 in self.source_pixel_size:\n            pixel_size1 = check_round_significants(pixel_size0[0], 6)\n            unit1 = pixel_size0[1]\n            for standard_unit in standard_units:\n                if unit1.lower().startswith(standard_unit):\n                    unit1 = standard_units[standard_unit]\n            pixel_size.append((pixel_size1, unit1))\n        if 0 &lt; len(pixel_size) &lt; 2:\n            pixel_size.append(pixel_size[0])\n        self.source_pixel_size = pixel_size\n\n        if self.target_pixel_size is None:\n            self.target_pixel_size = self.source_pixel_size\n\n        if 0 &lt; len(self.target_pixel_size) &lt; 2:\n            self.target_pixel_size.append(self.target_pixel_size[0])\n\n        # set source mags\n        self.source_mags = [self.source_mag]\n        for i, size in enumerate(self.sizes):\n            if i &gt; 0:\n                mag = self.source_mag * np.mean(np.divide(size, self.sizes[0]))\n                self.source_mags.append(check_round_significants(mag, 3))\n\n        if self.target_pixel_size:\n            self.best_level, self.best_factor, self.full_factor = get_best_level_factor(self, self.target_pixel_size)\n        else:\n            self.best_level = 0\n            self.best_factor = 1\n\n        if self.dimension_order == '':\n            x, y, z, c, t = self.get_size_xyzct()\n            if t &gt; 1:\n                self.dimension_order += 't'\n            if c &gt; 1:\n                self.dimension_order += 'c'\n            if z &gt; 1:\n                self.dimension_order += 'z'\n            self.dimension_order += 'yx'\n\n        self.output_dimension_order = 'tczyx'\n\n    def get_source_dask(self):\n        raise NotImplementedError('Implement method in subclass')\n\n    def get_mag(self) -&gt; float:\n        mag = self.source_mag\n        # get effective mag at target pixel size\n        if self.target_pixel_size:\n            mag *= np.mean(self.full_factor)\n        return check_round_significants(mag, 3)\n\n    def get_dimension_order(self) -&gt; str:\n        return self.output_dimension_order\n\n    def get_physical_size(self) -&gt; tuple:\n        physical_size = []\n        for size, pixel_size in zip(self.get_size_xyzct(), self.get_pixel_size()):\n            physical_size.append((np.multiply(size, pixel_size[0]), pixel_size[1]))\n        return tuple(physical_size)\n\n    def get_pixel_type(self, level: int = 0) -&gt; np.dtype:\n        return self.pixel_types[level]\n\n    def get_pixel_nbytes(self, level: int = 0) -&gt; int:\n        return self.pixel_nbits[level] // 8\n\n    def get_channels(self) -&gt; list:\n        return self.channels\n\n    def get_size(self) -&gt; tuple:\n        # size at target pixel size\n        return tuple(np.round(np.multiply(self.sizes[self.best_level], self.best_factor)).astype(int))\n\n    def get_size_xyzct(self) -&gt; tuple:\n        xyzct = list(self.sizes_xyzct[self.best_level]).copy()\n        size = self.get_size()\n        xyzct[0:2] = size\n        return tuple(xyzct)\n\n    def get_nchannels(self):\n        return self.sizes_xyzct[0][3]\n\n    def get_pixel_size(self) -&gt; list:\n        return self.target_pixel_size\n\n    def get_pixel_size_micrometer(self):\n        return get_value_units_micrometer(self.get_pixel_size())\n\n    def get_position(self) -&gt; list:\n        return self.position\n\n    def get_position_micrometer(self):\n        return get_value_units_micrometer(self.get_position())\n\n    def get_rotation(self) -&gt; float:\n        return self.rotation\n\n    def get_shape(self, dimension_order: str = None, xyzct: tuple = None) -&gt; tuple:\n        shape = []\n        if dimension_order is None:\n            dimension_order = self.get_dimension_order()\n        if xyzct is None:\n            xyzct = self.get_size_xyzct()\n        for dimension in dimension_order:\n            index = 'xyzct'.index(dimension)\n            shape.append(xyzct[index])\n        return tuple(shape)\n\n    def get_thumbnail(self, target_size: tuple, precise: bool = False) -&gt; np.ndarray:\n        size, index = get_best_size(self.sizes, target_size)\n        scale = np.divide(target_size, self.sizes[index])\n        new_dimension_order = 'yxc'\n        image = redimension_data(self._asarray_level(index), self.get_dimension_order(), new_dimension_order, t=0, z=0)\n        if precise:\n            thumbnail = precise_resize(image, scale)\n        else:\n            thumbnail = image_resize(image, target_size)\n        thumbnail_rgb = self.render(thumbnail, new_dimension_order)\n        return thumbnail_rgb\n\n    def get_channel_window(self, channeli):\n        min_quantile = 0.001\n        max_quantile = 0.999\n\n        if channeli &lt; len(self.channels) and 'window' in self.channels[channeli]:\n            return self.channels[channeli].get('window')\n\n        dtype = self.get_pixel_type()\n        if dtype.kind == 'f':\n            # info = np.finfo(dtype)\n            start, end = 0, 1\n        else:\n            info = np.iinfo(dtype)\n            start, end = info.min, info.max\n\n        nsizes = len(self.sizes)\n        if nsizes &gt; 1:\n            image = self._asarray_level(nsizes - 1)\n            image = np.asarray(image[:, channeli:channeli+1, ...])\n            min, max = get_image_quantile(image, min_quantile), get_image_quantile(image, max_quantile)\n        else:\n            # do not query full size image\n            min, max = start, end\n        return {'start': start, 'end': end, 'min': min, 'max': max}\n\n    def render(self, image: np.ndarray, source_dimension_order: str = None, t: int = 0, z: int = 0, channels: list = []) -&gt; np.ndarray:\n        if source_dimension_order is None:\n            source_dimension_order = self.get_dimension_order()\n        image = redimension_data(image, source_dimension_order, 'yxc', t=t, z=z)\n        total_image = None\n        n = len(self.channels)\n        is_rgb = (self.get_nchannels() in (3, 4) and (n &lt;= 1 or n == 3))\n        needs_normalisation = (image.dtype.itemsize == 2)\n\n        if not is_rgb:\n            tot_alpha = 0\n            for channeli, channel in enumerate(self.channels):\n                if not channels or channeli in channels:\n                    if n == 1:\n                        channel_values = image\n                    else:\n                        channel_values = image[..., channeli]\n                    if needs_normalisation:\n                        window = self.get_channel_window(channeli)\n                        channel_values = normalise_values(channel_values, window['min'], window['max'])\n                    else:\n                        channel_values = int2float_image(channel_values)\n                    new_channel_image = np.atleast_3d(channel_values)\n                    color = channel.get('color')\n                    if color:\n                        rgba = color\n                    else:\n                        rgba = [1, 1, 1, 1]\n                    color = rgba[:3]\n                    alpha = rgba[3]\n                    if alpha == 0:\n                        alpha = 1\n                    new_channel_image = new_channel_image * np.multiply(color, alpha).astype(np.float32)\n                    if total_image is None:\n                        total_image = new_channel_image\n                    else:\n                        total_image += new_channel_image\n                    tot_alpha += alpha\n            if tot_alpha != 1:\n                total_image /= tot_alpha\n            final_image = float2int_image(total_image,\n                                          target_dtype=image.dtype)\n        elif needs_normalisation:\n            window = self.get_channel_window(0)\n            final_image = float2int_image(normalise_values(image, window['min'], window['max']),\n                                          target_dtype=image.dtype)\n        else:\n            final_image = image\n        return final_image\n\n    def asarray(self, pixel_size: list = [], **slicing) -&gt; np.ndarray:\n        # expects x0, x1, y0, y1, ...\n        x0, x1 = slicing.get('x0', 0), slicing.get('x1', -1)\n        y0, y1 = slicing.get('y0', 0), slicing.get('y1', -1)\n        # allow custom pixel size\n        if pixel_size:\n            level, factor, _ = get_best_level_factor(self, pixel_size)\n            size0 = np.round(np.multiply(self.sizes[level], factor)).astype(int)\n        else:\n            level, factor = self.best_level, self.best_factor\n            size0 = self.get_size()\n\n        if x1 &lt; 0 or y1 &lt; 0:\n            x1, y1 = size0\n        if np.mean(factor) != 1:\n            slicing['x0'], slicing['y0'] = np.round(np.divide([x0, y0], factor)).astype(int)\n            slicing['x1'], slicing['y1'] = np.round(np.divide([x1, y1], factor)).astype(int)\n        image0 = self._asarray_level(level=level, **slicing)\n        if np.mean(factor) != 1:\n            size1 = x1 - x0, y1 - y0\n            image = image_resize(image0, size1, dimension_order=self.get_dimension_order())\n        else:\n            image = image0\n        return image\n\n    def asarray_um(self, **slicing):\n        pixel_size = self.get_pixel_size_micrometer()[:2]\n        slicing['x0'], slicing['y0'] = np.divide([slicing.get('x0'), slicing.get('y0')], pixel_size)\n        slicing['x1'], slicing['y1'] = np.divide([slicing.get('x1'), slicing.get('y1')], pixel_size)\n        return self.asarray(**slicing)\n\n    def asdask(self, chunk_size: tuple) -&gt; da.Array:\n        chunk_shape = list(np.flip(chunk_size))\n        while len(chunk_shape) &lt; 3:\n            chunk_shape = [1] + chunk_shape\n        chunk_shape = [self.get_nchannels()] + chunk_shape\n        while len(chunk_shape) &lt; 5:\n            chunk_shape = [1] + chunk_shape\n        chunks = np.ceil(np.flip(self.get_size_xyzct()) / chunk_shape).astype(int)\n        w, h = self.get_size()\n\n        delayed_reader = dask.delayed(self.asarray)\n        dtype = self.get_pixel_type()\n\n        dask_times = []\n        for ti in range(chunks[0]):\n            dask_planes = []\n            for zi in range(chunks[2]):\n                dask_rows = []\n                for yi in range(chunks[3]):\n                    dask_row = []\n                    for xi in range(chunks[4]):\n                        shape = list(chunk_shape).copy()\n                        x0, x1 = xi * shape[4], (xi + 1) * shape[4]\n                        y0, y1 = yi * shape[3], (yi + 1) * shape[3]\n                        if x1 &gt; w:\n                            x1 = w\n                            shape[4] = w - x0\n                        if y1 &gt; h:\n                            y1 = h\n                            shape[3] = h - y0\n                        z = zi * shape[2]\n                        t = ti * shape[0]\n                        dask_tile = da.from_delayed(delayed_reader(x0=x0, x1=x1, y0=y0, y1=y1, z=z, t=t),\n                                                    shape=shape, dtype=dtype)\n                        dask_row.append(dask_tile)\n                    dask_rows.append(da.concatenate(dask_row, axis=4))\n                dask_planes.append(da.concatenate(dask_rows, axis=3))\n            dask_times.append(da.concatenate(dask_planes, axis=2))\n        dask_data = da.concatenate(dask_times, axis=0)\n        return dask_data\n\n    def clone_empty(self) -&gt; np.ndarray:\n        return np.zeros(self.get_shape(), dtype=self.get_pixel_type())\n\n    def produce_chunks(self, chunk_size: tuple) -&gt; tuple:\n        w, h = self.get_size()\n        ny = int(np.ceil(h / chunk_size[1]))\n        nx = int(np.ceil(w / chunk_size[0]))\n        for chunky in range(ny):\n            for chunkx in range(nx):\n                x0, y0 = chunkx * chunk_size[0], chunky * chunk_size[1]\n                x1, y1 = min((chunkx + 1) * chunk_size[0], w), min((chunky + 1) * chunk_size[1], h)\n                indices = 0, 0, 0, y0, x0\n                yield indices, self.asarray(x0=x0, x1=x1, y0=y0, y1=y1)\n\n    def get_metadata(self) -&gt; dict:\n        return self.metadata\n\n    def create_xml_metadata(self, output_filename: str, combine_rgb: bool = True, pyramid_sizes_add: list = None) -&gt; str:\n        return create_ome_metadata(self, output_filename, combine_rgb=combine_rgb, pyramid_sizes_add=pyramid_sizes_add)\n\n    def _find_metadata(self):\n        raise NotImplementedError('Implement method in subclass')\n\n    def _asarray_level(self, level: int, **slicing) -&gt; np.ndarray:\n        raise NotImplementedError('Implement method in subclass')\n\n    def close(self):\n        pass\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.channels","title":"<code>channels = []</code>  <code>instance-attribute</code>","text":"<p>channel information for all image channels</p>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.default_physical_unit","title":"<code>default_physical_unit = '\u00b5m'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.OmeSource.OmeSource.default_properties_order","title":"<code>default_properties_order = 'xyzct'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.OmeSource.OmeSource.dimension_order","title":"<code>dimension_order = ''</code>  <code>instance-attribute</code>","text":"<p>source dimension order</p>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.has_ome_metadata","title":"<code>has_ome_metadata = False</code>  <code>instance-attribute</code>","text":"<p>has ome metadata</p>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.metadata","title":"<code>metadata = {}</code>  <code>instance-attribute</code>","text":"<p>metadata dictionary</p>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.output_dimension_order","title":"<code>output_dimension_order = ''</code>  <code>instance-attribute</code>","text":"<p>data dimension order</p>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.pixel_nbits","title":"<code>pixel_nbits = []</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.OmeSource.OmeSource.pixel_nbits--bits-for-all-pages","title":"bits for all pages","text":""},{"location":"references/#OmeSliCC.OmeSource.OmeSource.pixel_types","title":"<code>pixel_types = []</code>  <code>instance-attribute</code>","text":"<p>pixel types for all pages</p>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.position","title":"<code>position</code>  <code>instance-attribute</code>","text":"<p>source position information</p>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.rotation","title":"<code>rotation</code>  <code>instance-attribute</code>","text":"<p>source rotation information</p>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.sizes","title":"<code>sizes = []</code>  <code>instance-attribute</code>","text":"<p>x/y size pairs for all pages</p>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.sizes_xyzct","title":"<code>sizes_xyzct = []</code>  <code>instance-attribute</code>","text":"<p>xyzct size for all pages</p>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.source_pixel_size","title":"<code>source_pixel_size = []</code>  <code>instance-attribute</code>","text":"<p>original source pixel size</p>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.target_pixel_size","title":"<code>target_pixel_size = []</code>  <code>instance-attribute</code>","text":"<p>target pixel size</p>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.__init__","title":"<code>__init__()</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def __init__(self):\n    self.metadata = {}\n    self.has_ome_metadata = False\n    self.dimension_order = ''\n    self.output_dimension_order = ''\n    self.source_pixel_size = []\n    self.target_pixel_size = []\n    self.sizes = []\n    self.sizes_xyzct = []\n    self.pixel_types = []\n    self.pixel_nbits = []\n    self.channels = []\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource._asarray_level","title":"<code>_asarray_level(level, **slicing)</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def _asarray_level(self, level: int, **slicing) -&gt; np.ndarray:\n    raise NotImplementedError('Implement method in subclass')\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource._find_metadata","title":"<code>_find_metadata()</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def _find_metadata(self):\n    raise NotImplementedError('Implement method in subclass')\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource._get_ome_metadata","title":"<code>_get_ome_metadata()</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def _get_ome_metadata(self):\n    images = ensure_list(self.metadata.get('Image', {}))[0]\n    pixels = images.get('Pixels', {})\n    self.source_pixel_size = []\n    size = float(pixels.get('PhysicalSizeX', 0))\n    if size &gt; 0:\n        self.source_pixel_size.append((size, pixels.get('PhysicalSizeXUnit', self.default_physical_unit)))\n    size = float(pixels.get('PhysicalSizeY', 0))\n    if size &gt; 0:\n        self.source_pixel_size.append((size, pixels.get('PhysicalSizeYUnit', self.default_physical_unit)))\n    size = float(pixels.get('PhysicalSizeZ', 0))\n    if size &gt; 0:\n        self.source_pixel_size.append((size, pixels.get('PhysicalSizeZUnit', self.default_physical_unit)))\n\n    position = []\n    for plane in ensure_list(pixels.get('Plane', [])):\n        position = []\n        if 'PositionX' in plane:\n            position.append((float(plane.get('PositionX')), plane.get('PositionXUnit', self.default_physical_unit)))\n        if 'PositionY' in plane:\n            position.append((float(plane.get('PositionY')), plane.get('PositionYUnit', self.default_physical_unit)))\n        if 'PositionZ' in plane:\n            position.append((float(plane.get('PositionZ')), plane.get('PositionZUnit', self.default_physical_unit)))\n        #c, z, t = plane.get('TheC'), plane.get('TheZ'), plane.get('TheT')\n        break\n    self.position = position\n\n    rotation = None\n    annotations = self.metadata.get('StructuredAnnotations')\n    if annotations is not None:\n        if not isinstance(annotations, (list, tuple)):\n            annotations = [annotations]\n        for annotation_item in annotations:\n            for annotations2 in annotation_item.values():\n                if not isinstance(annotations2, (list, tuple)):\n                    annotations2 = [annotations2]\n                for annotation in annotations2:\n                    value = annotation.get('Value')\n                    unit = None\n                    if isinstance(value, dict) and 'Modulo' in value:\n                        modulo = value.get('Modulo', {}).get('ModuloAlongZ', {})\n                        unit = modulo.get('Unit')\n                        value = modulo.get('Label')\n                    elif isinstance(value, str) and value.lower().startswith('angle'):\n                        if ':' in value:\n                            value = value.split(':')[1].split()\n                        elif '=' in value:\n                            value = value.split('=')[1].split()\n                        else:\n                            value = value.split()[1:]\n                        if len(value) &gt;= 2:\n                            unit = value[1]\n                        value = value[0]\n                    else:\n                        value = None\n                    if value is not None:\n                        rotation = float(value)\n                        if 'rad' in unit.lower():\n                            rotation = np.rad2deg(rotation)\n    self.rotation = rotation\n\n    self.source_mag = 0\n    objective_id = images.get('ObjectiveSettings', {}).get('ID', '')\n    for objective in ensure_list(self.metadata.get('Instrument', {}).get('Objective', [])):\n        if objective.get('ID', '') == objective_id:\n            self.source_mag = float(objective.get('NominalMagnification', 0))\n    nchannels = self.get_nchannels()\n    channels = []\n    for channel0 in ensure_list(pixels.get('Channel', [])):\n        channel = {'label': channel0.get('Name', '')}\n        color = channel0.get('Color')\n        if color:\n            channel['color'] = int_to_rgba(int(color))\n        channels.append(channel)\n    if len(channels) == 0:\n        if nchannels == 3:\n            channels = [{'label': ''}]\n        else:\n            channels = [{'label': str(channeli)} for channeli in range(nchannels)]\n    self.channels = channels\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource._init_metadata","title":"<code>_init_metadata(source_reference, source_pixel_size=None, target_pixel_size=None, source_info_required=False)</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def _init_metadata(self,\n                   source_reference: str,\n                   source_pixel_size: list = None,\n                   target_pixel_size: list = None,\n                   source_info_required: bool = False):\n\n    self.source_reference = source_reference\n    self.target_pixel_size = target_pixel_size\n    self._find_metadata()\n    if (len(self.source_pixel_size) == 0 or self.source_pixel_size[0][0] == 0\n            or self.source_pixel_size[0][1] == '' or self.source_pixel_size[0][1] == 'inch') \\\n            and source_pixel_size is not None:\n        # if pixel size is not set, or default/unspecified value\n        self.source_pixel_size = source_pixel_size\n    if len(self.source_pixel_size) == 0 or self.source_pixel_size[0][0] == 0:\n        msg = f'{source_reference}: No source pixel size in metadata or provided'\n        if source_info_required:\n            raise ValueError(msg)\n        else:\n            logging.warning(msg)\n    self._init_sizes()\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource._init_sizes","title":"<code>_init_sizes()</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def _init_sizes(self):\n    # normalise source pixel sizes\n    standard_units = {'nano': 'nm', 'micro': '\u00b5m', 'milli': 'mm', 'centi': 'cm'}\n    pixel_size = []\n    for pixel_size0 in self.source_pixel_size:\n        pixel_size1 = check_round_significants(pixel_size0[0], 6)\n        unit1 = pixel_size0[1]\n        for standard_unit in standard_units:\n            if unit1.lower().startswith(standard_unit):\n                unit1 = standard_units[standard_unit]\n        pixel_size.append((pixel_size1, unit1))\n    if 0 &lt; len(pixel_size) &lt; 2:\n        pixel_size.append(pixel_size[0])\n    self.source_pixel_size = pixel_size\n\n    if self.target_pixel_size is None:\n        self.target_pixel_size = self.source_pixel_size\n\n    if 0 &lt; len(self.target_pixel_size) &lt; 2:\n        self.target_pixel_size.append(self.target_pixel_size[0])\n\n    # set source mags\n    self.source_mags = [self.source_mag]\n    for i, size in enumerate(self.sizes):\n        if i &gt; 0:\n            mag = self.source_mag * np.mean(np.divide(size, self.sizes[0]))\n            self.source_mags.append(check_round_significants(mag, 3))\n\n    if self.target_pixel_size:\n        self.best_level, self.best_factor, self.full_factor = get_best_level_factor(self, self.target_pixel_size)\n    else:\n        self.best_level = 0\n        self.best_factor = 1\n\n    if self.dimension_order == '':\n        x, y, z, c, t = self.get_size_xyzct()\n        if t &gt; 1:\n            self.dimension_order += 't'\n        if c &gt; 1:\n            self.dimension_order += 'c'\n        if z &gt; 1:\n            self.dimension_order += 'z'\n        self.dimension_order += 'yx'\n\n    self.output_dimension_order = 'tczyx'\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.asarray","title":"<code>asarray(pixel_size=[], **slicing)</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def asarray(self, pixel_size: list = [], **slicing) -&gt; np.ndarray:\n    # expects x0, x1, y0, y1, ...\n    x0, x1 = slicing.get('x0', 0), slicing.get('x1', -1)\n    y0, y1 = slicing.get('y0', 0), slicing.get('y1', -1)\n    # allow custom pixel size\n    if pixel_size:\n        level, factor, _ = get_best_level_factor(self, pixel_size)\n        size0 = np.round(np.multiply(self.sizes[level], factor)).astype(int)\n    else:\n        level, factor = self.best_level, self.best_factor\n        size0 = self.get_size()\n\n    if x1 &lt; 0 or y1 &lt; 0:\n        x1, y1 = size0\n    if np.mean(factor) != 1:\n        slicing['x0'], slicing['y0'] = np.round(np.divide([x0, y0], factor)).astype(int)\n        slicing['x1'], slicing['y1'] = np.round(np.divide([x1, y1], factor)).astype(int)\n    image0 = self._asarray_level(level=level, **slicing)\n    if np.mean(factor) != 1:\n        size1 = x1 - x0, y1 - y0\n        image = image_resize(image0, size1, dimension_order=self.get_dimension_order())\n    else:\n        image = image0\n    return image\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.asarray_um","title":"<code>asarray_um(**slicing)</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def asarray_um(self, **slicing):\n    pixel_size = self.get_pixel_size_micrometer()[:2]\n    slicing['x0'], slicing['y0'] = np.divide([slicing.get('x0'), slicing.get('y0')], pixel_size)\n    slicing['x1'], slicing['y1'] = np.divide([slicing.get('x1'), slicing.get('y1')], pixel_size)\n    return self.asarray(**slicing)\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.asdask","title":"<code>asdask(chunk_size)</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def asdask(self, chunk_size: tuple) -&gt; da.Array:\n    chunk_shape = list(np.flip(chunk_size))\n    while len(chunk_shape) &lt; 3:\n        chunk_shape = [1] + chunk_shape\n    chunk_shape = [self.get_nchannels()] + chunk_shape\n    while len(chunk_shape) &lt; 5:\n        chunk_shape = [1] + chunk_shape\n    chunks = np.ceil(np.flip(self.get_size_xyzct()) / chunk_shape).astype(int)\n    w, h = self.get_size()\n\n    delayed_reader = dask.delayed(self.asarray)\n    dtype = self.get_pixel_type()\n\n    dask_times = []\n    for ti in range(chunks[0]):\n        dask_planes = []\n        for zi in range(chunks[2]):\n            dask_rows = []\n            for yi in range(chunks[3]):\n                dask_row = []\n                for xi in range(chunks[4]):\n                    shape = list(chunk_shape).copy()\n                    x0, x1 = xi * shape[4], (xi + 1) * shape[4]\n                    y0, y1 = yi * shape[3], (yi + 1) * shape[3]\n                    if x1 &gt; w:\n                        x1 = w\n                        shape[4] = w - x0\n                    if y1 &gt; h:\n                        y1 = h\n                        shape[3] = h - y0\n                    z = zi * shape[2]\n                    t = ti * shape[0]\n                    dask_tile = da.from_delayed(delayed_reader(x0=x0, x1=x1, y0=y0, y1=y1, z=z, t=t),\n                                                shape=shape, dtype=dtype)\n                    dask_row.append(dask_tile)\n                dask_rows.append(da.concatenate(dask_row, axis=4))\n            dask_planes.append(da.concatenate(dask_rows, axis=3))\n        dask_times.append(da.concatenate(dask_planes, axis=2))\n    dask_data = da.concatenate(dask_times, axis=0)\n    return dask_data\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.clone_empty","title":"<code>clone_empty()</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def clone_empty(self) -&gt; np.ndarray:\n    return np.zeros(self.get_shape(), dtype=self.get_pixel_type())\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.close","title":"<code>close()</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def close(self):\n    pass\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.create_xml_metadata","title":"<code>create_xml_metadata(output_filename, combine_rgb=True, pyramid_sizes_add=None)</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def create_xml_metadata(self, output_filename: str, combine_rgb: bool = True, pyramid_sizes_add: list = None) -&gt; str:\n    return create_ome_metadata(self, output_filename, combine_rgb=combine_rgb, pyramid_sizes_add=pyramid_sizes_add)\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.get_channel_window","title":"<code>get_channel_window(channeli)</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def get_channel_window(self, channeli):\n    min_quantile = 0.001\n    max_quantile = 0.999\n\n    if channeli &lt; len(self.channels) and 'window' in self.channels[channeli]:\n        return self.channels[channeli].get('window')\n\n    dtype = self.get_pixel_type()\n    if dtype.kind == 'f':\n        # info = np.finfo(dtype)\n        start, end = 0, 1\n    else:\n        info = np.iinfo(dtype)\n        start, end = info.min, info.max\n\n    nsizes = len(self.sizes)\n    if nsizes &gt; 1:\n        image = self._asarray_level(nsizes - 1)\n        image = np.asarray(image[:, channeli:channeli+1, ...])\n        min, max = get_image_quantile(image, min_quantile), get_image_quantile(image, max_quantile)\n    else:\n        # do not query full size image\n        min, max = start, end\n    return {'start': start, 'end': end, 'min': min, 'max': max}\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.get_channels","title":"<code>get_channels()</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def get_channels(self) -&gt; list:\n    return self.channels\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.get_dimension_order","title":"<code>get_dimension_order()</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def get_dimension_order(self) -&gt; str:\n    return self.output_dimension_order\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.get_mag","title":"<code>get_mag()</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def get_mag(self) -&gt; float:\n    mag = self.source_mag\n    # get effective mag at target pixel size\n    if self.target_pixel_size:\n        mag *= np.mean(self.full_factor)\n    return check_round_significants(mag, 3)\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.get_metadata","title":"<code>get_metadata()</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def get_metadata(self) -&gt; dict:\n    return self.metadata\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.get_nchannels","title":"<code>get_nchannels()</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def get_nchannels(self):\n    return self.sizes_xyzct[0][3]\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.get_physical_size","title":"<code>get_physical_size()</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def get_physical_size(self) -&gt; tuple:\n    physical_size = []\n    for size, pixel_size in zip(self.get_size_xyzct(), self.get_pixel_size()):\n        physical_size.append((np.multiply(size, pixel_size[0]), pixel_size[1]))\n    return tuple(physical_size)\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.get_pixel_nbytes","title":"<code>get_pixel_nbytes(level=0)</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def get_pixel_nbytes(self, level: int = 0) -&gt; int:\n    return self.pixel_nbits[level] // 8\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.get_pixel_size","title":"<code>get_pixel_size()</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def get_pixel_size(self) -&gt; list:\n    return self.target_pixel_size\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.get_pixel_size_micrometer","title":"<code>get_pixel_size_micrometer()</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def get_pixel_size_micrometer(self):\n    return get_value_units_micrometer(self.get_pixel_size())\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.get_pixel_type","title":"<code>get_pixel_type(level=0)</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def get_pixel_type(self, level: int = 0) -&gt; np.dtype:\n    return self.pixel_types[level]\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.get_position","title":"<code>get_position()</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def get_position(self) -&gt; list:\n    return self.position\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.get_position_micrometer","title":"<code>get_position_micrometer()</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def get_position_micrometer(self):\n    return get_value_units_micrometer(self.get_position())\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.get_rotation","title":"<code>get_rotation()</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def get_rotation(self) -&gt; float:\n    return self.rotation\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.get_shape","title":"<code>get_shape(dimension_order=None, xyzct=None)</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def get_shape(self, dimension_order: str = None, xyzct: tuple = None) -&gt; tuple:\n    shape = []\n    if dimension_order is None:\n        dimension_order = self.get_dimension_order()\n    if xyzct is None:\n        xyzct = self.get_size_xyzct()\n    for dimension in dimension_order:\n        index = 'xyzct'.index(dimension)\n        shape.append(xyzct[index])\n    return tuple(shape)\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.get_size","title":"<code>get_size()</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def get_size(self) -&gt; tuple:\n    # size at target pixel size\n    return tuple(np.round(np.multiply(self.sizes[self.best_level], self.best_factor)).astype(int))\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.get_size_xyzct","title":"<code>get_size_xyzct()</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def get_size_xyzct(self) -&gt; tuple:\n    xyzct = list(self.sizes_xyzct[self.best_level]).copy()\n    size = self.get_size()\n    xyzct[0:2] = size\n    return tuple(xyzct)\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.get_source_dask","title":"<code>get_source_dask()</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def get_source_dask(self):\n    raise NotImplementedError('Implement method in subclass')\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.get_thumbnail","title":"<code>get_thumbnail(target_size, precise=False)</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def get_thumbnail(self, target_size: tuple, precise: bool = False) -&gt; np.ndarray:\n    size, index = get_best_size(self.sizes, target_size)\n    scale = np.divide(target_size, self.sizes[index])\n    new_dimension_order = 'yxc'\n    image = redimension_data(self._asarray_level(index), self.get_dimension_order(), new_dimension_order, t=0, z=0)\n    if precise:\n        thumbnail = precise_resize(image, scale)\n    else:\n        thumbnail = image_resize(image, target_size)\n    thumbnail_rgb = self.render(thumbnail, new_dimension_order)\n    return thumbnail_rgb\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.produce_chunks","title":"<code>produce_chunks(chunk_size)</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def produce_chunks(self, chunk_size: tuple) -&gt; tuple:\n    w, h = self.get_size()\n    ny = int(np.ceil(h / chunk_size[1]))\n    nx = int(np.ceil(w / chunk_size[0]))\n    for chunky in range(ny):\n        for chunkx in range(nx):\n            x0, y0 = chunkx * chunk_size[0], chunky * chunk_size[1]\n            x1, y1 = min((chunkx + 1) * chunk_size[0], w), min((chunky + 1) * chunk_size[1], h)\n            indices = 0, 0, 0, y0, x0\n            yield indices, self.asarray(x0=x0, x1=x1, y0=y0, y1=y1)\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.OmeSource.render","title":"<code>render(image, source_dimension_order=None, t=0, z=0, channels=[])</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def render(self, image: np.ndarray, source_dimension_order: str = None, t: int = 0, z: int = 0, channels: list = []) -&gt; np.ndarray:\n    if source_dimension_order is None:\n        source_dimension_order = self.get_dimension_order()\n    image = redimension_data(image, source_dimension_order, 'yxc', t=t, z=z)\n    total_image = None\n    n = len(self.channels)\n    is_rgb = (self.get_nchannels() in (3, 4) and (n &lt;= 1 or n == 3))\n    needs_normalisation = (image.dtype.itemsize == 2)\n\n    if not is_rgb:\n        tot_alpha = 0\n        for channeli, channel in enumerate(self.channels):\n            if not channels or channeli in channels:\n                if n == 1:\n                    channel_values = image\n                else:\n                    channel_values = image[..., channeli]\n                if needs_normalisation:\n                    window = self.get_channel_window(channeli)\n                    channel_values = normalise_values(channel_values, window['min'], window['max'])\n                else:\n                    channel_values = int2float_image(channel_values)\n                new_channel_image = np.atleast_3d(channel_values)\n                color = channel.get('color')\n                if color:\n                    rgba = color\n                else:\n                    rgba = [1, 1, 1, 1]\n                color = rgba[:3]\n                alpha = rgba[3]\n                if alpha == 0:\n                    alpha = 1\n                new_channel_image = new_channel_image * np.multiply(color, alpha).astype(np.float32)\n                if total_image is None:\n                    total_image = new_channel_image\n                else:\n                    total_image += new_channel_image\n                tot_alpha += alpha\n        if tot_alpha != 1:\n            total_image /= tot_alpha\n        final_image = float2int_image(total_image,\n                                      target_dtype=image.dtype)\n    elif needs_normalisation:\n        window = self.get_channel_window(0)\n        final_image = float2int_image(normalise_values(image, window['min'], window['max']),\n                                      target_dtype=image.dtype)\n    else:\n        final_image = image\n    return final_image\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.blur_image","title":"<code>blur_image(image, sigma)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def blur_image(image, sigma):\n    nchannels = image.shape[2] if image.ndim == 3 else 1\n    if nchannels not in [1, 3]:\n        new_image = np.zeros_like(image)\n        for channeli in range(nchannels):\n            new_image[..., channeli] = blur_image_single(image[..., channeli], sigma)\n    else:\n        new_image = blur_image_single(image, sigma)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.blur_image_single","title":"<code>blur_image_single(image, sigma)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def blur_image_single(image, sigma):\n    return gaussian_filter(image, sigma)\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.calc_fraction_used","title":"<code>calc_fraction_used(image, threshold=0.1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_fraction_used(image: np.ndarray, threshold: float = 0.1) -&gt; float:\n    low = int(round(threshold * 255))\n    high = int(round((1 - threshold) * 255))\n    shape = image.shape\n    total = shape[0] * shape[1]\n    good = 0\n    for y in range(shape[0]):\n        for x in range(shape[1]):\n            pixel = image[y, x]\n            if low &lt;= pixel[0] &lt; high and low &lt;= pixel[1] &lt; high and low &lt;= pixel[2] &lt; high:\n                good += 1\n    fraction = good / total\n    return fraction\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.calc_pyramid","title":"<code>calc_pyramid(xyzct, npyramid_add=0, pyramid_downsample=2, volumetric_resize=False)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_pyramid(xyzct: tuple, npyramid_add: int = 0, pyramid_downsample: float = 2,\n                 volumetric_resize: bool = False) -&gt; list:\n    x, y, z, c, t = xyzct\n    if volumetric_resize and z &gt; 1:\n        size = (x, y, z)\n    else:\n        size = (x, y)\n    sizes_add = []\n    scale = 1\n    for _ in range(npyramid_add):\n        scale /= pyramid_downsample\n        scaled_size = np.maximum(np.round(np.multiply(size, scale)).astype(int), 1)\n        sizes_add.append(scaled_size)\n    return sizes_add\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.calc_tiles_median","title":"<code>calc_tiles_median(images)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_tiles_median(images):\n    out_image = np.zeros_like(images[0])\n    median_image = np.median(images, 0, out_image)\n    return median_image\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.calc_tiles_quantiles","title":"<code>calc_tiles_quantiles(images, quantiles)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_tiles_quantiles(images, quantiles):\n    out_quantiles = []\n    quantile_images = np.quantile(images, quantiles, 0)\n    for quantile_image in quantile_images:\n        maxval = 2 ** (8 * images[0].dtype.itemsize) - 1\n        image = (quantile_image / maxval).astype(np.float32)\n        out_quantiles.append(image)\n    return out_quantiles\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.check_round_significants","title":"<code>check_round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def check_round_significants(a: float, significant_digits: int) -&gt; float:\n    rounded = round_significants(a, significant_digits)\n    if a != 0:\n        dif = 1 - rounded / a\n    else:\n        dif = rounded - a\n    if abs(dif) &lt; 10 ** -significant_digits:\n        return rounded\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.check_versions","title":"<code>check_versions()</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def check_versions():\n    print(f'tifffile {tifffile.__version__}')\n    print(imagecodecs.version())\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.compare_image","title":"<code>compare_image(image0, image1, show=False)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image(image0, image1, show=False) -&gt; float:\n    dif, dif_max, dif_mean, psnr = compare_image_dist(image0, image1)\n    print(f'rgb dist max: {dif_max:.1f} mean: {dif_mean:.1f} PSNR: {psnr:.1f}')\n    if show:\n        show_image(dif)\n        show_image((dif * 10).astype(np.uint8))\n    return dif\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.compare_image_dist","title":"<code>compare_image_dist(image0, image1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image_dist(image0: np.ndarray, image1: np.ndarray) -&gt; tuple:\n    dif = cv.absdiff(image0, image1)\n    psnr = cv.PSNR(image0, image1)\n    if dif.size &gt; 1000000000:\n        # split very large array\n        rgb_maxs = []\n        rgb_means = []\n        for dif1 in np.array_split(dif, 16):\n            rgb_dif = np.linalg.norm(dif1, axis=2)\n            rgb_maxs.append(np.max(rgb_dif))\n            rgb_means.append(np.mean(rgb_dif))\n        rgb_max = np.max(rgb_maxs)\n        rgb_mean = np.mean(rgb_means)\n    else:\n        rgb_dif = np.linalg.norm(dif, axis=2)\n        rgb_max = np.max(rgb_dif)\n        rgb_mean = np.mean(rgb_dif)\n    return dif, rgb_max, rgb_mean, psnr\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.compare_image_dist_simple","title":"<code>compare_image_dist_simple(image0, image1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image_dist_simple(image0: np.ndarray, image1: np.ndarray) -&gt; dict:\n    dif = cv.absdiff(image0, image1)\n    psnr = cv.PSNR(image0, image1)\n    rgb_dif = np.linalg.norm(dif, axis=2)\n    dif_max = np.max(rgb_dif)\n    dif_mean = np.mean(rgb_dif)\n    return {'dif_max': dif_max, 'dif_mean': dif_mean, 'psnr': psnr}\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.convert_image_sign_type","title":"<code>convert_image_sign_type(image, target_dtype)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def convert_image_sign_type(image: np.ndarray, target_dtype: np.dtype) -&gt; np.ndarray:\n    source_dtype = image.dtype\n    if source_dtype.kind == target_dtype.kind:\n        new_image = image\n    elif source_dtype.kind == 'i':\n        new_image = ensure_unsigned_image(image)\n    else:\n        # conversion without overhead\n        offset = 2 ** (8 * target_dtype.itemsize - 1)\n        new_image = (image - offset).astype(target_dtype)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.convert_rational_value","title":"<code>convert_rational_value(value)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def convert_rational_value(value) -&gt; float:\n    if value is not None and isinstance(value, tuple):\n        value = value[0] / value[1]\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.create_compression_codecs","title":"<code>create_compression_codecs(compression)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def create_compression_codecs(compression: list) -&gt; list:\n    codecs = None\n    compression = ensure_list(compression)\n    if compression is not None and len(compression) &gt; 0:\n        compression_type = compression[0].lower()\n        if len(compression) &gt; 1:\n            level = int(compression[1])\n        else:\n            level = None\n        if 'lzw' in compression_type:\n            from imagecodecs.numcodecs import Lzw\n            codecs = [Lzw()]\n        elif '2k' in compression_type or '2000' in compression_type:\n            from imagecodecs.numcodecs import Jpeg2k\n            codecs = [Jpeg2k(level=level)]\n        elif 'jpegls' in compression_type:\n            from imagecodecs.numcodecs import Jpegls\n            codecs = [Jpegls(level=level)]\n        elif 'jpegxr' in compression_type:\n            from imagecodecs.numcodecs import Jpegxr\n            codecs = [Jpegxr(level=level)]\n        elif 'jpegxl' in compression_type:\n            from imagecodecs.numcodecs import Jpegxl\n            codecs = [Jpegxl(level=level)]\n        else:\n            codecs = [compression]\n    return codecs\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.create_compression_filter","title":"<code>create_compression_filter(compression)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def create_compression_filter(compression: list) -&gt; tuple:\n    compressor, compression_filters = None, None\n    compression = ensure_list(compression)\n    if compression is not None and len(compression) &gt; 0:\n        compression_type = compression[0].lower()\n        if len(compression) &gt; 1:\n            level = int(compression[1])\n        else:\n            level = None\n        if 'lzw' in compression_type:\n            from imagecodecs.numcodecs import Lzw\n            compression_filters = [Lzw()]\n        elif '2k' in compression_type or '2000' in compression_type:\n            from imagecodecs.numcodecs import Jpeg2k\n            compression_filters = [Jpeg2k(level=level)]\n        elif 'jpegls' in compression_type:\n            from imagecodecs.numcodecs import Jpegls\n            compression_filters = [Jpegls(level=level)]\n        elif 'jpegxr' in compression_type:\n            from imagecodecs.numcodecs import Jpegxr\n            compression_filters = [Jpegxr(level=level)]\n        elif 'jpegxl' in compression_type:\n            from imagecodecs.numcodecs import Jpegxl\n            compression_filters = [Jpegxl(level=level)]\n        else:\n            compressor = compression\n    return compressor, compression_filters\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.desc_to_dict","title":"<code>desc_to_dict(desc)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def desc_to_dict(desc: str) -&gt; dict:\n    desc_dict = {}\n    if desc.startswith('{'):\n        try:\n            metadata = ast.literal_eval(desc)\n            return metadata\n        except:\n            pass\n    for item in re.split(r'[\\r\\n\\t|]', desc):\n        item_sep = '='\n        if ':' in item:\n            item_sep = ':'\n        if item_sep in item:\n            items = item.split(item_sep)\n            key = items[0].strip()\n            value = items[1].strip()\n            for dtype in (int, float, bool):\n                try:\n                    value = dtype(value)\n                    break\n                except:\n                    pass\n            desc_dict[key] = value\n    return desc_dict\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.ensure_list","title":"<code>ensure_list(x)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def ensure_list(x) -&gt; list:\n    if x is None:\n        return []\n    elif isinstance(x, list):\n        return x\n    else:\n        return [x]\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.ensure_unsigned_image","title":"<code>ensure_unsigned_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def ensure_unsigned_image(image: np.ndarray) -&gt; np.ndarray:\n    source_dtype = image.dtype\n    dtype = ensure_unsigned_type(source_dtype)\n    if dtype != source_dtype:\n        # conversion without overhead\n        offset = 2 ** (8 * dtype.itemsize - 1)\n        new_image = image.astype(dtype) + offset\n    else:\n        new_image = image\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.ensure_unsigned_type","title":"<code>ensure_unsigned_type(dtype)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def ensure_unsigned_type(dtype: np.dtype) -&gt; np.dtype:\n    new_dtype = dtype\n    if dtype.kind == 'i' or dtype.byteorder == '&gt;' or dtype.byteorder == '&lt;':\n        new_dtype = np.dtype(f'u{dtype.itemsize}')\n    return new_dtype\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.file_to_dict","title":"<code>file_to_dict(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def file_to_dict(filename: str) -&gt; dict:\n    ext = os.path.splitext(filename)[1]\n    content = open(filename, 'r').read()\n    if ext == '.xml':\n        data = xmltodict.parse(content)\n    elif ext in ['.yml', '.yaml']:\n        data = yaml.safe_load(content)\n    else:   # assume json\n        data = json.loads(content)\n    return data\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.filter_dict","title":"<code>filter_dict(dict0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def filter_dict(dict0: dict) -&gt; dict:\n    new_dict = {}\n    for key, value0 in dict0.items():\n        if value0 is not None:\n            values = []\n            for value in ensure_list(value0):\n                if isinstance(value, dict):\n                    value = filter_dict(value)\n                values.append(value)\n            if len(values) == 1:\n                values = values[0]\n            new_dict[key] = values\n    return new_dict\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.float2int_image","title":"<code>float2int_image(image, target_dtype=np.dtype(np.uint8))</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def float2int_image(image, target_dtype=np.dtype(np.uint8)):\n    source_dtype = image.dtype\n    if source_dtype.kind not in ('i', 'u') and not target_dtype.kind == 'f':\n        maxval = 2 ** (8 * target_dtype.itemsize) - 1\n        return (image * maxval).astype(target_dtype)\n    else:\n        return image\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.get_best_level_factor","title":"<code>get_best_level_factor(source, target_pixel_size)</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def get_best_level_factor(source: OmeSource, target_pixel_size: list) -&gt; tuple:\n    # find best pixel_size level and corresponding factor\n    if source.source_pixel_size:\n        target_factor = np.divide(get_value_units_micrometer(source.source_pixel_size)[:2],\n                                  get_value_units_micrometer(target_pixel_size)[:2])\n    else:\n        target_factor = 1\n    best_level = 0\n    best_factor = None\n    for level, size in enumerate(source.sizes):\n        factor = np.divide(size, source.sizes[0])\n        if (np.all(factor &gt; target_factor)\n                or np.all(np.isclose(factor, target_factor, rtol=1e-4))\n                or best_factor is None):\n            best_level = level\n            best_factor = factor\n    return best_level, target_factor / best_factor, target_factor\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.get_best_size","title":"<code>get_best_size(sizes, target_size)</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def get_best_size(sizes: list, target_size: tuple) -&gt; tuple:\n    # find largest scale but smaller to 1\n    best_index = 0\n    best_scale = 0\n    for index, size in enumerate(sizes):\n        scale = np.mean(np.divide(target_size, size))\n        if 1 &gt;= scale &gt; best_scale:\n            best_index = index\n            best_scale = scale\n    return sizes[best_index], best_index\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.get_default","title":"<code>get_default(x, default)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_default(x, default):\n    return default if x is None else x\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.get_filetitle","title":"<code>get_filetitle(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_filetitle(filename: str) -&gt; str:\n    filebase = os.path.basename(filename)\n    title = os.path.splitext(filebase)[0].rstrip('.ome')\n    return title\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.get_image_quantile","title":"<code>get_image_quantile(image, quantile, axis=None)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_image_quantile(image: np.ndarray, quantile: float, axis=None) -&gt; float:\n    value = np.quantile(image, quantile, axis=axis).astype(image.dtype)\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.get_image_size_info","title":"<code>get_image_size_info(sizes_xyzct, pixel_nbytes, pixel_type, channels)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_image_size_info(sizes_xyzct: list, pixel_nbytes: int, pixel_type: np.dtype, channels: list) -&gt; str:\n    image_size_info = 'XYZCT:'\n    size = 0\n    for i, size_xyzct in enumerate(sizes_xyzct):\n        w, h, zs, cs, ts = size_xyzct\n        size += np.int64(pixel_nbytes) * w * h * zs * cs * ts\n        if i &gt; 0:\n            image_size_info += ','\n        image_size_info += f' {w} {h} {zs} {cs} {ts}'\n    image_size_info += f' Pixel type: {pixel_type} Uncompressed: {print_hbytes(size)}'\n    if sizes_xyzct[0][3] == 3:\n        channel_info = 'rgb'\n    else:\n        channel_info = ','.join([channel.get('Name', '') for channel in channels])\n    if channel_info != '':\n        image_size_info += f' Channels: {channel_info}'\n    return image_size_info\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.get_numpy_slicing","title":"<code>get_numpy_slicing(dimension_order, **slicing)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_numpy_slicing(dimension_order, **slicing):\n    slices = []\n    for axis in dimension_order:\n        index = slicing.get(axis)\n        index0 = slicing.get(axis + '0')\n        index1 = slicing.get(axis + '1')\n        if index0 is not None and index1 is not None:\n            slice1 = slice(int(index0), int(index1))\n        elif index is not None:\n            slice1 = int(index)\n        else:\n            slice1 = slice(None)\n        slices.append(slice1)\n    return tuple(slices)\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.get_pil_metadata","title":"<code>get_pil_metadata(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_pil_metadata(image: PIL.Image) -&gt; dict:\n    metadata = {}\n    exifdata = image.getexif()\n    for tag_id in exifdata:\n        tag = TAGS.get(tag_id, tag_id)\n        data = exifdata.get(tag_id)\n        if isinstance(data, bytes):\n            data = data.decode()\n        metadata[tag] = data\n    if metadata == {}:\n        metadata = image.info\n    return metadata\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.get_resolution_from_pixel_size","title":"<code>get_resolution_from_pixel_size(pixel_size)</code>","text":"Source code in <code>OmeSliCC\\OmeSource.py</code> <pre><code>def get_resolution_from_pixel_size(pixel_size: list) -&gt; tuple:\n    conversions = {\n        'cm': (1, 'centimeter'),\n        'mm': (1, 'millimeter'),\n        '\u00b5m': (1, 'micrometer'),\n        'um': (1, 'micrometer'),\n        'nm': (1000, 'micrometer'),\n        'nanometer': (1000, 'micrometer'),\n    }\n    resolutions = []\n    resolutions_unit = None\n    if len(pixel_size) &gt; 0:\n        units = []\n        for size, unit in pixel_size:\n            if size != 0 and size != 1:\n                resolution = 1 / size\n                resolutions.append(resolution)\n                if unit != '':\n                    units.append(unit)\n        if len(units) &gt; 0:\n            resolutions_unit = units[0]\n            if resolutions_unit in conversions:\n                conversion = conversions[resolutions_unit]\n                resolutions = list(np.multiply(resolutions, conversion[0]))\n                resolutions_unit = conversion[1]\n    if len(resolutions) == 0:\n        resolutions = None\n    return resolutions, resolutions_unit\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.get_tiff_pages","title":"<code>get_tiff_pages(tiff)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_tiff_pages(tiff: TiffFile) -&gt; list:\n    # TODO: review so this works for multi-level ome-tiff, tiff-stack, and z pages tiff, then later check for mmstack\n    pages = []\n    found = False\n    if tiff.series and not tiff.is_mmstack:\n        # has series\n        baseline = tiff.series[0]\n        for level in baseline.levels:\n            # has levels\n            level_pages = []\n            for page in level.pages:\n                found = True\n                level_pages.append(page)\n            if level_pages:\n                pages.append(level_pages)\n\n    if not found:\n        for page in tiff.pages:\n            pages.append(page)\n    return pages\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.get_value_units_micrometer","title":"<code>get_value_units_micrometer(value_units0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_value_units_micrometer(value_units0: list) -&gt; list:\n    conversions = {'nm': 1e-3, '\u00b5m': 1, 'um': 1, 'micrometer': 1, 'mm': 1e3, 'cm': 1e4, 'm': 1e6}\n    if value_units0 is None:\n        return None\n\n    values_um = []\n    for value_unit in value_units0:\n        if not (isinstance(value_unit, int) or isinstance(value_unit, float)):\n            value_um = value_unit[0] * conversions.get(value_unit[1], 1)\n        else:\n            value_um = value_unit\n        values_um.append(value_um)\n    return values_um\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.hexrgb_to_rgba","title":"<code>hexrgb_to_rgba(hexrgb)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def hexrgb_to_rgba(hexrgb: str) -&gt; list:\n    rgba = int_to_rgba(eval('0x' + hexrgb + 'FF'))\n    return rgba\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.image_reshape","title":"<code>image_reshape(image, target_size)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def image_reshape(image: np.ndarray, target_size: tuple) -&gt; np.ndarray:\n    tw, th = target_size\n    sh, sw = image.shape[0:2]\n    if sw &lt; tw or sh &lt; th:\n        dw = max(tw - sw, 0)\n        dh = max(th - sh, 0)\n        padding = [(0, dh), (0, dw)]\n        if len(image.shape) == 3:\n            padding += [(0, 0)]\n        image = np.pad(image, padding, 'edge')\n    if tw &lt; sw or th &lt; sh:\n        image = image[0:th, 0:tw]\n    return image\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.image_resize","title":"<code>image_resize(image, target_size0, dimension_order='yxc')</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def image_resize(image: np.ndarray, target_size0: tuple, dimension_order: str = 'yxc') -&gt; np.ndarray:\n    shape = image.shape\n    x_index = dimension_order.index('x')\n    y_index = dimension_order.index('y')\n    c_is_at_end = ('c' in dimension_order and dimension_order.endswith('c'))\n    size = shape[x_index], shape[y_index]\n    if np.mean(np.divide(size, target_size0)) &lt; 1:\n        interpolation = cv.INTER_CUBIC\n    else:\n        interpolation = cv.INTER_AREA\n    dtype0 = image.dtype\n    image = ensure_unsigned_image(image)\n    target_size = tuple(np.maximum(np.round(target_size0).astype(int), 1))\n    if dimension_order in ['yxc', 'yx']:\n        new_image = cv.resize(np.asarray(image), target_size, interpolation=interpolation)\n    elif dimension_order == 'cyx':\n        new_image = np.moveaxis(image, 0, -1)\n        new_image = cv.resize(np.asarray(new_image), target_size, interpolation=interpolation)\n        new_image = np.moveaxis(new_image, -1, 0)\n    else:\n        ts = image.shape[dimension_order.index('t')] if 't' in dimension_order else 1\n        zs = image.shape[dimension_order.index('z')] if 'z' in dimension_order else 1\n        target_shape = list(image.shape).copy()\n        target_shape[x_index] = target_size[0]\n        target_shape[y_index] = target_size[1]\n        new_image = np.zeros(target_shape, dtype=image.dtype)\n        for t in range(ts):\n            for z in range(zs):\n                slices = get_numpy_slicing(dimension_order, z=z, t=t)\n                image1 = image[slices]\n                if not c_is_at_end:\n                    image1 = np.moveaxis(image1, 0, -1)\n                new_image1 = np.atleast_3d(cv.resize(np.asarray(image1), target_size, interpolation=interpolation))\n                if not c_is_at_end:\n                    new_image1 = np.moveaxis(new_image1, -1, 0)\n                new_image[slices] = new_image1\n    new_image = convert_image_sign_type(new_image, dtype0)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.int2float_image","title":"<code>int2float_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def int2float_image(image):\n    source_dtype = image.dtype\n    if not source_dtype.kind == 'f':\n        maxval = 2 ** (8 * source_dtype.itemsize) - 1\n        return image / np.float32(maxval)\n    else:\n        return image\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.int_to_rgba","title":"<code>int_to_rgba(intrgba)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def int_to_rgba(intrgba: int) -&gt; list:\n    signed = (intrgba &lt; 0)\n    rgba = [x / 255 for x in intrgba.to_bytes(4, signed=signed, byteorder=\"big\")]\n    if rgba[-1] == 0:\n        rgba[-1] = 1\n    return rgba\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.normalise_values","title":"<code>normalise_values(image, min_value, max_value)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def normalise_values(image: np.ndarray, min_value: float, max_value: float) -&gt; np.ndarray:\n    return np.clip((image.astype(np.float32) - min_value) / (max_value - min_value), 0, 1)\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.pilmode_to_pixelinfo","title":"<code>pilmode_to_pixelinfo(mode)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def pilmode_to_pixelinfo(mode: str) -&gt; tuple:\n    pixelinfo = (np.uint8, 8, 1)\n    mode_types = {\n        'I': (np.uint32, 32, 1),\n        'F': (np.float32, 32, 1),\n        'RGB': (np.uint8, 24, 3),\n        'RGBA': (np.uint8, 32, 4),\n        'CMYK': (np.uint8, 32, 4),\n        'YCbCr': (np.uint8, 24, 3),\n        'LAB': (np.uint8, 24, 3),\n        'HSV': (np.uint8, 24, 3),\n    }\n    if '16' in mode:\n        pixelinfo = (np.uint16, 16, 1)\n    elif '32' in mode:\n        pixelinfo = (np.uint32, 32, 1)\n    elif mode in mode_types:\n        pixelinfo = mode_types[mode]\n    pixelinfo = (np.dtype(pixelinfo[0]), pixelinfo[1])\n    return pixelinfo\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.precise_resize","title":"<code>precise_resize(image, factors)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def precise_resize(image: np.ndarray, factors) -&gt; np.ndarray:\n    if image.ndim &gt; len(factors):\n        factors = list(factors) + [1]\n    new_image = downscale_local_mean(np.asarray(image), tuple(factors)).astype(image.dtype)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.print_dict","title":"<code>print_dict(dct, indent=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_dict(dct: dict, indent: int = 0) -&gt; str:\n    s = ''\n    if isinstance(dct, dict):\n        for key, value in dct.items():\n            s += '\\n'\n            if not isinstance(value, list):\n                s += '\\t' * indent + str(key) + ': '\n            if isinstance(value, dict):\n                s += print_dict(value, indent=indent + 1)\n            elif isinstance(value, list):\n                for v in value:\n                    s += print_dict(v)\n            else:\n                s += str(value)\n    else:\n        s += str(dct)\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.print_hbytes","title":"<code>print_hbytes(nbytes)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_hbytes(nbytes: int) -&gt; str:\n    exps = ['', 'K', 'M', 'G', 'T']\n    div = 1024\n    exp = 0\n\n    while nbytes &gt; div:\n        nbytes /= div\n        exp += 1\n    return f'{nbytes:.1f}{exps[exp]}B'\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.redimension_data","title":"<code>redimension_data(data, old_order, new_order, **indices)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def redimension_data(data, old_order, new_order, **indices):\n    # able to provide optional dimension values e.g. t=0, z=0\n    if new_order == old_order:\n        return data\n\n    new_data = data\n    order = old_order\n    # remove\n    for o in old_order:\n        if o not in new_order:\n            index = order.index(o)\n            dim_value = indices.get(o, 0)\n            new_data = np.take(new_data, indices=dim_value, axis=index)\n            order = order[:index] + order[index + 1:]\n    # add\n    for o in new_order:\n        if o not in order:\n            new_data = np.expand_dims(new_data, 0)\n            order = o + order\n    # move\n    old_indices = [order.index(o) for o in new_order]\n    new_indices = list(range(len(new_order)))\n    new_data = np.moveaxis(new_data, old_indices, new_indices)\n    return new_data\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.reorder","title":"<code>reorder(items, old_order, new_order, default_value=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def reorder(items: list, old_order: str, new_order: str, default_value: int = 0) -&gt; list:\n    new_items = []\n    for label in new_order:\n        if label in old_order:\n            item = items[old_order.index(label)]\n        else:\n            item = default_value\n        new_items.append(item)\n    return new_items\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.rgba_to_hexrgb","title":"<code>rgba_to_hexrgb(rgba)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def rgba_to_hexrgb(rgba: list) -&gt; str:\n    hexrgb = ''.join([hex(int(x * 255))[2:].upper().zfill(2) for x in rgba[:3]])\n    return hexrgb\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.rgba_to_int","title":"<code>rgba_to_int(rgba)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def rgba_to_int(rgba: list) -&gt; int:\n    intrgba = int.from_bytes([int(x * 255) for x in rgba], signed=True, byteorder=\"big\")\n    return intrgba\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.round_significants","title":"<code>round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def round_significants(a: float, significant_digits: int) -&gt; float:\n    if a != 0:\n        round_decimals = significant_digits - int(np.floor(np.log10(abs(a)))) - 1\n        return round(a, round_decimals)\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.save_image","title":"<code>save_image(image, filename, output_params={})</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def save_image(image: np.ndarray, filename: str, output_params: dict = {}):\n    compression = output_params.get('compression')\n    PIL.Image.fromarray(image).save(filename, compression=compression)\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.show_image","title":"<code>show_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def show_image(image: np.ndarray):\n    plt.imshow(image)\n    plt.show()\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.show_image_gray","title":"<code>show_image_gray(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def show_image_gray(image: np.ndarray):\n    plt.imshow(image, cmap='gray')\n    plt.show()\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.split_num_text","title":"<code>split_num_text(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_num_text(text: str) -&gt; list:\n    num_texts = []\n    block = ''\n    is_num0 = None\n    if text is None:\n        return None\n\n    for c in text:\n        is_num = (c.isnumeric() or c == '.')\n        if is_num0 is not None and is_num != is_num0:\n            num_texts.append(block)\n            block = ''\n        block += c\n        is_num0 = is_num\n    if block != '':\n        num_texts.append(block)\n\n    num_texts2 = []\n    for block in num_texts:\n        block = block.strip()\n        try:\n            block = float(block)\n        except:\n            pass\n        if block not in [' ', ',', '|']:\n            num_texts2.append(block)\n    return num_texts2\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.split_value_unit_list","title":"<code>split_value_unit_list(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_value_unit_list(text: str) -&gt; list:\n    value_units = []\n    if text is None:\n        return None\n\n    items = split_num_text(text)\n    if isinstance(items[-1], str):\n        def_unit = items[-1]\n    else:\n        def_unit = ''\n\n    i = 0\n    while i &lt; len(items):\n        value = items[i]\n        if i + 1 &lt; len(items):\n            unit = items[i + 1]\n        else:\n            unit = ''\n        if not isinstance(value, str):\n            if isinstance(unit, str):\n                i += 1\n            else:\n                unit = def_unit\n            value_units.append((value, unit))\n        i += 1\n    return value_units\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.tags_to_dict","title":"<code>tags_to_dict(tags)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tags_to_dict(tags: tifffile.TiffTags) -&gt; dict:\n    tag_dict = {}\n    for tag in tags.values():\n        tag_dict[tag.name] = tag.value\n    return tag_dict\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.tiff_info","title":"<code>tiff_info(filename)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tiff_info(filename: str) -&gt; str:\n    s = ''\n    nom_size = 0\n    tiff = TiffFile(filename)\n    real_size = tiff.fstat.st_size\n    s += str(tiff) + '\\n'\n    if tiff.ome_metadata:\n        print(tiff.ome_metadata)\n        s += f'OME: {print_dict(tifffile.xml2dict(tiff.ome_metadata))}\\n'\n    if tiff.metaseries_metadata:\n        s += f'Series: {tiff.metaseries_metadata}\\n'\n    if tiff.imagej_metadata:\n        s += f'ImageJ: {tiff.imagej_metadata}\\n'\n\n    for page0 in get_tiff_pages(tiff):\n        page = page0[0] if isinstance(page0, list) else page0\n        s += str(page) + '\\n'\n        s += f'Size: {np.flip(page.shape)} ({print_hbytes(page.size)})\\n'\n        if page.is_tiled:\n            s += f'Tiling: {page.tilewidth} {page.tilelength} {page.tiledepth}\\n'\n        s += f'Compression: {str(page.compression)} jpegtables: {page.jpegtables is not None}\\n'\n        tag_dict = tags_to_dict(page.tags)\n        if 'TileOffsets' in tag_dict:\n            tag_dict.pop('TileOffsets')\n        if 'TileByteCounts' in tag_dict:\n            tag_dict.pop('TileByteCounts')\n        if 'ImageDescription' in tag_dict and tag_dict['ImageDescription'].startswith('&lt;?xml'):\n            # redundant\n            tag_dict.pop('ImageDescription')\n        s += print_dict(tag_dict) + '\\n\\n'\n        nom_size += page.size\n\n    s += f'Overall compression: 1:{nom_size / real_size:.1f}'\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.OmeSource.tiff_info_short","title":"<code>tiff_info_short(filename)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tiff_info_short(filename: str) -&gt; str:\n    nom_size = 0\n    tiff = TiffFile(filename)\n    s = str(filename)\n    real_size = tiff.fstat.st_size\n    for page in tiff.pages:\n        s += ' ' + str(page)\n        nom_size += page.size\n    s += f' Image size:{nom_size} File size:{real_size} Overall compression: 1:{nom_size / real_size:.1f}'\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr","title":"<code>OmeZarr</code>","text":""},{"location":"references/#OmeSliCC.OmeZarr.OmeZarr","title":"<code>OmeZarr</code>","text":"Source code in <code>OmeSliCC\\OmeZarr.py</code> <pre><code>class OmeZarr:\n    def __init__(self, filename):\n        self.filename = filename\n\n    def write(self, sources, tile_size=[], compression=[],\n              npyramid_add=0, pyramid_downsample=2, translations=[],\n              image_operations=[]):\n\n        compressor, compression_filters = create_compression_filter(compression)\n        storage_options = {'dimension_separator': '/', 'chunks': tile_size}\n        ome_version = '0.4'\n        # Zarr V3 testing\n        #storage_options = {'chunks': tile_size}\n        if compressor is not None:\n            storage_options['compressor'] = compressor\n        if compression_filters is not None:\n            storage_options['filters'] = compression_filters\n        self.storage_options = storage_options\n\n        zarr_root = zarr.open_group(store=parse_url(self.filename, mode=\"w\").store, mode=\"w\", storage_options=storage_options)\n        # Zarr V3 testing\n        #zarr_root = zarr.open_group(store=parse_url(self.filename, mode=\"w\").store, mode=\"w\", zarr_version=3)\n        root_path = ''\n\n        multiple_images = isinstance(sources, list)\n        multi_metadata = []\n        if not multiple_images:\n            sources = [sources]\n\n        for index, source in enumerate(sources):\n            data = source.asarray()\n            for image_operation in image_operations:\n                data = image_operation(data)\n            if multiple_images:\n                root_path = str(index)\n                root = zarr_root.create_group(root_path)\n            else:\n                root = zarr_root\n            if index &lt; len(translations):\n                translation_um = translations[index]\n            else:\n                translation_um = source.get_position_micrometer()\n            self.write_dataset(root, data, source, npyramid_add, pyramid_downsample, translation_um)\n            if multiple_images:\n                meta = root.attrs['multiscales'][0].copy()\n                for dataset_meta in meta['datasets']:\n                    dataset_meta['path'] = f'{root_path}/{dataset_meta[\"path\"]}'\n                multi_metadata.append(meta)\n        if multiple_images:\n            zarr_root.attrs['multiscales'] = multi_metadata\n        zarr_root.attrs['omero'] = create_channel_metadata(sources[0], ome_version)\n\n    def write_dataset(self, zarr_root, data, source,\n                      npyramid_add=0, pyramid_downsample=2, translation_um=[]):\n\n        pixel_size_um = source.get_pixel_size_micrometer()\n        if len(pixel_size_um) == 0:\n            npyramid_add = 0\n\n        dimension_order = source.get_dimension_order()\n        if 'c' in dimension_order and dimension_order.index('c') == len(dimension_order) - 1:\n            # ome-zarr doesn't support channel after space dimensions (yet)\n            data = np.moveaxis(data, -1, 0)\n            dimension_order = dimension_order[-1] + dimension_order[:-1]\n\n        axes = create_axes_metadata(dimension_order)\n\n        pixel_size_scales = []\n        scale = 1\n        for i in range(npyramid_add + 1):\n            pixel_size_scales.append(create_transformation_metadata(dimension_order, pixel_size_um, scale, translation_um))\n            if pyramid_downsample:\n                scale /= pyramid_downsample\n\n        write_image(image=data, group=zarr_root, axes=axes, coordinate_transformations=pixel_size_scales,\n                    scaler=Scaler(downscale=pyramid_downsample, max_layer=npyramid_add), overwrite=True)\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.OmeZarr.filename","title":"<code>filename = filename</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.OmeZarr.OmeZarr.__init__","title":"<code>__init__(filename)</code>","text":"Source code in <code>OmeSliCC\\OmeZarr.py</code> <pre><code>def __init__(self, filename):\n    self.filename = filename\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.OmeZarr.write","title":"<code>write(sources, tile_size=[], compression=[], npyramid_add=0, pyramid_downsample=2, translations=[], image_operations=[])</code>","text":"Source code in <code>OmeSliCC\\OmeZarr.py</code> <pre><code>def write(self, sources, tile_size=[], compression=[],\n          npyramid_add=0, pyramid_downsample=2, translations=[],\n          image_operations=[]):\n\n    compressor, compression_filters = create_compression_filter(compression)\n    storage_options = {'dimension_separator': '/', 'chunks': tile_size}\n    ome_version = '0.4'\n    # Zarr V3 testing\n    #storage_options = {'chunks': tile_size}\n    if compressor is not None:\n        storage_options['compressor'] = compressor\n    if compression_filters is not None:\n        storage_options['filters'] = compression_filters\n    self.storage_options = storage_options\n\n    zarr_root = zarr.open_group(store=parse_url(self.filename, mode=\"w\").store, mode=\"w\", storage_options=storage_options)\n    # Zarr V3 testing\n    #zarr_root = zarr.open_group(store=parse_url(self.filename, mode=\"w\").store, mode=\"w\", zarr_version=3)\n    root_path = ''\n\n    multiple_images = isinstance(sources, list)\n    multi_metadata = []\n    if not multiple_images:\n        sources = [sources]\n\n    for index, source in enumerate(sources):\n        data = source.asarray()\n        for image_operation in image_operations:\n            data = image_operation(data)\n        if multiple_images:\n            root_path = str(index)\n            root = zarr_root.create_group(root_path)\n        else:\n            root = zarr_root\n        if index &lt; len(translations):\n            translation_um = translations[index]\n        else:\n            translation_um = source.get_position_micrometer()\n        self.write_dataset(root, data, source, npyramid_add, pyramid_downsample, translation_um)\n        if multiple_images:\n            meta = root.attrs['multiscales'][0].copy()\n            for dataset_meta in meta['datasets']:\n                dataset_meta['path'] = f'{root_path}/{dataset_meta[\"path\"]}'\n            multi_metadata.append(meta)\n    if multiple_images:\n        zarr_root.attrs['multiscales'] = multi_metadata\n    zarr_root.attrs['omero'] = create_channel_metadata(sources[0], ome_version)\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.OmeZarr.write_dataset","title":"<code>write_dataset(zarr_root, data, source, npyramid_add=0, pyramid_downsample=2, translation_um=[])</code>","text":"Source code in <code>OmeSliCC\\OmeZarr.py</code> <pre><code>def write_dataset(self, zarr_root, data, source,\n                  npyramid_add=0, pyramid_downsample=2, translation_um=[]):\n\n    pixel_size_um = source.get_pixel_size_micrometer()\n    if len(pixel_size_um) == 0:\n        npyramid_add = 0\n\n    dimension_order = source.get_dimension_order()\n    if 'c' in dimension_order and dimension_order.index('c') == len(dimension_order) - 1:\n        # ome-zarr doesn't support channel after space dimensions (yet)\n        data = np.moveaxis(data, -1, 0)\n        dimension_order = dimension_order[-1] + dimension_order[:-1]\n\n    axes = create_axes_metadata(dimension_order)\n\n    pixel_size_scales = []\n    scale = 1\n    for i in range(npyramid_add + 1):\n        pixel_size_scales.append(create_transformation_metadata(dimension_order, pixel_size_um, scale, translation_um))\n        if pyramid_downsample:\n            scale /= pyramid_downsample\n\n    write_image(image=data, group=zarr_root, axes=axes, coordinate_transformations=pixel_size_scales,\n                scaler=Scaler(downscale=pyramid_downsample, max_layer=npyramid_add), overwrite=True)\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.blur_image","title":"<code>blur_image(image, sigma)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def blur_image(image, sigma):\n    nchannels = image.shape[2] if image.ndim == 3 else 1\n    if nchannels not in [1, 3]:\n        new_image = np.zeros_like(image)\n        for channeli in range(nchannels):\n            new_image[..., channeli] = blur_image_single(image[..., channeli], sigma)\n    else:\n        new_image = blur_image_single(image, sigma)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.blur_image_single","title":"<code>blur_image_single(image, sigma)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def blur_image_single(image, sigma):\n    return gaussian_filter(image, sigma)\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.calc_fraction_used","title":"<code>calc_fraction_used(image, threshold=0.1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_fraction_used(image: np.ndarray, threshold: float = 0.1) -&gt; float:\n    low = int(round(threshold * 255))\n    high = int(round((1 - threshold) * 255))\n    shape = image.shape\n    total = shape[0] * shape[1]\n    good = 0\n    for y in range(shape[0]):\n        for x in range(shape[1]):\n            pixel = image[y, x]\n            if low &lt;= pixel[0] &lt; high and low &lt;= pixel[1] &lt; high and low &lt;= pixel[2] &lt; high:\n                good += 1\n    fraction = good / total\n    return fraction\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.calc_pyramid","title":"<code>calc_pyramid(xyzct, npyramid_add=0, pyramid_downsample=2, volumetric_resize=False)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_pyramid(xyzct: tuple, npyramid_add: int = 0, pyramid_downsample: float = 2,\n                 volumetric_resize: bool = False) -&gt; list:\n    x, y, z, c, t = xyzct\n    if volumetric_resize and z &gt; 1:\n        size = (x, y, z)\n    else:\n        size = (x, y)\n    sizes_add = []\n    scale = 1\n    for _ in range(npyramid_add):\n        scale /= pyramid_downsample\n        scaled_size = np.maximum(np.round(np.multiply(size, scale)).astype(int), 1)\n        sizes_add.append(scaled_size)\n    return sizes_add\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.calc_tiles_median","title":"<code>calc_tiles_median(images)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_tiles_median(images):\n    out_image = np.zeros_like(images[0])\n    median_image = np.median(images, 0, out_image)\n    return median_image\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.calc_tiles_quantiles","title":"<code>calc_tiles_quantiles(images, quantiles)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_tiles_quantiles(images, quantiles):\n    out_quantiles = []\n    quantile_images = np.quantile(images, quantiles, 0)\n    for quantile_image in quantile_images:\n        maxval = 2 ** (8 * images[0].dtype.itemsize) - 1\n        image = (quantile_image / maxval).astype(np.float32)\n        out_quantiles.append(image)\n    return out_quantiles\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.check_round_significants","title":"<code>check_round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def check_round_significants(a: float, significant_digits: int) -&gt; float:\n    rounded = round_significants(a, significant_digits)\n    if a != 0:\n        dif = 1 - rounded / a\n    else:\n        dif = rounded - a\n    if abs(dif) &lt; 10 ** -significant_digits:\n        return rounded\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.check_versions","title":"<code>check_versions()</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def check_versions():\n    print(f'tifffile {tifffile.__version__}')\n    print(imagecodecs.version())\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.compare_image","title":"<code>compare_image(image0, image1, show=False)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image(image0, image1, show=False) -&gt; float:\n    dif, dif_max, dif_mean, psnr = compare_image_dist(image0, image1)\n    print(f'rgb dist max: {dif_max:.1f} mean: {dif_mean:.1f} PSNR: {psnr:.1f}')\n    if show:\n        show_image(dif)\n        show_image((dif * 10).astype(np.uint8))\n    return dif\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.compare_image_dist","title":"<code>compare_image_dist(image0, image1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image_dist(image0: np.ndarray, image1: np.ndarray) -&gt; tuple:\n    dif = cv.absdiff(image0, image1)\n    psnr = cv.PSNR(image0, image1)\n    if dif.size &gt; 1000000000:\n        # split very large array\n        rgb_maxs = []\n        rgb_means = []\n        for dif1 in np.array_split(dif, 16):\n            rgb_dif = np.linalg.norm(dif1, axis=2)\n            rgb_maxs.append(np.max(rgb_dif))\n            rgb_means.append(np.mean(rgb_dif))\n        rgb_max = np.max(rgb_maxs)\n        rgb_mean = np.mean(rgb_means)\n    else:\n        rgb_dif = np.linalg.norm(dif, axis=2)\n        rgb_max = np.max(rgb_dif)\n        rgb_mean = np.mean(rgb_dif)\n    return dif, rgb_max, rgb_mean, psnr\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.compare_image_dist_simple","title":"<code>compare_image_dist_simple(image0, image1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image_dist_simple(image0: np.ndarray, image1: np.ndarray) -&gt; dict:\n    dif = cv.absdiff(image0, image1)\n    psnr = cv.PSNR(image0, image1)\n    rgb_dif = np.linalg.norm(dif, axis=2)\n    dif_max = np.max(rgb_dif)\n    dif_mean = np.mean(rgb_dif)\n    return {'dif_max': dif_max, 'dif_mean': dif_mean, 'psnr': psnr}\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.convert_image_sign_type","title":"<code>convert_image_sign_type(image, target_dtype)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def convert_image_sign_type(image: np.ndarray, target_dtype: np.dtype) -&gt; np.ndarray:\n    source_dtype = image.dtype\n    if source_dtype.kind == target_dtype.kind:\n        new_image = image\n    elif source_dtype.kind == 'i':\n        new_image = ensure_unsigned_image(image)\n    else:\n        # conversion without overhead\n        offset = 2 ** (8 * target_dtype.itemsize - 1)\n        new_image = (image - offset).astype(target_dtype)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.convert_rational_value","title":"<code>convert_rational_value(value)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def convert_rational_value(value) -&gt; float:\n    if value is not None and isinstance(value, tuple):\n        value = value[0] / value[1]\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.create_axes_metadata","title":"<code>create_axes_metadata(dimension_order)</code>","text":"Source code in <code>OmeSliCC\\ome_zarr_util.py</code> <pre><code>def create_axes_metadata(dimension_order):\n    axes = []\n    for dimension in dimension_order:\n        unit1 = None\n        if dimension == 't':\n            type1 = 'time'\n            unit1 = 'millisecond'\n        elif dimension == 'c':\n            type1 = 'channel'\n        else:\n            type1 = 'space'\n            unit1 = 'micrometer'\n        axis = {'name': dimension, 'type': type1}\n        if unit1 is not None and unit1 != '':\n            axis['unit'] = unit1\n        axes.append(axis)\n    return axes\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.create_channel_metadata","title":"<code>create_channel_metadata(source, ome_version)</code>","text":"Source code in <code>OmeSliCC\\ome_zarr_util.py</code> <pre><code>def create_channel_metadata(source, ome_version):\n    channels = source.get_channels()\n    nchannels = source.get_nchannels()\n\n    if len(channels) &lt; nchannels == 3:\n        labels = ['Red', 'Green', 'Blue']\n        colors = [(1, 0, 0, 1), (0, 1, 0, 1), (0, 0, 1, 1)]\n        channels = [{'label': label, 'color': color} for label, color in zip(labels, colors)]\n\n    omezarr_channels = []\n    for channeli, channel0 in enumerate(channels):\n        channel = channel0.copy()\n        color = channel.get('color', (1, 1, 1, 1))\n        channel['color'] = rgba_to_hexrgb(color)\n        if 'window' not in channel:\n            channel['window'] = source.get_channel_window(channeli)\n        omezarr_channels.append(channel)\n\n    metadata = {\n        'version': ome_version,\n        'channels': omezarr_channels,\n    }\n    return metadata\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.create_compression_codecs","title":"<code>create_compression_codecs(compression)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def create_compression_codecs(compression: list) -&gt; list:\n    codecs = None\n    compression = ensure_list(compression)\n    if compression is not None and len(compression) &gt; 0:\n        compression_type = compression[0].lower()\n        if len(compression) &gt; 1:\n            level = int(compression[1])\n        else:\n            level = None\n        if 'lzw' in compression_type:\n            from imagecodecs.numcodecs import Lzw\n            codecs = [Lzw()]\n        elif '2k' in compression_type or '2000' in compression_type:\n            from imagecodecs.numcodecs import Jpeg2k\n            codecs = [Jpeg2k(level=level)]\n        elif 'jpegls' in compression_type:\n            from imagecodecs.numcodecs import Jpegls\n            codecs = [Jpegls(level=level)]\n        elif 'jpegxr' in compression_type:\n            from imagecodecs.numcodecs import Jpegxr\n            codecs = [Jpegxr(level=level)]\n        elif 'jpegxl' in compression_type:\n            from imagecodecs.numcodecs import Jpegxl\n            codecs = [Jpegxl(level=level)]\n        else:\n            codecs = [compression]\n    return codecs\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.create_compression_filter","title":"<code>create_compression_filter(compression)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def create_compression_filter(compression: list) -&gt; tuple:\n    compressor, compression_filters = None, None\n    compression = ensure_list(compression)\n    if compression is not None and len(compression) &gt; 0:\n        compression_type = compression[0].lower()\n        if len(compression) &gt; 1:\n            level = int(compression[1])\n        else:\n            level = None\n        if 'lzw' in compression_type:\n            from imagecodecs.numcodecs import Lzw\n            compression_filters = [Lzw()]\n        elif '2k' in compression_type or '2000' in compression_type:\n            from imagecodecs.numcodecs import Jpeg2k\n            compression_filters = [Jpeg2k(level=level)]\n        elif 'jpegls' in compression_type:\n            from imagecodecs.numcodecs import Jpegls\n            compression_filters = [Jpegls(level=level)]\n        elif 'jpegxr' in compression_type:\n            from imagecodecs.numcodecs import Jpegxr\n            compression_filters = [Jpegxr(level=level)]\n        elif 'jpegxl' in compression_type:\n            from imagecodecs.numcodecs import Jpegxl\n            compression_filters = [Jpegxl(level=level)]\n        else:\n            compressor = compression\n    return compressor, compression_filters\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.create_transformation_metadata","title":"<code>create_transformation_metadata(dimension_order, pixel_size_um, scale, translation_um=[])</code>","text":"Source code in <code>OmeSliCC\\ome_zarr_util.py</code> <pre><code>def create_transformation_metadata(dimension_order, pixel_size_um, scale, translation_um=[]):\n    metadata = []\n    pixel_size_scale = []\n    translation_scale = []\n    for dimension in dimension_order:\n        if dimension == 'z' and len(pixel_size_um) &gt; 2:\n            pixel_size_scale1 = pixel_size_um[2]\n        elif dimension == 'y' and len(pixel_size_um) &gt; 1:\n            pixel_size_scale1 = pixel_size_um[1] / scale\n        elif dimension == 'x' and len(pixel_size_um) &gt; 0:\n            pixel_size_scale1 = pixel_size_um[0] / scale\n        else:\n            pixel_size_scale1 = 1\n        if pixel_size_scale1 == 0:\n            pixel_size_scale1 = 1\n        pixel_size_scale.append(pixel_size_scale1)\n\n        if dimension == 'z' and len(translation_um) &gt; 2:\n            translation1 = translation_um[2]\n        elif dimension == 'y' and len(translation_um) &gt; 1:\n            translation1 = translation_um[1] * scale\n        elif dimension == 'x' and len(translation_um) &gt; 0:\n            translation1 = translation_um[0] * scale\n        else:\n            translation1 = 0\n        translation_scale.append(translation1)\n\n    metadata.append({'type': 'scale', 'scale': pixel_size_scale})\n    if not all(v == 0 for v in translation_scale):\n        metadata.append({'type': 'translation', 'translation': translation_scale})\n    return metadata\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.desc_to_dict","title":"<code>desc_to_dict(desc)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def desc_to_dict(desc: str) -&gt; dict:\n    desc_dict = {}\n    if desc.startswith('{'):\n        try:\n            metadata = ast.literal_eval(desc)\n            return metadata\n        except:\n            pass\n    for item in re.split(r'[\\r\\n\\t|]', desc):\n        item_sep = '='\n        if ':' in item:\n            item_sep = ':'\n        if item_sep in item:\n            items = item.split(item_sep)\n            key = items[0].strip()\n            value = items[1].strip()\n            for dtype in (int, float, bool):\n                try:\n                    value = dtype(value)\n                    break\n                except:\n                    pass\n            desc_dict[key] = value\n    return desc_dict\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.ensure_list","title":"<code>ensure_list(x)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def ensure_list(x) -&gt; list:\n    if x is None:\n        return []\n    elif isinstance(x, list):\n        return x\n    else:\n        return [x]\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.ensure_unsigned_image","title":"<code>ensure_unsigned_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def ensure_unsigned_image(image: np.ndarray) -&gt; np.ndarray:\n    source_dtype = image.dtype\n    dtype = ensure_unsigned_type(source_dtype)\n    if dtype != source_dtype:\n        # conversion without overhead\n        offset = 2 ** (8 * dtype.itemsize - 1)\n        new_image = image.astype(dtype) + offset\n    else:\n        new_image = image\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.ensure_unsigned_type","title":"<code>ensure_unsigned_type(dtype)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def ensure_unsigned_type(dtype: np.dtype) -&gt; np.dtype:\n    new_dtype = dtype\n    if dtype.kind == 'i' or dtype.byteorder == '&gt;' or dtype.byteorder == '&lt;':\n        new_dtype = np.dtype(f'u{dtype.itemsize}')\n    return new_dtype\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.file_to_dict","title":"<code>file_to_dict(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def file_to_dict(filename: str) -&gt; dict:\n    ext = os.path.splitext(filename)[1]\n    content = open(filename, 'r').read()\n    if ext == '.xml':\n        data = xmltodict.parse(content)\n    elif ext in ['.yml', '.yaml']:\n        data = yaml.safe_load(content)\n    else:   # assume json\n        data = json.loads(content)\n    return data\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.filter_dict","title":"<code>filter_dict(dict0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def filter_dict(dict0: dict) -&gt; dict:\n    new_dict = {}\n    for key, value0 in dict0.items():\n        if value0 is not None:\n            values = []\n            for value in ensure_list(value0):\n                if isinstance(value, dict):\n                    value = filter_dict(value)\n                values.append(value)\n            if len(values) == 1:\n                values = values[0]\n            new_dict[key] = values\n    return new_dict\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.float2int_image","title":"<code>float2int_image(image, target_dtype=np.dtype(np.uint8))</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def float2int_image(image, target_dtype=np.dtype(np.uint8)):\n    source_dtype = image.dtype\n    if source_dtype.kind not in ('i', 'u') and not target_dtype.kind == 'f':\n        maxval = 2 ** (8 * target_dtype.itemsize) - 1\n        return (image * maxval).astype(target_dtype)\n    else:\n        return image\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.get_default","title":"<code>get_default(x, default)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_default(x, default):\n    return default if x is None else x\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.get_filetitle","title":"<code>get_filetitle(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_filetitle(filename: str) -&gt; str:\n    filebase = os.path.basename(filename)\n    title = os.path.splitext(filebase)[0].rstrip('.ome')\n    return title\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.get_image_quantile","title":"<code>get_image_quantile(image, quantile, axis=None)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_image_quantile(image: np.ndarray, quantile: float, axis=None) -&gt; float:\n    value = np.quantile(image, quantile, axis=axis).astype(image.dtype)\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.get_image_size_info","title":"<code>get_image_size_info(sizes_xyzct, pixel_nbytes, pixel_type, channels)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_image_size_info(sizes_xyzct: list, pixel_nbytes: int, pixel_type: np.dtype, channels: list) -&gt; str:\n    image_size_info = 'XYZCT:'\n    size = 0\n    for i, size_xyzct in enumerate(sizes_xyzct):\n        w, h, zs, cs, ts = size_xyzct\n        size += np.int64(pixel_nbytes) * w * h * zs * cs * ts\n        if i &gt; 0:\n            image_size_info += ','\n        image_size_info += f' {w} {h} {zs} {cs} {ts}'\n    image_size_info += f' Pixel type: {pixel_type} Uncompressed: {print_hbytes(size)}'\n    if sizes_xyzct[0][3] == 3:\n        channel_info = 'rgb'\n    else:\n        channel_info = ','.join([channel.get('Name', '') for channel in channels])\n    if channel_info != '':\n        image_size_info += f' Channels: {channel_info}'\n    return image_size_info\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.get_numpy_slicing","title":"<code>get_numpy_slicing(dimension_order, **slicing)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_numpy_slicing(dimension_order, **slicing):\n    slices = []\n    for axis in dimension_order:\n        index = slicing.get(axis)\n        index0 = slicing.get(axis + '0')\n        index1 = slicing.get(axis + '1')\n        if index0 is not None and index1 is not None:\n            slice1 = slice(int(index0), int(index1))\n        elif index is not None:\n            slice1 = int(index)\n        else:\n            slice1 = slice(None)\n        slices.append(slice1)\n    return tuple(slices)\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.get_pil_metadata","title":"<code>get_pil_metadata(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_pil_metadata(image: PIL.Image) -&gt; dict:\n    metadata = {}\n    exifdata = image.getexif()\n    for tag_id in exifdata:\n        tag = TAGS.get(tag_id, tag_id)\n        data = exifdata.get(tag_id)\n        if isinstance(data, bytes):\n            data = data.decode()\n        metadata[tag] = data\n    if metadata == {}:\n        metadata = image.info\n    return metadata\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.get_tiff_pages","title":"<code>get_tiff_pages(tiff)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_tiff_pages(tiff: TiffFile) -&gt; list:\n    # TODO: review so this works for multi-level ome-tiff, tiff-stack, and z pages tiff, then later check for mmstack\n    pages = []\n    found = False\n    if tiff.series and not tiff.is_mmstack:\n        # has series\n        baseline = tiff.series[0]\n        for level in baseline.levels:\n            # has levels\n            level_pages = []\n            for page in level.pages:\n                found = True\n                level_pages.append(page)\n            if level_pages:\n                pages.append(level_pages)\n\n    if not found:\n        for page in tiff.pages:\n            pages.append(page)\n    return pages\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.get_value_units_micrometer","title":"<code>get_value_units_micrometer(value_units0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_value_units_micrometer(value_units0: list) -&gt; list:\n    conversions = {'nm': 1e-3, '\u00b5m': 1, 'um': 1, 'micrometer': 1, 'mm': 1e3, 'cm': 1e4, 'm': 1e6}\n    if value_units0 is None:\n        return None\n\n    values_um = []\n    for value_unit in value_units0:\n        if not (isinstance(value_unit, int) or isinstance(value_unit, float)):\n            value_um = value_unit[0] * conversions.get(value_unit[1], 1)\n        else:\n            value_um = value_unit\n        values_um.append(value_um)\n    return values_um\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.hexrgb_to_rgba","title":"<code>hexrgb_to_rgba(hexrgb)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def hexrgb_to_rgba(hexrgb: str) -&gt; list:\n    rgba = int_to_rgba(eval('0x' + hexrgb + 'FF'))\n    return rgba\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.image_reshape","title":"<code>image_reshape(image, target_size)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def image_reshape(image: np.ndarray, target_size: tuple) -&gt; np.ndarray:\n    tw, th = target_size\n    sh, sw = image.shape[0:2]\n    if sw &lt; tw or sh &lt; th:\n        dw = max(tw - sw, 0)\n        dh = max(th - sh, 0)\n        padding = [(0, dh), (0, dw)]\n        if len(image.shape) == 3:\n            padding += [(0, 0)]\n        image = np.pad(image, padding, 'edge')\n    if tw &lt; sw or th &lt; sh:\n        image = image[0:th, 0:tw]\n    return image\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.image_resize","title":"<code>image_resize(image, target_size0, dimension_order='yxc')</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def image_resize(image: np.ndarray, target_size0: tuple, dimension_order: str = 'yxc') -&gt; np.ndarray:\n    shape = image.shape\n    x_index = dimension_order.index('x')\n    y_index = dimension_order.index('y')\n    c_is_at_end = ('c' in dimension_order and dimension_order.endswith('c'))\n    size = shape[x_index], shape[y_index]\n    if np.mean(np.divide(size, target_size0)) &lt; 1:\n        interpolation = cv.INTER_CUBIC\n    else:\n        interpolation = cv.INTER_AREA\n    dtype0 = image.dtype\n    image = ensure_unsigned_image(image)\n    target_size = tuple(np.maximum(np.round(target_size0).astype(int), 1))\n    if dimension_order in ['yxc', 'yx']:\n        new_image = cv.resize(np.asarray(image), target_size, interpolation=interpolation)\n    elif dimension_order == 'cyx':\n        new_image = np.moveaxis(image, 0, -1)\n        new_image = cv.resize(np.asarray(new_image), target_size, interpolation=interpolation)\n        new_image = np.moveaxis(new_image, -1, 0)\n    else:\n        ts = image.shape[dimension_order.index('t')] if 't' in dimension_order else 1\n        zs = image.shape[dimension_order.index('z')] if 'z' in dimension_order else 1\n        target_shape = list(image.shape).copy()\n        target_shape[x_index] = target_size[0]\n        target_shape[y_index] = target_size[1]\n        new_image = np.zeros(target_shape, dtype=image.dtype)\n        for t in range(ts):\n            for z in range(zs):\n                slices = get_numpy_slicing(dimension_order, z=z, t=t)\n                image1 = image[slices]\n                if not c_is_at_end:\n                    image1 = np.moveaxis(image1, 0, -1)\n                new_image1 = np.atleast_3d(cv.resize(np.asarray(image1), target_size, interpolation=interpolation))\n                if not c_is_at_end:\n                    new_image1 = np.moveaxis(new_image1, -1, 0)\n                new_image[slices] = new_image1\n    new_image = convert_image_sign_type(new_image, dtype0)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.int2float_image","title":"<code>int2float_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def int2float_image(image):\n    source_dtype = image.dtype\n    if not source_dtype.kind == 'f':\n        maxval = 2 ** (8 * source_dtype.itemsize) - 1\n        return image / np.float32(maxval)\n    else:\n        return image\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.int_to_rgba","title":"<code>int_to_rgba(intrgba)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def int_to_rgba(intrgba: int) -&gt; list:\n    signed = (intrgba &lt; 0)\n    rgba = [x / 255 for x in intrgba.to_bytes(4, signed=signed, byteorder=\"big\")]\n    if rgba[-1] == 0:\n        rgba[-1] = 1\n    return rgba\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.normalise_values","title":"<code>normalise_values(image, min_value, max_value)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def normalise_values(image: np.ndarray, min_value: float, max_value: float) -&gt; np.ndarray:\n    return np.clip((image.astype(np.float32) - min_value) / (max_value - min_value), 0, 1)\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.pilmode_to_pixelinfo","title":"<code>pilmode_to_pixelinfo(mode)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def pilmode_to_pixelinfo(mode: str) -&gt; tuple:\n    pixelinfo = (np.uint8, 8, 1)\n    mode_types = {\n        'I': (np.uint32, 32, 1),\n        'F': (np.float32, 32, 1),\n        'RGB': (np.uint8, 24, 3),\n        'RGBA': (np.uint8, 32, 4),\n        'CMYK': (np.uint8, 32, 4),\n        'YCbCr': (np.uint8, 24, 3),\n        'LAB': (np.uint8, 24, 3),\n        'HSV': (np.uint8, 24, 3),\n    }\n    if '16' in mode:\n        pixelinfo = (np.uint16, 16, 1)\n    elif '32' in mode:\n        pixelinfo = (np.uint32, 32, 1)\n    elif mode in mode_types:\n        pixelinfo = mode_types[mode]\n    pixelinfo = (np.dtype(pixelinfo[0]), pixelinfo[1])\n    return pixelinfo\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.precise_resize","title":"<code>precise_resize(image, factors)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def precise_resize(image: np.ndarray, factors) -&gt; np.ndarray:\n    if image.ndim &gt; len(factors):\n        factors = list(factors) + [1]\n    new_image = downscale_local_mean(np.asarray(image), tuple(factors)).astype(image.dtype)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.print_dict","title":"<code>print_dict(dct, indent=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_dict(dct: dict, indent: int = 0) -&gt; str:\n    s = ''\n    if isinstance(dct, dict):\n        for key, value in dct.items():\n            s += '\\n'\n            if not isinstance(value, list):\n                s += '\\t' * indent + str(key) + ': '\n            if isinstance(value, dict):\n                s += print_dict(value, indent=indent + 1)\n            elif isinstance(value, list):\n                for v in value:\n                    s += print_dict(v)\n            else:\n                s += str(value)\n    else:\n        s += str(dct)\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.print_hbytes","title":"<code>print_hbytes(nbytes)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_hbytes(nbytes: int) -&gt; str:\n    exps = ['', 'K', 'M', 'G', 'T']\n    div = 1024\n    exp = 0\n\n    while nbytes &gt; div:\n        nbytes /= div\n        exp += 1\n    return f'{nbytes:.1f}{exps[exp]}B'\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.redimension_data","title":"<code>redimension_data(data, old_order, new_order, **indices)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def redimension_data(data, old_order, new_order, **indices):\n    # able to provide optional dimension values e.g. t=0, z=0\n    if new_order == old_order:\n        return data\n\n    new_data = data\n    order = old_order\n    # remove\n    for o in old_order:\n        if o not in new_order:\n            index = order.index(o)\n            dim_value = indices.get(o, 0)\n            new_data = np.take(new_data, indices=dim_value, axis=index)\n            order = order[:index] + order[index + 1:]\n    # add\n    for o in new_order:\n        if o not in order:\n            new_data = np.expand_dims(new_data, 0)\n            order = o + order\n    # move\n    old_indices = [order.index(o) for o in new_order]\n    new_indices = list(range(len(new_order)))\n    new_data = np.moveaxis(new_data, old_indices, new_indices)\n    return new_data\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.reorder","title":"<code>reorder(items, old_order, new_order, default_value=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def reorder(items: list, old_order: str, new_order: str, default_value: int = 0) -&gt; list:\n    new_items = []\n    for label in new_order:\n        if label in old_order:\n            item = items[old_order.index(label)]\n        else:\n            item = default_value\n        new_items.append(item)\n    return new_items\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.rgba_to_hexrgb","title":"<code>rgba_to_hexrgb(rgba)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def rgba_to_hexrgb(rgba: list) -&gt; str:\n    hexrgb = ''.join([hex(int(x * 255))[2:].upper().zfill(2) for x in rgba[:3]])\n    return hexrgb\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.rgba_to_int","title":"<code>rgba_to_int(rgba)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def rgba_to_int(rgba: list) -&gt; int:\n    intrgba = int.from_bytes([int(x * 255) for x in rgba], signed=True, byteorder=\"big\")\n    return intrgba\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.round_significants","title":"<code>round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def round_significants(a: float, significant_digits: int) -&gt; float:\n    if a != 0:\n        round_decimals = significant_digits - int(np.floor(np.log10(abs(a)))) - 1\n        return round(a, round_decimals)\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.save_image","title":"<code>save_image(image, filename, output_params={})</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def save_image(image: np.ndarray, filename: str, output_params: dict = {}):\n    compression = output_params.get('compression')\n    PIL.Image.fromarray(image).save(filename, compression=compression)\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.scale_dimensions_dict","title":"<code>scale_dimensions_dict(shape0, scale)</code>","text":"Source code in <code>OmeSliCC\\ome_zarr_util.py</code> <pre><code>def scale_dimensions_dict(shape0, scale):\n    shape = {}\n    if scale == 1:\n        return shape0\n    for dimension, shape1 in shape0.items():\n        if dimension[0] in ['x', 'y']:\n            shape1 = int(shape1 * scale)\n        shape[dimension] = shape1\n    return shape\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.scale_dimensions_xy","title":"<code>scale_dimensions_xy(shape0, dimension_order, scale)</code>","text":"Source code in <code>OmeSliCC\\ome_zarr_util.py</code> <pre><code>def scale_dimensions_xy(shape0, dimension_order, scale):\n    shape = []\n    if scale == 1:\n        return shape0\n    for shape1, dimension in zip(shape0, dimension_order):\n        if dimension[0] in ['x', 'y']:\n            shape1 = int(shape1 * scale)\n        shape.append(shape1)\n    return shape\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.show_image","title":"<code>show_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def show_image(image: np.ndarray):\n    plt.imshow(image)\n    plt.show()\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.show_image_gray","title":"<code>show_image_gray(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def show_image_gray(image: np.ndarray):\n    plt.imshow(image, cmap='gray')\n    plt.show()\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.split_num_text","title":"<code>split_num_text(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_num_text(text: str) -&gt; list:\n    num_texts = []\n    block = ''\n    is_num0 = None\n    if text is None:\n        return None\n\n    for c in text:\n        is_num = (c.isnumeric() or c == '.')\n        if is_num0 is not None and is_num != is_num0:\n            num_texts.append(block)\n            block = ''\n        block += c\n        is_num0 = is_num\n    if block != '':\n        num_texts.append(block)\n\n    num_texts2 = []\n    for block in num_texts:\n        block = block.strip()\n        try:\n            block = float(block)\n        except:\n            pass\n        if block not in [' ', ',', '|']:\n            num_texts2.append(block)\n    return num_texts2\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.split_value_unit_list","title":"<code>split_value_unit_list(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_value_unit_list(text: str) -&gt; list:\n    value_units = []\n    if text is None:\n        return None\n\n    items = split_num_text(text)\n    if isinstance(items[-1], str):\n        def_unit = items[-1]\n    else:\n        def_unit = ''\n\n    i = 0\n    while i &lt; len(items):\n        value = items[i]\n        if i + 1 &lt; len(items):\n            unit = items[i + 1]\n        else:\n            unit = ''\n        if not isinstance(value, str):\n            if isinstance(unit, str):\n                i += 1\n            else:\n                unit = def_unit\n            value_units.append((value, unit))\n        i += 1\n    return value_units\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.tags_to_dict","title":"<code>tags_to_dict(tags)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tags_to_dict(tags: tifffile.TiffTags) -&gt; dict:\n    tag_dict = {}\n    for tag in tags.values():\n        tag_dict[tag.name] = tag.value\n    return tag_dict\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.tiff_info","title":"<code>tiff_info(filename)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tiff_info(filename: str) -&gt; str:\n    s = ''\n    nom_size = 0\n    tiff = TiffFile(filename)\n    real_size = tiff.fstat.st_size\n    s += str(tiff) + '\\n'\n    if tiff.ome_metadata:\n        print(tiff.ome_metadata)\n        s += f'OME: {print_dict(tifffile.xml2dict(tiff.ome_metadata))}\\n'\n    if tiff.metaseries_metadata:\n        s += f'Series: {tiff.metaseries_metadata}\\n'\n    if tiff.imagej_metadata:\n        s += f'ImageJ: {tiff.imagej_metadata}\\n'\n\n    for page0 in get_tiff_pages(tiff):\n        page = page0[0] if isinstance(page0, list) else page0\n        s += str(page) + '\\n'\n        s += f'Size: {np.flip(page.shape)} ({print_hbytes(page.size)})\\n'\n        if page.is_tiled:\n            s += f'Tiling: {page.tilewidth} {page.tilelength} {page.tiledepth}\\n'\n        s += f'Compression: {str(page.compression)} jpegtables: {page.jpegtables is not None}\\n'\n        tag_dict = tags_to_dict(page.tags)\n        if 'TileOffsets' in tag_dict:\n            tag_dict.pop('TileOffsets')\n        if 'TileByteCounts' in tag_dict:\n            tag_dict.pop('TileByteCounts')\n        if 'ImageDescription' in tag_dict and tag_dict['ImageDescription'].startswith('&lt;?xml'):\n            # redundant\n            tag_dict.pop('ImageDescription')\n        s += print_dict(tag_dict) + '\\n\\n'\n        nom_size += page.size\n\n    s += f'Overall compression: 1:{nom_size / real_size:.1f}'\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarr.tiff_info_short","title":"<code>tiff_info_short(filename)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tiff_info_short(filename: str) -&gt; str:\n    nom_size = 0\n    tiff = TiffFile(filename)\n    s = str(filename)\n    real_size = tiff.fstat.st_size\n    for page in tiff.pages:\n        s += ' ' + str(page)\n        nom_size += page.size\n    s += f' Image size:{nom_size} File size:{real_size} Overall compression: 1:{nom_size / real_size:.1f}'\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarrSource","title":"<code>OmeZarrSource</code>","text":""},{"location":"references/#OmeSliCC.OmeZarrSource.OmeZarrSource","title":"<code>OmeZarrSource</code>","text":"<p>               Bases: <code>OmeSource</code></p> <p>Zarr-compatible image source</p> Source code in <code>OmeSliCC\\OmeZarrSource.py</code> <pre><code>class OmeZarrSource(OmeSource):\n    \"\"\"Zarr-compatible image source\"\"\"\n\n    filename: str\n    \"\"\"original filename / URL\"\"\"\n    levels: list\n    \"\"\"list of all image arrays for different sizes\"\"\"\n    level_scales: list\n    \"\"\"list of all image (xy) scales\"\"\"\n    shapes: list\n    \"\"\"list of image shapes\"\"\"\n    chunk_shapes: list\n    \"\"\"list of image chunk shapes\"\"\"\n\n    def __init__(self, filename: str,\n                 source_pixel_size: list = None,\n                 target_pixel_size: list = None,\n                 source_info_required: bool = False):\n\n        super().__init__()\n\n        self.levels = []\n        self.level_scales = []\n        self.shapes = []\n        self.chunk_shapes = []\n        nchannels = 1\n        try:\n            location = parse_url(filename)\n            if location is None:\n                raise FileNotFoundError(f'Error parsing ome-zarr file {filename}')\n            reader = Reader(location)\n            # nodes may include images, labels etc\n            nodes = list(reader())\n            # first node will be the image pixel data\n            if len(nodes) == 0:\n                raise FileNotFoundError(f'No image data found in ome-zarr file {filename}')\n            image_node = nodes[0]\n\n            self.metadata = image_node.metadata\n            # channel metadata from ome-zarr-py limited; get from root_attrs manually\n            self.root_metadata = reader.zarr.root_attrs\n\n            axes = self.metadata.get('axes', [])\n            self.dimension_order = ''.join([axis.get('name') for axis in axes])\n\n            for data in image_node.data:\n                self.levels.append(data)\n\n                xyzct = [1, 1, 1, 1, 1]\n                for i, n in enumerate(data.shape):\n                    xyzct_index = self.default_properties_order.index(self.dimension_order[i])\n                    xyzct[xyzct_index] = n\n                self.sizes_xyzct.append(xyzct)\n                self.sizes.append((xyzct[0], xyzct[1]))\n                self.pixel_types.append(data.dtype)\n                self.pixel_nbits.append(data.dtype.itemsize * 8)\n                self.level_scales.append(np.divide(self.sizes_xyzct[0][0], xyzct[0]))\n                self.shapes.append(np.flip(reorder(data.shape, self.dimension_order, self.default_properties_order)))\n                self.chunk_shapes.append(np.flip(reorder(data.chunksize, self.dimension_order, self.default_properties_order)))\n                nchannels = xyzct[3]\n        except Exception as e:\n            raise FileNotFoundError(f'Read error: {e}')\n\n        self.is_rgb = nchannels in (3, 4)\n\n        self._init_metadata(filename,\n                            source_pixel_size=source_pixel_size,\n                            target_pixel_size=target_pixel_size,\n                            source_info_required=source_info_required)\n\n    def _find_metadata(self):\n        pixel_size = []\n        position = []\n        channels = []\n        metadata = self.metadata\n        axes = self.dimension_order\n\n        units = [axis.get('unit', '') for axis in metadata.get('axes', [])]\n\n        scale1 = [1] * len(metadata.get('axes'))\n        position1 = [0] * len(metadata.get('axes'))\n        # get pixelsize using largest/first scale\n        transform = self.metadata.get('coordinateTransformations', [])\n        if transform:\n            for transform1 in transform[0]:\n                if transform1['type'] == 'scale':\n                    scale1 = transform1['scale']\n                if transform1['type'] == 'translation':\n                    position1 = transform1['translation']\n            for axis in 'xyz':\n                if axis in axes:\n                    index = axes.index(axis)\n                    pixel_size.append((scale1[index], units[index]))\n                    position.append((position1[index], units[index]))\n                else:\n                    pixel_size.append((1, ''))\n                    position.append((0, ''))\n        nchannels = self.sizes_xyzct[0][3]\n        # look for channel metadata\n        for data in self.root_metadata.values():\n            if isinstance(data, dict) and 'channels' in data:\n                channels = data['channels'].copy()\n                for channel in channels:\n                    color = channel.pop('color', '')\n                    if color != '':\n                        if isinstance(color, int):\n                            color = int_to_rgba(color)\n                        else:\n                            color = hexrgb_to_rgba(color)\n                        channel['color'] = color\n        if len(channels) == 0:\n            if self.is_rgb:\n                channels = [{'label': ''}]\n            else:\n                channels = [{'label': ''}] * nchannels\n        self.source_pixel_size = pixel_size\n        self.channels = channels\n        self.source_mag = 0\n        self.position = position\n\n    def get_source_dask(self):\n        return self.levels\n\n    def _asarray_level(self, level: int, **slicing) -&gt; np.ndarray:\n        redim = redimension_data(self.levels[level], self.dimension_order, self.get_dimension_order())\n        slices = get_numpy_slicing(self.get_dimension_order(), **slicing)\n        out = redim[slices]\n        return out\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarrSource.OmeZarrSource.chunk_shapes","title":"<code>chunk_shapes = []</code>  <code>instance-attribute</code>","text":"<p>list of image chunk shapes</p>"},{"location":"references/#OmeSliCC.OmeZarrSource.OmeZarrSource.dimension_order","title":"<code>dimension_order = ''.join([axis.get('name') for axis in axes])</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.OmeZarrSource.OmeZarrSource.filename","title":"<code>filename</code>  <code>instance-attribute</code>","text":"<p>original filename / URL</p>"},{"location":"references/#OmeSliCC.OmeZarrSource.OmeZarrSource.is_rgb","title":"<code>is_rgb = nchannels in (3, 4)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.OmeZarrSource.OmeZarrSource.level_scales","title":"<code>level_scales = []</code>  <code>instance-attribute</code>","text":"<p>list of all image (xy) scales</p>"},{"location":"references/#OmeSliCC.OmeZarrSource.OmeZarrSource.levels","title":"<code>levels = []</code>  <code>instance-attribute</code>","text":"<p>list of all image arrays for different sizes</p>"},{"location":"references/#OmeSliCC.OmeZarrSource.OmeZarrSource.metadata","title":"<code>metadata = image_node.metadata</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.OmeZarrSource.OmeZarrSource.root_metadata","title":"<code>root_metadata = reader.zarr.root_attrs</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.OmeZarrSource.OmeZarrSource.shapes","title":"<code>shapes = []</code>  <code>instance-attribute</code>","text":"<p>list of image shapes</p>"},{"location":"references/#OmeSliCC.OmeZarrSource.OmeZarrSource.__init__","title":"<code>__init__(filename, source_pixel_size=None, target_pixel_size=None, source_info_required=False)</code>","text":"Source code in <code>OmeSliCC\\OmeZarrSource.py</code> <pre><code>def __init__(self, filename: str,\n             source_pixel_size: list = None,\n             target_pixel_size: list = None,\n             source_info_required: bool = False):\n\n    super().__init__()\n\n    self.levels = []\n    self.level_scales = []\n    self.shapes = []\n    self.chunk_shapes = []\n    nchannels = 1\n    try:\n        location = parse_url(filename)\n        if location is None:\n            raise FileNotFoundError(f'Error parsing ome-zarr file {filename}')\n        reader = Reader(location)\n        # nodes may include images, labels etc\n        nodes = list(reader())\n        # first node will be the image pixel data\n        if len(nodes) == 0:\n            raise FileNotFoundError(f'No image data found in ome-zarr file {filename}')\n        image_node = nodes[0]\n\n        self.metadata = image_node.metadata\n        # channel metadata from ome-zarr-py limited; get from root_attrs manually\n        self.root_metadata = reader.zarr.root_attrs\n\n        axes = self.metadata.get('axes', [])\n        self.dimension_order = ''.join([axis.get('name') for axis in axes])\n\n        for data in image_node.data:\n            self.levels.append(data)\n\n            xyzct = [1, 1, 1, 1, 1]\n            for i, n in enumerate(data.shape):\n                xyzct_index = self.default_properties_order.index(self.dimension_order[i])\n                xyzct[xyzct_index] = n\n            self.sizes_xyzct.append(xyzct)\n            self.sizes.append((xyzct[0], xyzct[1]))\n            self.pixel_types.append(data.dtype)\n            self.pixel_nbits.append(data.dtype.itemsize * 8)\n            self.level_scales.append(np.divide(self.sizes_xyzct[0][0], xyzct[0]))\n            self.shapes.append(np.flip(reorder(data.shape, self.dimension_order, self.default_properties_order)))\n            self.chunk_shapes.append(np.flip(reorder(data.chunksize, self.dimension_order, self.default_properties_order)))\n            nchannels = xyzct[3]\n    except Exception as e:\n        raise FileNotFoundError(f'Read error: {e}')\n\n    self.is_rgb = nchannels in (3, 4)\n\n    self._init_metadata(filename,\n                        source_pixel_size=source_pixel_size,\n                        target_pixel_size=target_pixel_size,\n                        source_info_required=source_info_required)\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarrSource.OmeZarrSource._asarray_level","title":"<code>_asarray_level(level, **slicing)</code>","text":"Source code in <code>OmeSliCC\\OmeZarrSource.py</code> <pre><code>def _asarray_level(self, level: int, **slicing) -&gt; np.ndarray:\n    redim = redimension_data(self.levels[level], self.dimension_order, self.get_dimension_order())\n    slices = get_numpy_slicing(self.get_dimension_order(), **slicing)\n    out = redim[slices]\n    return out\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarrSource.OmeZarrSource._find_metadata","title":"<code>_find_metadata()</code>","text":"Source code in <code>OmeSliCC\\OmeZarrSource.py</code> <pre><code>def _find_metadata(self):\n    pixel_size = []\n    position = []\n    channels = []\n    metadata = self.metadata\n    axes = self.dimension_order\n\n    units = [axis.get('unit', '') for axis in metadata.get('axes', [])]\n\n    scale1 = [1] * len(metadata.get('axes'))\n    position1 = [0] * len(metadata.get('axes'))\n    # get pixelsize using largest/first scale\n    transform = self.metadata.get('coordinateTransformations', [])\n    if transform:\n        for transform1 in transform[0]:\n            if transform1['type'] == 'scale':\n                scale1 = transform1['scale']\n            if transform1['type'] == 'translation':\n                position1 = transform1['translation']\n        for axis in 'xyz':\n            if axis in axes:\n                index = axes.index(axis)\n                pixel_size.append((scale1[index], units[index]))\n                position.append((position1[index], units[index]))\n            else:\n                pixel_size.append((1, ''))\n                position.append((0, ''))\n    nchannels = self.sizes_xyzct[0][3]\n    # look for channel metadata\n    for data in self.root_metadata.values():\n        if isinstance(data, dict) and 'channels' in data:\n            channels = data['channels'].copy()\n            for channel in channels:\n                color = channel.pop('color', '')\n                if color != '':\n                    if isinstance(color, int):\n                        color = int_to_rgba(color)\n                    else:\n                        color = hexrgb_to_rgba(color)\n                    channel['color'] = color\n    if len(channels) == 0:\n        if self.is_rgb:\n            channels = [{'label': ''}]\n        else:\n            channels = [{'label': ''}] * nchannels\n    self.source_pixel_size = pixel_size\n    self.channels = channels\n    self.source_mag = 0\n    self.position = position\n</code></pre>"},{"location":"references/#OmeSliCC.OmeZarrSource.OmeZarrSource.get_source_dask","title":"<code>get_source_dask()</code>","text":"Source code in <code>OmeSliCC\\OmeZarrSource.py</code> <pre><code>def get_source_dask(self):\n    return self.levels\n</code></pre>"},{"location":"references/#OmeSliCC.Omero","title":"<code>Omero</code>","text":""},{"location":"references/#OmeSliCC.Omero.Omero","title":"<code>Omero</code>","text":"<p>Omero image and metadata extraction</p> Source code in <code>OmeSliCC\\Omero.py</code> <pre><code>class Omero:\n    \"\"\"Omero image and metadata extraction\"\"\"\n\n    def __init__(self, params: dict):\n        self.params = params\n        self.private_key_filename = params['credentials']['private_key']\n        self.credentials_filename = params['credentials']['credentials']\n        self.connected = False\n\n    def __enter__(self) -&gt; Omero:\n        self.init()\n        return self\n\n    def __exit__(self, exc_type: type[BaseException], exc_value: BaseException, traceback: TracebackType):\n        self.close()\n\n    def init(self):\n        self._connect()\n        self._switch_user_group()\n\n    def close(self):\n        self._disconnect()\n\n    def _connect(self):\n        logging.info('Connecting to Omero...')\n        usr, pwd = decrypt_credentials(self.private_key_filename, self.credentials_filename)\n        self.conn = BlitzGateway(usr, pwd, host=self.params['input']['omero']['host'], secure=True)\n        if not self.conn.connect():\n            self._disconnect()\n            logging.error('Omero connection error')\n            raise ConnectionError\n        self.conn.c.enableKeepAlive(60)\n        self.connected = True\n        logging.info(f'Connected as {self.conn.getUser().getName()}')\n\n    def _disconnect(self):\n        self.conn.close()\n        self.connected = False\n\n    def _switch_user_group(self):\n        self.conn.SERVICE_OPTS.setOmeroGroup('-1')\n\n    def _get_project(self, project_id: int) -&gt; omero.gateway.ProjectWrapper:\n        project = self.conn.getObject('Project', project_id)\n        return project\n\n    def _get_dataset(self, dataset_id: int) -&gt; omero.gateway.DatasetWrapper:\n        dataset = self.conn.getObject('Dataset', dataset_id)\n        return dataset\n\n    def get_image_object(self, image_id: int) -&gt; omero.gateway.ImageWrapper:\n        image_object = self.conn.getObject('Image', image_id)\n        return image_object\n\n    def create_pixels_store(self, image_object: omero.gateway.ImageWrapper) -&gt; omero.gateway.ProxyObjectWrapper:\n        pixels_store = self.conn.createRawPixelsStore()\n        pixels_store.setPixelsId(image_object.getPixelsId(), False, self.conn.SERVICE_OPTS)\n        return pixels_store\n\n    def get_annotation_image_ids(self) -&gt; dict:\n        images_final = {}\n        input_omero = self.params['input'].get('omero', {})\n        include_params = input_omero['include']\n        include_regex = ensure_list(include_params.get('regex', []))\n        exclude_params = input_omero.get('exclude', {})\n        exclude_regex = ensure_list(exclude_params.get('regex', []))\n        # include\n        image_ids = set(ensure_list(include_params.get('image', [])))\n        images = {image_id: self.get_image_object(image_id) for image_id in image_ids}\n        for dataset_id in ensure_list(include_params.get('dataset', [])):\n            images.update(self._get_dataset_images(dataset_id))\n        for project_id in ensure_list(include_params.get('project', [])):\n            project = self._get_project(project_id)\n            for dataset in project.listChildren():\n                images.update(self._get_dataset_images(dataset.getId()))\n        # exclude\n        for image_id in ensure_list(exclude_params.get('image', [])):\n            images.pop(image_id, None)\n        for dataset_id in ensure_list(exclude_params.get('dataset', [])):\n            for image_id in self._get_dataset_images(dataset_id):\n                images.pop(image_id, None)\n        for project_id in ensure_list(exclude_params.get('project', [])):\n            project = self._get_project(project_id)\n            for dataset in project.listChildren():\n                for image_id in self._get_dataset_images(dataset.getId()):\n                    images.pop(image_id, None)\n\n        # regex\n        for image_id, image in images.items():\n            name = image.getName()\n            include = True\n            if include_regex:\n                include = False\n                for pattern in include_regex:\n                    if re.search(pattern, name, re.IGNORECASE):\n                        include = True\n            if exclude_regex:\n                for pattern in exclude_regex:\n                    if re.search(pattern, name, re.IGNORECASE):\n                        include = False\n            if include:\n                images_final[image_id] = image\n        return images_final\n\n    def _get_dataset_images(self, dataset_id: int) -&gt; dict:\n        dataset = self._get_dataset(dataset_id)\n        return {image.getId(): image for image in dataset.listChildren()}\n\n    def get_image_annotation(self, image_id: int, target_labels: list) -&gt; tuple:\n        image_object = self.get_image_object(image_id)\n        name = image_object.getName()\n        annotations = self._get_image_annotations(image_object, target_labels)\n        return name, annotations\n\n    def _get_image_annotations(self, image_object: omero.gateway.ImageWrapper, annotation_keys: list) -&gt; dict:\n        annotations = {}\n        for omero_annotation in image_object.listAnnotations():\n            if omero_annotation.OMERO_TYPE == omero.model.MapAnnotationI:\n                for annotation_key in annotation_keys:\n                    for annotation in omero_annotation.getMapValue():\n                        if annotation.name.lower() == annotation_key.lower():\n                            annotations[annotation_key] = annotation.value\n        return annotations\n\n    def print_projects(self):\n        projects = self.conn.listProjects()      # may include other users' data\n        for project in projects:\n            print_omero_object(project)\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.Omero.connected","title":"<code>connected = False</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.Omero.Omero.credentials_filename","title":"<code>credentials_filename = params['credentials']['credentials']</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.Omero.Omero.params","title":"<code>params = params</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.Omero.Omero.private_key_filename","title":"<code>private_key_filename = params['credentials']['private_key']</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.Omero.Omero.__enter__","title":"<code>__enter__()</code>","text":"Source code in <code>OmeSliCC\\Omero.py</code> <pre><code>def __enter__(self) -&gt; Omero:\n    self.init()\n    return self\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.Omero.__exit__","title":"<code>__exit__(exc_type, exc_value, traceback)</code>","text":"Source code in <code>OmeSliCC\\Omero.py</code> <pre><code>def __exit__(self, exc_type: type[BaseException], exc_value: BaseException, traceback: TracebackType):\n    self.close()\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.Omero.__init__","title":"<code>__init__(params)</code>","text":"Source code in <code>OmeSliCC\\Omero.py</code> <pre><code>def __init__(self, params: dict):\n    self.params = params\n    self.private_key_filename = params['credentials']['private_key']\n    self.credentials_filename = params['credentials']['credentials']\n    self.connected = False\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.Omero._connect","title":"<code>_connect()</code>","text":"Source code in <code>OmeSliCC\\Omero.py</code> <pre><code>def _connect(self):\n    logging.info('Connecting to Omero...')\n    usr, pwd = decrypt_credentials(self.private_key_filename, self.credentials_filename)\n    self.conn = BlitzGateway(usr, pwd, host=self.params['input']['omero']['host'], secure=True)\n    if not self.conn.connect():\n        self._disconnect()\n        logging.error('Omero connection error')\n        raise ConnectionError\n    self.conn.c.enableKeepAlive(60)\n    self.connected = True\n    logging.info(f'Connected as {self.conn.getUser().getName()}')\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.Omero._disconnect","title":"<code>_disconnect()</code>","text":"Source code in <code>OmeSliCC\\Omero.py</code> <pre><code>def _disconnect(self):\n    self.conn.close()\n    self.connected = False\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.Omero._get_dataset","title":"<code>_get_dataset(dataset_id)</code>","text":"Source code in <code>OmeSliCC\\Omero.py</code> <pre><code>def _get_dataset(self, dataset_id: int) -&gt; omero.gateway.DatasetWrapper:\n    dataset = self.conn.getObject('Dataset', dataset_id)\n    return dataset\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.Omero._get_dataset_images","title":"<code>_get_dataset_images(dataset_id)</code>","text":"Source code in <code>OmeSliCC\\Omero.py</code> <pre><code>def _get_dataset_images(self, dataset_id: int) -&gt; dict:\n    dataset = self._get_dataset(dataset_id)\n    return {image.getId(): image for image in dataset.listChildren()}\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.Omero._get_image_annotations","title":"<code>_get_image_annotations(image_object, annotation_keys)</code>","text":"Source code in <code>OmeSliCC\\Omero.py</code> <pre><code>def _get_image_annotations(self, image_object: omero.gateway.ImageWrapper, annotation_keys: list) -&gt; dict:\n    annotations = {}\n    for omero_annotation in image_object.listAnnotations():\n        if omero_annotation.OMERO_TYPE == omero.model.MapAnnotationI:\n            for annotation_key in annotation_keys:\n                for annotation in omero_annotation.getMapValue():\n                    if annotation.name.lower() == annotation_key.lower():\n                        annotations[annotation_key] = annotation.value\n    return annotations\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.Omero._get_project","title":"<code>_get_project(project_id)</code>","text":"Source code in <code>OmeSliCC\\Omero.py</code> <pre><code>def _get_project(self, project_id: int) -&gt; omero.gateway.ProjectWrapper:\n    project = self.conn.getObject('Project', project_id)\n    return project\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.Omero._switch_user_group","title":"<code>_switch_user_group()</code>","text":"Source code in <code>OmeSliCC\\Omero.py</code> <pre><code>def _switch_user_group(self):\n    self.conn.SERVICE_OPTS.setOmeroGroup('-1')\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.Omero.close","title":"<code>close()</code>","text":"Source code in <code>OmeSliCC\\Omero.py</code> <pre><code>def close(self):\n    self._disconnect()\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.Omero.create_pixels_store","title":"<code>create_pixels_store(image_object)</code>","text":"Source code in <code>OmeSliCC\\Omero.py</code> <pre><code>def create_pixels_store(self, image_object: omero.gateway.ImageWrapper) -&gt; omero.gateway.ProxyObjectWrapper:\n    pixels_store = self.conn.createRawPixelsStore()\n    pixels_store.setPixelsId(image_object.getPixelsId(), False, self.conn.SERVICE_OPTS)\n    return pixels_store\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.Omero.get_annotation_image_ids","title":"<code>get_annotation_image_ids()</code>","text":"Source code in <code>OmeSliCC\\Omero.py</code> <pre><code>def get_annotation_image_ids(self) -&gt; dict:\n    images_final = {}\n    input_omero = self.params['input'].get('omero', {})\n    include_params = input_omero['include']\n    include_regex = ensure_list(include_params.get('regex', []))\n    exclude_params = input_omero.get('exclude', {})\n    exclude_regex = ensure_list(exclude_params.get('regex', []))\n    # include\n    image_ids = set(ensure_list(include_params.get('image', [])))\n    images = {image_id: self.get_image_object(image_id) for image_id in image_ids}\n    for dataset_id in ensure_list(include_params.get('dataset', [])):\n        images.update(self._get_dataset_images(dataset_id))\n    for project_id in ensure_list(include_params.get('project', [])):\n        project = self._get_project(project_id)\n        for dataset in project.listChildren():\n            images.update(self._get_dataset_images(dataset.getId()))\n    # exclude\n    for image_id in ensure_list(exclude_params.get('image', [])):\n        images.pop(image_id, None)\n    for dataset_id in ensure_list(exclude_params.get('dataset', [])):\n        for image_id in self._get_dataset_images(dataset_id):\n            images.pop(image_id, None)\n    for project_id in ensure_list(exclude_params.get('project', [])):\n        project = self._get_project(project_id)\n        for dataset in project.listChildren():\n            for image_id in self._get_dataset_images(dataset.getId()):\n                images.pop(image_id, None)\n\n    # regex\n    for image_id, image in images.items():\n        name = image.getName()\n        include = True\n        if include_regex:\n            include = False\n            for pattern in include_regex:\n                if re.search(pattern, name, re.IGNORECASE):\n                    include = True\n        if exclude_regex:\n            for pattern in exclude_regex:\n                if re.search(pattern, name, re.IGNORECASE):\n                    include = False\n        if include:\n            images_final[image_id] = image\n    return images_final\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.Omero.get_image_annotation","title":"<code>get_image_annotation(image_id, target_labels)</code>","text":"Source code in <code>OmeSliCC\\Omero.py</code> <pre><code>def get_image_annotation(self, image_id: int, target_labels: list) -&gt; tuple:\n    image_object = self.get_image_object(image_id)\n    name = image_object.getName()\n    annotations = self._get_image_annotations(image_object, target_labels)\n    return name, annotations\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.Omero.get_image_object","title":"<code>get_image_object(image_id)</code>","text":"Source code in <code>OmeSliCC\\Omero.py</code> <pre><code>def get_image_object(self, image_id: int) -&gt; omero.gateway.ImageWrapper:\n    image_object = self.conn.getObject('Image', image_id)\n    return image_object\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.Omero.init","title":"<code>init()</code>","text":"Source code in <code>OmeSliCC\\Omero.py</code> <pre><code>def init(self):\n    self._connect()\n    self._switch_user_group()\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.Omero.print_projects","title":"<code>print_projects()</code>","text":"Source code in <code>OmeSliCC\\Omero.py</code> <pre><code>def print_projects(self):\n    projects = self.conn.listProjects()      # may include other users' data\n    for project in projects:\n        print_omero_object(project)\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.check_round_significants","title":"<code>check_round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def check_round_significants(a: float, significant_digits: int) -&gt; float:\n    rounded = round_significants(a, significant_digits)\n    if a != 0:\n        dif = 1 - rounded / a\n    else:\n        dif = rounded - a\n    if abs(dif) &lt; 10 ** -significant_digits:\n        return rounded\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.convert_rational_value","title":"<code>convert_rational_value(value)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def convert_rational_value(value) -&gt; float:\n    if value is not None and isinstance(value, tuple):\n        value = value[0] / value[1]\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.desc_to_dict","title":"<code>desc_to_dict(desc)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def desc_to_dict(desc: str) -&gt; dict:\n    desc_dict = {}\n    if desc.startswith('{'):\n        try:\n            metadata = ast.literal_eval(desc)\n            return metadata\n        except:\n            pass\n    for item in re.split(r'[\\r\\n\\t|]', desc):\n        item_sep = '='\n        if ':' in item:\n            item_sep = ':'\n        if item_sep in item:\n            items = item.split(item_sep)\n            key = items[0].strip()\n            value = items[1].strip()\n            for dtype in (int, float, bool):\n                try:\n                    value = dtype(value)\n                    break\n                except:\n                    pass\n            desc_dict[key] = value\n    return desc_dict\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.ensure_list","title":"<code>ensure_list(x)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def ensure_list(x) -&gt; list:\n    if x is None:\n        return []\n    elif isinstance(x, list):\n        return x\n    else:\n        return [x]\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.file_to_dict","title":"<code>file_to_dict(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def file_to_dict(filename: str) -&gt; dict:\n    ext = os.path.splitext(filename)[1]\n    content = open(filename, 'r').read()\n    if ext == '.xml':\n        data = xmltodict.parse(content)\n    elif ext in ['.yml', '.yaml']:\n        data = yaml.safe_load(content)\n    else:   # assume json\n        data = json.loads(content)\n    return data\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.filter_dict","title":"<code>filter_dict(dict0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def filter_dict(dict0: dict) -&gt; dict:\n    new_dict = {}\n    for key, value0 in dict0.items():\n        if value0 is not None:\n            values = []\n            for value in ensure_list(value0):\n                if isinstance(value, dict):\n                    value = filter_dict(value)\n                values.append(value)\n            if len(values) == 1:\n                values = values[0]\n            new_dict[key] = values\n    return new_dict\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.get_default","title":"<code>get_default(x, default)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_default(x, default):\n    return default if x is None else x\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.get_filetitle","title":"<code>get_filetitle(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_filetitle(filename: str) -&gt; str:\n    filebase = os.path.basename(filename)\n    title = os.path.splitext(filebase)[0].rstrip('.ome')\n    return title\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.get_value_units_micrometer","title":"<code>get_value_units_micrometer(value_units0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_value_units_micrometer(value_units0: list) -&gt; list:\n    conversions = {'nm': 1e-3, '\u00b5m': 1, 'um': 1, 'micrometer': 1, 'mm': 1e3, 'cm': 1e4, 'm': 1e6}\n    if value_units0 is None:\n        return None\n\n    values_um = []\n    for value_unit in value_units0:\n        if not (isinstance(value_unit, int) or isinstance(value_unit, float)):\n            value_um = value_unit[0] * conversions.get(value_unit[1], 1)\n        else:\n            value_um = value_unit\n        values_um.append(value_um)\n    return values_um\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.print_dict","title":"<code>print_dict(dct, indent=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_dict(dct: dict, indent: int = 0) -&gt; str:\n    s = ''\n    if isinstance(dct, dict):\n        for key, value in dct.items():\n            s += '\\n'\n            if not isinstance(value, list):\n                s += '\\t' * indent + str(key) + ': '\n            if isinstance(value, dict):\n                s += print_dict(value, indent=indent + 1)\n            elif isinstance(value, list):\n                for v in value:\n                    s += print_dict(v)\n            else:\n                s += str(value)\n    else:\n        s += str(dct)\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.print_hbytes","title":"<code>print_hbytes(nbytes)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_hbytes(nbytes: int) -&gt; str:\n    exps = ['', 'K', 'M', 'G', 'T']\n    div = 1024\n    exp = 0\n\n    while nbytes &gt; div:\n        nbytes /= div\n        exp += 1\n    return f'{nbytes:.1f}{exps[exp]}B'\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.print_omero_object","title":"<code>print_omero_object(omero_object, indent=0)</code>","text":"Source code in <code>OmeSliCC\\Omero.py</code> <pre><code>def print_omero_object(omero_object: omero.gateway.BlitzObjectWrapper, indent: int = 0):\n    logging.info(\"\"\"%s%s:%s  Name:\"%s\" (owner=%s)\"\"\" % (\n        \" \" * indent,\n        omero_object.OMERO_CLASS,\n        omero_object.getId(),\n        omero_object.getName(),\n        omero_object.getOwnerOmeName()))\n\n    for child in omero_object.listChildren():\n        logging.info('\\t', child.getName())\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.reorder","title":"<code>reorder(items, old_order, new_order, default_value=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def reorder(items: list, old_order: str, new_order: str, default_value: int = 0) -&gt; list:\n    new_items = []\n    for label in new_order:\n        if label in old_order:\n            item = items[old_order.index(label)]\n        else:\n            item = default_value\n        new_items.append(item)\n    return new_items\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.round_significants","title":"<code>round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def round_significants(a: float, significant_digits: int) -&gt; float:\n    if a != 0:\n        round_decimals = significant_digits - int(np.floor(np.log10(abs(a)))) - 1\n        return round(a, round_decimals)\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.split_num_text","title":"<code>split_num_text(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_num_text(text: str) -&gt; list:\n    num_texts = []\n    block = ''\n    is_num0 = None\n    if text is None:\n        return None\n\n    for c in text:\n        is_num = (c.isnumeric() or c == '.')\n        if is_num0 is not None and is_num != is_num0:\n            num_texts.append(block)\n            block = ''\n        block += c\n        is_num0 = is_num\n    if block != '':\n        num_texts.append(block)\n\n    num_texts2 = []\n    for block in num_texts:\n        block = block.strip()\n        try:\n            block = float(block)\n        except:\n            pass\n        if block not in [' ', ',', '|']:\n            num_texts2.append(block)\n    return num_texts2\n</code></pre>"},{"location":"references/#OmeSliCC.Omero.split_value_unit_list","title":"<code>split_value_unit_list(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_value_unit_list(text: str) -&gt; list:\n    value_units = []\n    if text is None:\n        return None\n\n    items = split_num_text(text)\n    if isinstance(items[-1], str):\n        def_unit = items[-1]\n    else:\n        def_unit = ''\n\n    i = 0\n    while i &lt; len(items):\n        value = items[i]\n        if i + 1 &lt; len(items):\n            unit = items[i + 1]\n        else:\n            unit = ''\n        if not isinstance(value, str):\n            if isinstance(unit, str):\n                i += 1\n            else:\n                unit = def_unit\n            value_units.append((value, unit))\n        i += 1\n    return value_units\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroLabelReader","title":"<code>OmeroLabelReader</code>","text":""},{"location":"references/#OmeSliCC.OmeroLabelReader.OmeroLabelReader","title":"<code>OmeroLabelReader</code>","text":"<p>Omero metadata extraction to label file</p> Source code in <code>OmeSliCC\\OmeroLabelReader.py</code> <pre><code>class OmeroLabelReader:\n    \"\"\"Omero metadata extraction to label file\"\"\"\n\n    params: dict\n    \"\"\"input parameters\"\"\"\n    omero: Omero\n    \"\"\"Omero instance\"\"\"\n    manage_omero: bool\n    \"\"\"If responsible for managing Omero instance\"\"\"\n\n    def __init__(self, params: dict, omero: Omero = None):\n        self.params = params\n        self.manage_omero = (omero is None)\n        if self.manage_omero:\n            self.omero = Omero(params)\n        else:\n            self.omero = omero\n\n    def __enter__(self) -&gt; OmeroLabelReader:\n        if self.manage_omero:\n            self.omero.init()\n        return self\n\n    def __exit__(self, exc_type: type[BaseException], exc_value: BaseException, traceback: TracebackType):\n        if self.manage_omero:\n            self.omero.close()\n\n    def create_label_csv(self, image_ids):\n        image_names = []\n        image_annotations = []\n        input_params = self.params['input']\n        output_params = self.params['output']\n        input_labels = input_params.get('omero', {}).get('labels', [])\n        logging.info(f'Matching images: {len(image_ids)}')\n        for image_id in image_ids:\n            name, annotations = self.omero.get_image_annotation(image_id, input_labels)\n            image_names.append(name)\n            image_annotations.append(annotations)\n        df = pd.DataFrame(index=image_ids, data=image_annotations)\n        df.index.name = 'omero_id'\n        for input_label in input_labels:\n            if input_label in df:\n                logging.info(f'Label {input_label}:\\n' + df[input_label].value_counts().to_string())\n        df.insert(0, 'omero_name', image_names)\n        df['path'] = [image_name + '.' + output_params['format'] for image_name in image_names]\n        log_path = os.path.dirname(output_params['csv'])\n        if not os.path.exists(log_path):\n            os.makedirs(log_path)\n        df.to_csv(output_params['csv'])\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroLabelReader.OmeroLabelReader.manage_omero","title":"<code>manage_omero = omero is None</code>  <code>instance-attribute</code>","text":"<p>If responsible for managing Omero instance</p>"},{"location":"references/#OmeSliCC.OmeroLabelReader.OmeroLabelReader.omero","title":"<code>omero</code>  <code>instance-attribute</code>","text":"<p>Omero instance</p>"},{"location":"references/#OmeSliCC.OmeroLabelReader.OmeroLabelReader.params","title":"<code>params = params</code>  <code>instance-attribute</code>","text":"<p>input parameters</p>"},{"location":"references/#OmeSliCC.OmeroLabelReader.OmeroLabelReader.__enter__","title":"<code>__enter__()</code>","text":"Source code in <code>OmeSliCC\\OmeroLabelReader.py</code> <pre><code>def __enter__(self) -&gt; OmeroLabelReader:\n    if self.manage_omero:\n        self.omero.init()\n    return self\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroLabelReader.OmeroLabelReader.__exit__","title":"<code>__exit__(exc_type, exc_value, traceback)</code>","text":"Source code in <code>OmeSliCC\\OmeroLabelReader.py</code> <pre><code>def __exit__(self, exc_type: type[BaseException], exc_value: BaseException, traceback: TracebackType):\n    if self.manage_omero:\n        self.omero.close()\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroLabelReader.OmeroLabelReader.__init__","title":"<code>__init__(params, omero=None)</code>","text":"Source code in <code>OmeSliCC\\OmeroLabelReader.py</code> <pre><code>def __init__(self, params: dict, omero: Omero = None):\n    self.params = params\n    self.manage_omero = (omero is None)\n    if self.manage_omero:\n        self.omero = Omero(params)\n    else:\n        self.omero = omero\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroLabelReader.OmeroLabelReader.create_label_csv","title":"<code>create_label_csv(image_ids)</code>","text":"Source code in <code>OmeSliCC\\OmeroLabelReader.py</code> <pre><code>def create_label_csv(self, image_ids):\n    image_names = []\n    image_annotations = []\n    input_params = self.params['input']\n    output_params = self.params['output']\n    input_labels = input_params.get('omero', {}).get('labels', [])\n    logging.info(f'Matching images: {len(image_ids)}')\n    for image_id in image_ids:\n        name, annotations = self.omero.get_image_annotation(image_id, input_labels)\n        image_names.append(name)\n        image_annotations.append(annotations)\n    df = pd.DataFrame(index=image_ids, data=image_annotations)\n    df.index.name = 'omero_id'\n    for input_label in input_labels:\n        if input_label in df:\n            logging.info(f'Label {input_label}:\\n' + df[input_label].value_counts().to_string())\n    df.insert(0, 'omero_name', image_names)\n    df['path'] = [image_name + '.' + output_params['format'] for image_name in image_names]\n    log_path = os.path.dirname(output_params['csv'])\n    if not os.path.exists(log_path):\n        os.makedirs(log_path)\n    df.to_csv(output_params['csv'])\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource","title":"<code>OmeroSource</code>","text":""},{"location":"references/#OmeSliCC.OmeroSource.OmeroSource","title":"<code>OmeroSource</code>","text":"<p>               Bases: <code>OmeSource</code></p> <p>Omero image source</p> Source code in <code>OmeSliCC\\OmeroSource.py</code> <pre><code>class OmeroSource(OmeSource):\n    \"\"\"Omero image source\"\"\"\n\n    omero: Omero\n    \"\"\"Omero instance\"\"\"\n    image_id: int\n    \"\"\"Omero image id\"\"\"\n    image_object: omero.gateway.ImageWrapper\n    \"\"\"Omero image object\"\"\"\n    pixels_store: omero.gateway.ProxyObjectWrapper\n    \"\"\"Raw pixels store object\"\"\"\n    pixels_store_pyramid_order: list\n    \"\"\"Raw pixels store pyramid sizes order (pixel store level order not guaranteed) \"\"\"\n\n    def __init__(self,\n                 omero: Omero,\n                 image_id: int,\n                 source_pixel_size: list = None,\n                 target_pixel_size: list = None,\n                 source_info_required: bool = False):\n\n        super().__init__()\n        self.omero = omero\n        self.image_id = image_id\n        image_object = self.omero.get_image_object(image_id)\n        self.image_object = image_object\n\n        zsize = get_default(image_object.getSizeZ(), 1)\n        nchannels = np.sum([channel.getLogicalChannel().getSamplesPerPixel() for channel in image_object.getChannels()])\n        pixel_type = np.dtype(image_object.getPixelsType())\n\n        self.pixels_store = self.omero.create_pixels_store(image_object)\n        for resolution in self.pixels_store.getResolutionDescriptions():\n            self.sizes.append((resolution.sizeX, resolution.sizeY))\n            self.sizes_xyzct.append((resolution.sizeX, resolution.sizeY, zsize, nchannels, 1))\n            self.pixel_types.append(pixel_type)\n            self.pixel_nbits.append(pixel_type.itemsize * 8)\n\n        if not self.sizes:\n            xsize, ysize = image_object.getSizeX(), image_object.getSizeY()\n            self.sizes.append((xsize, ysize))\n            self.sizes_xyzct.append((xsize, ysize, zsize, nchannels, 1))\n            self.pixel_types.append(pixel_type)\n            self.pixel_nbits.append(pixel_type.itemsize * 8)\n\n        # Omero API issue: pixel store level order not guaranteed\n        default_level = self.pixels_store.getResolutionLevel()\n        nlevels = self.pixels_store.getResolutionLevels()\n        if default_level != 0:\n            # reverse order\n            self.pixels_store_pyramid_order = list(reversed(range(nlevels)))\n        else:\n            # default order\n            self.pixels_store_pyramid_order = list(range(nlevels))\n\n        self.is_rgb = nchannels in (3, 4)\n\n        self._init_metadata(image_object.getName(),\n                            source_pixel_size=source_pixel_size,\n                            target_pixel_size=target_pixel_size,\n                            source_info_required=source_info_required)\n\n        # currently only support/output yxc\n        self.dimension_order = 'yxc'\n\n    def _find_metadata(self):\n        image_object = self.image_object\n        self.source_pixel_size = [(get_default(image_object.getPixelSizeX(), 0), self.default_physical_unit),\n                                  (get_default(image_object.getPixelSizeY(), 0), self.default_physical_unit),\n                                  (get_default(image_object.getPixelSizeZ(), 0), self.default_physical_unit)]\n        objective_settings = image_object.getObjectiveSettings()\n        if objective_settings:\n            self.source_mag = objective_settings.getObjective().getNominalMagnification()\n        else:\n            self.source_mag = 0\n        self.channels = []\n        for channeli, channel0 in enumerate(image_object.getChannels()):\n            channel = {'label': get_default(channel0.getName(), str(channeli)),\n                       'color': int_to_rgba(channel0.getColor().getInt())}\n            self.channels.append(channel)\n\n    def create_xml_metadata(self, output_filename: str, combine_rgb: bool = True, pyramid_sizes_add: list = None) -&gt; str:\n        return create_ome_metadata_from_omero(self, self.image_object, output_filename, combine_rgb=combine_rgb,\n                                              pyramid_sizes_add=pyramid_sizes_add)\n\n    def get_thumbnail(self, target_size: tuple, precise: bool = False) -&gt; np.ndarray:\n        image_bytes = self.image_object.getThumbnail(target_size)\n        image_stream = io.BytesIO(image_bytes)\n        image = np.array(PIL.Image.open(image_stream))\n        return image\n\n    def _asarray_level(self, level: int, **slicing) -&gt; np.ndarray:\n        x0, x1 = slicing.get('x0', 0), slicing.get('x1', -1)\n        y0, y1 = slicing.get('y0', 0), slicing.get('y1', -1)\n        c, t, z = slicing.get('c'), slicing.get('t'), slicing.get('z')\n        if x1 &lt; 0 or y1 &lt; 0:\n            x1, y1 = self.sizes[level]\n        if t is None:\n            t = 0\n        if z is None:\n            z = 0\n\n        w, h = x1 - x0, y1 - y0\n        if c is not None:\n            channels = [c]\n        else:\n            channels = range(self.get_nchannels())\n        shape = h, w, len(channels)\n        image = np.zeros(shape, dtype=self.pixel_types[level])\n        pixels_store = self.pixels_store\n        pixels_store_level = self.pixels_store_pyramid_order[level]\n        if pixels_store.getResolutionLevel() != pixels_store_level:\n            pixels_store.setResolutionLevel(pixels_store_level)\n        for c in channels:\n            tile0 = pixels_store.getTile(z, c, t, x0, y0, w, h)\n            tile = np.frombuffer(tile0, dtype=image.dtype).reshape(h, w)\n            image[..., c] = tile\n\n        out = redimension_data(image, self.dimension_order, self.get_dimension_order())\n        return out\n\n    def close(self):\n        self.pixels_store.close()\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.OmeroSource.dimension_order","title":"<code>dimension_order = 'yxc'</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.OmeroSource.OmeroSource.image_id","title":"<code>image_id = image_id</code>  <code>instance-attribute</code>","text":"<p>Omero image id</p>"},{"location":"references/#OmeSliCC.OmeroSource.OmeroSource.image_object","title":"<code>image_object = image_object</code>  <code>instance-attribute</code>","text":"<p>Omero image object</p>"},{"location":"references/#OmeSliCC.OmeroSource.OmeroSource.is_rgb","title":"<code>is_rgb = nchannels in (3, 4)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.OmeroSource.OmeroSource.omero","title":"<code>omero = omero</code>  <code>instance-attribute</code>","text":"<p>Omero instance</p>"},{"location":"references/#OmeSliCC.OmeroSource.OmeroSource.pixels_store","title":"<code>pixels_store = self.omero.create_pixels_store(image_object)</code>  <code>instance-attribute</code>","text":"<p>Raw pixels store object</p>"},{"location":"references/#OmeSliCC.OmeroSource.OmeroSource.pixels_store_pyramid_order","title":"<code>pixels_store_pyramid_order</code>  <code>instance-attribute</code>","text":"<p>Raw pixels store pyramid sizes order (pixel store level order not guaranteed)</p>"},{"location":"references/#OmeSliCC.OmeroSource.OmeroSource.__init__","title":"<code>__init__(omero, image_id, source_pixel_size=None, target_pixel_size=None, source_info_required=False)</code>","text":"Source code in <code>OmeSliCC\\OmeroSource.py</code> <pre><code>def __init__(self,\n             omero: Omero,\n             image_id: int,\n             source_pixel_size: list = None,\n             target_pixel_size: list = None,\n             source_info_required: bool = False):\n\n    super().__init__()\n    self.omero = omero\n    self.image_id = image_id\n    image_object = self.omero.get_image_object(image_id)\n    self.image_object = image_object\n\n    zsize = get_default(image_object.getSizeZ(), 1)\n    nchannels = np.sum([channel.getLogicalChannel().getSamplesPerPixel() for channel in image_object.getChannels()])\n    pixel_type = np.dtype(image_object.getPixelsType())\n\n    self.pixels_store = self.omero.create_pixels_store(image_object)\n    for resolution in self.pixels_store.getResolutionDescriptions():\n        self.sizes.append((resolution.sizeX, resolution.sizeY))\n        self.sizes_xyzct.append((resolution.sizeX, resolution.sizeY, zsize, nchannels, 1))\n        self.pixel_types.append(pixel_type)\n        self.pixel_nbits.append(pixel_type.itemsize * 8)\n\n    if not self.sizes:\n        xsize, ysize = image_object.getSizeX(), image_object.getSizeY()\n        self.sizes.append((xsize, ysize))\n        self.sizes_xyzct.append((xsize, ysize, zsize, nchannels, 1))\n        self.pixel_types.append(pixel_type)\n        self.pixel_nbits.append(pixel_type.itemsize * 8)\n\n    # Omero API issue: pixel store level order not guaranteed\n    default_level = self.pixels_store.getResolutionLevel()\n    nlevels = self.pixels_store.getResolutionLevels()\n    if default_level != 0:\n        # reverse order\n        self.pixels_store_pyramid_order = list(reversed(range(nlevels)))\n    else:\n        # default order\n        self.pixels_store_pyramid_order = list(range(nlevels))\n\n    self.is_rgb = nchannels in (3, 4)\n\n    self._init_metadata(image_object.getName(),\n                        source_pixel_size=source_pixel_size,\n                        target_pixel_size=target_pixel_size,\n                        source_info_required=source_info_required)\n\n    # currently only support/output yxc\n    self.dimension_order = 'yxc'\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.OmeroSource._asarray_level","title":"<code>_asarray_level(level, **slicing)</code>","text":"Source code in <code>OmeSliCC\\OmeroSource.py</code> <pre><code>def _asarray_level(self, level: int, **slicing) -&gt; np.ndarray:\n    x0, x1 = slicing.get('x0', 0), slicing.get('x1', -1)\n    y0, y1 = slicing.get('y0', 0), slicing.get('y1', -1)\n    c, t, z = slicing.get('c'), slicing.get('t'), slicing.get('z')\n    if x1 &lt; 0 or y1 &lt; 0:\n        x1, y1 = self.sizes[level]\n    if t is None:\n        t = 0\n    if z is None:\n        z = 0\n\n    w, h = x1 - x0, y1 - y0\n    if c is not None:\n        channels = [c]\n    else:\n        channels = range(self.get_nchannels())\n    shape = h, w, len(channels)\n    image = np.zeros(shape, dtype=self.pixel_types[level])\n    pixels_store = self.pixels_store\n    pixels_store_level = self.pixels_store_pyramid_order[level]\n    if pixels_store.getResolutionLevel() != pixels_store_level:\n        pixels_store.setResolutionLevel(pixels_store_level)\n    for c in channels:\n        tile0 = pixels_store.getTile(z, c, t, x0, y0, w, h)\n        tile = np.frombuffer(tile0, dtype=image.dtype).reshape(h, w)\n        image[..., c] = tile\n\n    out = redimension_data(image, self.dimension_order, self.get_dimension_order())\n    return out\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.OmeroSource._find_metadata","title":"<code>_find_metadata()</code>","text":"Source code in <code>OmeSliCC\\OmeroSource.py</code> <pre><code>def _find_metadata(self):\n    image_object = self.image_object\n    self.source_pixel_size = [(get_default(image_object.getPixelSizeX(), 0), self.default_physical_unit),\n                              (get_default(image_object.getPixelSizeY(), 0), self.default_physical_unit),\n                              (get_default(image_object.getPixelSizeZ(), 0), self.default_physical_unit)]\n    objective_settings = image_object.getObjectiveSettings()\n    if objective_settings:\n        self.source_mag = objective_settings.getObjective().getNominalMagnification()\n    else:\n        self.source_mag = 0\n    self.channels = []\n    for channeli, channel0 in enumerate(image_object.getChannels()):\n        channel = {'label': get_default(channel0.getName(), str(channeli)),\n                   'color': int_to_rgba(channel0.getColor().getInt())}\n        self.channels.append(channel)\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.OmeroSource.close","title":"<code>close()</code>","text":"Source code in <code>OmeSliCC\\OmeroSource.py</code> <pre><code>def close(self):\n    self.pixels_store.close()\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.OmeroSource.create_xml_metadata","title":"<code>create_xml_metadata(output_filename, combine_rgb=True, pyramid_sizes_add=None)</code>","text":"Source code in <code>OmeSliCC\\OmeroSource.py</code> <pre><code>def create_xml_metadata(self, output_filename: str, combine_rgb: bool = True, pyramid_sizes_add: list = None) -&gt; str:\n    return create_ome_metadata_from_omero(self, self.image_object, output_filename, combine_rgb=combine_rgb,\n                                          pyramid_sizes_add=pyramid_sizes_add)\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.OmeroSource.get_thumbnail","title":"<code>get_thumbnail(target_size, precise=False)</code>","text":"Source code in <code>OmeSliCC\\OmeroSource.py</code> <pre><code>def get_thumbnail(self, target_size: tuple, precise: bool = False) -&gt; np.ndarray:\n    image_bytes = self.image_object.getThumbnail(target_size)\n    image_stream = io.BytesIO(image_bytes)\n    image = np.array(PIL.Image.open(image_stream))\n    return image\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.check_round_significants","title":"<code>check_round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def check_round_significants(a: float, significant_digits: int) -&gt; float:\n    rounded = round_significants(a, significant_digits)\n    if a != 0:\n        dif = 1 - rounded / a\n    else:\n        dif = rounded - a\n    if abs(dif) &lt; 10 ** -significant_digits:\n        return rounded\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.convert_rational_value","title":"<code>convert_rational_value(value)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def convert_rational_value(value) -&gt; float:\n    if value is not None and isinstance(value, tuple):\n        value = value[0] / value[1]\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.desc_to_dict","title":"<code>desc_to_dict(desc)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def desc_to_dict(desc: str) -&gt; dict:\n    desc_dict = {}\n    if desc.startswith('{'):\n        try:\n            metadata = ast.literal_eval(desc)\n            return metadata\n        except:\n            pass\n    for item in re.split(r'[\\r\\n\\t|]', desc):\n        item_sep = '='\n        if ':' in item:\n            item_sep = ':'\n        if item_sep in item:\n            items = item.split(item_sep)\n            key = items[0].strip()\n            value = items[1].strip()\n            for dtype in (int, float, bool):\n                try:\n                    value = dtype(value)\n                    break\n                except:\n                    pass\n            desc_dict[key] = value\n    return desc_dict\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.ensure_list","title":"<code>ensure_list(x)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def ensure_list(x) -&gt; list:\n    if x is None:\n        return []\n    elif isinstance(x, list):\n        return x\n    else:\n        return [x]\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.file_to_dict","title":"<code>file_to_dict(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def file_to_dict(filename: str) -&gt; dict:\n    ext = os.path.splitext(filename)[1]\n    content = open(filename, 'r').read()\n    if ext == '.xml':\n        data = xmltodict.parse(content)\n    elif ext in ['.yml', '.yaml']:\n        data = yaml.safe_load(content)\n    else:   # assume json\n        data = json.loads(content)\n    return data\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.filter_dict","title":"<code>filter_dict(dict0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def filter_dict(dict0: dict) -&gt; dict:\n    new_dict = {}\n    for key, value0 in dict0.items():\n        if value0 is not None:\n            values = []\n            for value in ensure_list(value0):\n                if isinstance(value, dict):\n                    value = filter_dict(value)\n                values.append(value)\n            if len(values) == 1:\n                values = values[0]\n            new_dict[key] = values\n    return new_dict\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.get_default","title":"<code>get_default(x, default)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_default(x, default):\n    return default if x is None else x\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.get_filetitle","title":"<code>get_filetitle(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_filetitle(filename: str) -&gt; str:\n    filebase = os.path.basename(filename)\n    title = os.path.splitext(filebase)[0].rstrip('.ome')\n    return title\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.get_value_units_micrometer","title":"<code>get_value_units_micrometer(value_units0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_value_units_micrometer(value_units0: list) -&gt; list:\n    conversions = {'nm': 1e-3, '\u00b5m': 1, 'um': 1, 'micrometer': 1, 'mm': 1e3, 'cm': 1e4, 'm': 1e6}\n    if value_units0 is None:\n        return None\n\n    values_um = []\n    for value_unit in value_units0:\n        if not (isinstance(value_unit, int) or isinstance(value_unit, float)):\n            value_um = value_unit[0] * conversions.get(value_unit[1], 1)\n        else:\n            value_um = value_unit\n        values_um.append(value_um)\n    return values_um\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.hexrgb_to_rgba","title":"<code>hexrgb_to_rgba(hexrgb)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def hexrgb_to_rgba(hexrgb: str) -&gt; list:\n    rgba = int_to_rgba(eval('0x' + hexrgb + 'FF'))\n    return rgba\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.int_to_rgba","title":"<code>int_to_rgba(intrgba)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def int_to_rgba(intrgba: int) -&gt; list:\n    signed = (intrgba &lt; 0)\n    rgba = [x / 255 for x in intrgba.to_bytes(4, signed=signed, byteorder=\"big\")]\n    if rgba[-1] == 0:\n        rgba[-1] = 1\n    return rgba\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.print_dict","title":"<code>print_dict(dct, indent=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_dict(dct: dict, indent: int = 0) -&gt; str:\n    s = ''\n    if isinstance(dct, dict):\n        for key, value in dct.items():\n            s += '\\n'\n            if not isinstance(value, list):\n                s += '\\t' * indent + str(key) + ': '\n            if isinstance(value, dict):\n                s += print_dict(value, indent=indent + 1)\n            elif isinstance(value, list):\n                for v in value:\n                    s += print_dict(v)\n            else:\n                s += str(value)\n    else:\n        s += str(dct)\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.print_hbytes","title":"<code>print_hbytes(nbytes)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_hbytes(nbytes: int) -&gt; str:\n    exps = ['', 'K', 'M', 'G', 'T']\n    div = 1024\n    exp = 0\n\n    while nbytes &gt; div:\n        nbytes /= div\n        exp += 1\n    return f'{nbytes:.1f}{exps[exp]}B'\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.reorder","title":"<code>reorder(items, old_order, new_order, default_value=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def reorder(items: list, old_order: str, new_order: str, default_value: int = 0) -&gt; list:\n    new_items = []\n    for label in new_order:\n        if label in old_order:\n            item = items[old_order.index(label)]\n        else:\n            item = default_value\n        new_items.append(item)\n    return new_items\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.rgba_to_hexrgb","title":"<code>rgba_to_hexrgb(rgba)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def rgba_to_hexrgb(rgba: list) -&gt; str:\n    hexrgb = ''.join([hex(int(x * 255))[2:].upper().zfill(2) for x in rgba[:3]])\n    return hexrgb\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.rgba_to_int","title":"<code>rgba_to_int(rgba)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def rgba_to_int(rgba: list) -&gt; int:\n    intrgba = int.from_bytes([int(x * 255) for x in rgba], signed=True, byteorder=\"big\")\n    return intrgba\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.round_significants","title":"<code>round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def round_significants(a: float, significant_digits: int) -&gt; float:\n    if a != 0:\n        round_decimals = significant_digits - int(np.floor(np.log10(abs(a)))) - 1\n        return round(a, round_decimals)\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.split_num_text","title":"<code>split_num_text(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_num_text(text: str) -&gt; list:\n    num_texts = []\n    block = ''\n    is_num0 = None\n    if text is None:\n        return None\n\n    for c in text:\n        is_num = (c.isnumeric() or c == '.')\n        if is_num0 is not None and is_num != is_num0:\n            num_texts.append(block)\n            block = ''\n        block += c\n        is_num0 = is_num\n    if block != '':\n        num_texts.append(block)\n\n    num_texts2 = []\n    for block in num_texts:\n        block = block.strip()\n        try:\n            block = float(block)\n        except:\n            pass\n        if block not in [' ', ',', '|']:\n            num_texts2.append(block)\n    return num_texts2\n</code></pre>"},{"location":"references/#OmeSliCC.OmeroSource.split_value_unit_list","title":"<code>split_value_unit_list(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_value_unit_list(text: str) -&gt; list:\n    value_units = []\n    if text is None:\n        return None\n\n    items = split_num_text(text)\n    if isinstance(items[-1], str):\n        def_unit = items[-1]\n    else:\n        def_unit = ''\n\n    i = 0\n    while i &lt; len(items):\n        value = items[i]\n        if i + 1 &lt; len(items):\n            unit = items[i + 1]\n        else:\n            unit = ''\n        if not isinstance(value, str):\n            if isinstance(unit, str):\n                i += 1\n            else:\n                unit = def_unit\n            value_units.append((value, unit))\n        i += 1\n    return value_units\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource","title":"<code>PlainImageSource</code>","text":""},{"location":"references/#OmeSliCC.PlainImageSource.PlainImageSource","title":"<code>PlainImageSource</code>","text":"<p>               Bases: <code>OmeSource</code></p> <p>Plain common format image source</p> Source code in <code>OmeSliCC\\PlainImageSource.py</code> <pre><code>class PlainImageSource(OmeSource):\n    \"\"\"Plain common format image source\"\"\"\n\n    filename: str\n    \"\"\"original filename\"\"\"\n    loaded: bool\n    \"\"\"if image data is loaded\"\"\"\n    arrays: list\n    \"\"\"list of all image arrays for different sizes\"\"\"\n\n    def __init__(self,\n                 filename: str,\n                 source_pixel_size: list = None,\n                 target_pixel_size: list = None,\n                 source_info_required: bool = False):\n\n        super().__init__()\n        self.loaded = False\n        self.arrays = []\n\n        self.image = Image.open(filename)\n        self.metadata = get_pil_metadata(self.image)\n        size = (self.image.width, self.image.height)\n        self.sizes = [size]\n        nchannels = len(self.image.getbands())\n        size_xyzct = (self.image.width, self.image.height, self.image.n_frames, nchannels, 1)\n        self.sizes_xyzct = [size_xyzct]\n        pixelinfo = pilmode_to_pixelinfo(self.image.mode)\n        self.pixel_types = [pixelinfo[0]]\n        self.pixel_nbits = [pixelinfo[1]]\n\n        dimension_order = 'yx'\n        if self.image.n_frames &gt; 1:\n            dimension_order = 'z' + dimension_order\n        if nchannels &gt; 1:\n            dimension_order += 'c'\n        self.dimension_order = dimension_order\n\n        self.is_rgb = nchannels in (3, 4)\n\n        self._init_metadata(filename,\n                            source_pixel_size=source_pixel_size,\n                            target_pixel_size=target_pixel_size,\n                            source_info_required=source_info_required)\n\n    def _find_metadata(self):\n        self.source_pixel_size = []\n        pixel_size_unit = None\n        pixel_size_z = None\n\n        description = self.metadata.get('ImageDescription', '')\n        if description != '':\n            metadata = desc_to_dict(description)\n            if 'spacing' in metadata:\n                pixel_size_unit = metadata.get('unit', '')\n                if not isinstance(pixel_size_unit, str):\n                    pixel_size_unit = 'micrometer'\n                pixel_size_z = metadata['spacing']\n        if not pixel_size_unit:\n            pixel_size_unit = self.metadata.get('ResolutionUnit')\n            if pixel_size_unit is not None:\n                pixel_size_unit = str(RESUNIT(pixel_size_unit).name).lower()\n                if pixel_size_unit == 'none':\n                    pixel_size_unit = ''\n        res0 = self.metadata.get('XResolution')\n        if res0 is not None:\n            self.source_pixel_size.append((1 / float(res0), pixel_size_unit))\n        res0 = self.metadata.get('YResolution')\n        if res0 is not None:\n            self.source_pixel_size.append((1 / float(res0), pixel_size_unit))\n        if pixel_size_z is not None:\n            self.source_pixel_size.append((pixel_size_z, pixel_size_unit))\n        self.source_mag = self.metadata.get('Mag', 0)\n        self.channels = [{'label': ''}]\n\n    def load(self):\n        self.unload()\n        for level in range(len(self.sizes)):\n            self.arrays.append(self._asarray_level(level))\n        self.loaded = True\n\n    def unload(self):\n        for array in self.arrays:\n            del array\n        self.arrays = []\n        self.loaded = False\n\n    def _asarray_level(self, level: int, **slicing) -&gt; np.ndarray:\n        nframes = self.image.n_frames\n        if self.loaded:\n            image = self.arrays[level]\n        elif nframes &gt; 1:\n            shape = [nframes] + list(np.array(self.image).shape)\n            image = np.zeros(shape, dtype=self.pixel_types[level])\n            for framei in range(nframes):\n                self.image.seek(framei)\n                image[framei] = np.array(self.image)\n        else:\n            image = np.array(self.image)\n\n        redim = redimension_data(image, self.dimension_order, self.get_dimension_order())\n        slicing = get_numpy_slicing(self.get_dimension_order(), **slicing)\n        out = redim[slicing]\n        return out\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.PlainImageSource.arrays","title":"<code>arrays = []</code>  <code>instance-attribute</code>","text":"<p>list of all image arrays for different sizes</p>"},{"location":"references/#OmeSliCC.PlainImageSource.PlainImageSource.dimension_order","title":"<code>dimension_order = dimension_order</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.PlainImageSource.PlainImageSource.filename","title":"<code>filename</code>  <code>instance-attribute</code>","text":"<p>original filename</p>"},{"location":"references/#OmeSliCC.PlainImageSource.PlainImageSource.image","title":"<code>image = Image.open(filename)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.PlainImageSource.PlainImageSource.is_rgb","title":"<code>is_rgb = nchannels in (3, 4)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.PlainImageSource.PlainImageSource.loaded","title":"<code>loaded = False</code>  <code>instance-attribute</code>","text":"<p>if image data is loaded</p>"},{"location":"references/#OmeSliCC.PlainImageSource.PlainImageSource.metadata","title":"<code>metadata = get_pil_metadata(self.image)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.PlainImageSource.PlainImageSource.pixel_nbits","title":"<code>pixel_nbits = [pixelinfo[1]]</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.PlainImageSource.PlainImageSource.pixel_types","title":"<code>pixel_types = [pixelinfo[0]]</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.PlainImageSource.PlainImageSource.sizes","title":"<code>sizes = [size]</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.PlainImageSource.PlainImageSource.sizes_xyzct","title":"<code>sizes_xyzct = [size_xyzct]</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.PlainImageSource.PlainImageSource.__init__","title":"<code>__init__(filename, source_pixel_size=None, target_pixel_size=None, source_info_required=False)</code>","text":"Source code in <code>OmeSliCC\\PlainImageSource.py</code> <pre><code>def __init__(self,\n             filename: str,\n             source_pixel_size: list = None,\n             target_pixel_size: list = None,\n             source_info_required: bool = False):\n\n    super().__init__()\n    self.loaded = False\n    self.arrays = []\n\n    self.image = Image.open(filename)\n    self.metadata = get_pil_metadata(self.image)\n    size = (self.image.width, self.image.height)\n    self.sizes = [size]\n    nchannels = len(self.image.getbands())\n    size_xyzct = (self.image.width, self.image.height, self.image.n_frames, nchannels, 1)\n    self.sizes_xyzct = [size_xyzct]\n    pixelinfo = pilmode_to_pixelinfo(self.image.mode)\n    self.pixel_types = [pixelinfo[0]]\n    self.pixel_nbits = [pixelinfo[1]]\n\n    dimension_order = 'yx'\n    if self.image.n_frames &gt; 1:\n        dimension_order = 'z' + dimension_order\n    if nchannels &gt; 1:\n        dimension_order += 'c'\n    self.dimension_order = dimension_order\n\n    self.is_rgb = nchannels in (3, 4)\n\n    self._init_metadata(filename,\n                        source_pixel_size=source_pixel_size,\n                        target_pixel_size=target_pixel_size,\n                        source_info_required=source_info_required)\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.PlainImageSource._asarray_level","title":"<code>_asarray_level(level, **slicing)</code>","text":"Source code in <code>OmeSliCC\\PlainImageSource.py</code> <pre><code>def _asarray_level(self, level: int, **slicing) -&gt; np.ndarray:\n    nframes = self.image.n_frames\n    if self.loaded:\n        image = self.arrays[level]\n    elif nframes &gt; 1:\n        shape = [nframes] + list(np.array(self.image).shape)\n        image = np.zeros(shape, dtype=self.pixel_types[level])\n        for framei in range(nframes):\n            self.image.seek(framei)\n            image[framei] = np.array(self.image)\n    else:\n        image = np.array(self.image)\n\n    redim = redimension_data(image, self.dimension_order, self.get_dimension_order())\n    slicing = get_numpy_slicing(self.get_dimension_order(), **slicing)\n    out = redim[slicing]\n    return out\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.PlainImageSource._find_metadata","title":"<code>_find_metadata()</code>","text":"Source code in <code>OmeSliCC\\PlainImageSource.py</code> <pre><code>def _find_metadata(self):\n    self.source_pixel_size = []\n    pixel_size_unit = None\n    pixel_size_z = None\n\n    description = self.metadata.get('ImageDescription', '')\n    if description != '':\n        metadata = desc_to_dict(description)\n        if 'spacing' in metadata:\n            pixel_size_unit = metadata.get('unit', '')\n            if not isinstance(pixel_size_unit, str):\n                pixel_size_unit = 'micrometer'\n            pixel_size_z = metadata['spacing']\n    if not pixel_size_unit:\n        pixel_size_unit = self.metadata.get('ResolutionUnit')\n        if pixel_size_unit is not None:\n            pixel_size_unit = str(RESUNIT(pixel_size_unit).name).lower()\n            if pixel_size_unit == 'none':\n                pixel_size_unit = ''\n    res0 = self.metadata.get('XResolution')\n    if res0 is not None:\n        self.source_pixel_size.append((1 / float(res0), pixel_size_unit))\n    res0 = self.metadata.get('YResolution')\n    if res0 is not None:\n        self.source_pixel_size.append((1 / float(res0), pixel_size_unit))\n    if pixel_size_z is not None:\n        self.source_pixel_size.append((pixel_size_z, pixel_size_unit))\n    self.source_mag = self.metadata.get('Mag', 0)\n    self.channels = [{'label': ''}]\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.PlainImageSource.load","title":"<code>load()</code>","text":"Source code in <code>OmeSliCC\\PlainImageSource.py</code> <pre><code>def load(self):\n    self.unload()\n    for level in range(len(self.sizes)):\n        self.arrays.append(self._asarray_level(level))\n    self.loaded = True\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.PlainImageSource.unload","title":"<code>unload()</code>","text":"Source code in <code>OmeSliCC\\PlainImageSource.py</code> <pre><code>def unload(self):\n    for array in self.arrays:\n        del array\n    self.arrays = []\n    self.loaded = False\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.blur_image","title":"<code>blur_image(image, sigma)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def blur_image(image, sigma):\n    nchannels = image.shape[2] if image.ndim == 3 else 1\n    if nchannels not in [1, 3]:\n        new_image = np.zeros_like(image)\n        for channeli in range(nchannels):\n            new_image[..., channeli] = blur_image_single(image[..., channeli], sigma)\n    else:\n        new_image = blur_image_single(image, sigma)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.blur_image_single","title":"<code>blur_image_single(image, sigma)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def blur_image_single(image, sigma):\n    return gaussian_filter(image, sigma)\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.calc_fraction_used","title":"<code>calc_fraction_used(image, threshold=0.1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_fraction_used(image: np.ndarray, threshold: float = 0.1) -&gt; float:\n    low = int(round(threshold * 255))\n    high = int(round((1 - threshold) * 255))\n    shape = image.shape\n    total = shape[0] * shape[1]\n    good = 0\n    for y in range(shape[0]):\n        for x in range(shape[1]):\n            pixel = image[y, x]\n            if low &lt;= pixel[0] &lt; high and low &lt;= pixel[1] &lt; high and low &lt;= pixel[2] &lt; high:\n                good += 1\n    fraction = good / total\n    return fraction\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.calc_pyramid","title":"<code>calc_pyramid(xyzct, npyramid_add=0, pyramid_downsample=2, volumetric_resize=False)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_pyramid(xyzct: tuple, npyramid_add: int = 0, pyramid_downsample: float = 2,\n                 volumetric_resize: bool = False) -&gt; list:\n    x, y, z, c, t = xyzct\n    if volumetric_resize and z &gt; 1:\n        size = (x, y, z)\n    else:\n        size = (x, y)\n    sizes_add = []\n    scale = 1\n    for _ in range(npyramid_add):\n        scale /= pyramid_downsample\n        scaled_size = np.maximum(np.round(np.multiply(size, scale)).astype(int), 1)\n        sizes_add.append(scaled_size)\n    return sizes_add\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.calc_tiles_median","title":"<code>calc_tiles_median(images)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_tiles_median(images):\n    out_image = np.zeros_like(images[0])\n    median_image = np.median(images, 0, out_image)\n    return median_image\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.calc_tiles_quantiles","title":"<code>calc_tiles_quantiles(images, quantiles)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_tiles_quantiles(images, quantiles):\n    out_quantiles = []\n    quantile_images = np.quantile(images, quantiles, 0)\n    for quantile_image in quantile_images:\n        maxval = 2 ** (8 * images[0].dtype.itemsize) - 1\n        image = (quantile_image / maxval).astype(np.float32)\n        out_quantiles.append(image)\n    return out_quantiles\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.check_round_significants","title":"<code>check_round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def check_round_significants(a: float, significant_digits: int) -&gt; float:\n    rounded = round_significants(a, significant_digits)\n    if a != 0:\n        dif = 1 - rounded / a\n    else:\n        dif = rounded - a\n    if abs(dif) &lt; 10 ** -significant_digits:\n        return rounded\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.check_versions","title":"<code>check_versions()</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def check_versions():\n    print(f'tifffile {tifffile.__version__}')\n    print(imagecodecs.version())\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.compare_image","title":"<code>compare_image(image0, image1, show=False)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image(image0, image1, show=False) -&gt; float:\n    dif, dif_max, dif_mean, psnr = compare_image_dist(image0, image1)\n    print(f'rgb dist max: {dif_max:.1f} mean: {dif_mean:.1f} PSNR: {psnr:.1f}')\n    if show:\n        show_image(dif)\n        show_image((dif * 10).astype(np.uint8))\n    return dif\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.compare_image_dist","title":"<code>compare_image_dist(image0, image1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image_dist(image0: np.ndarray, image1: np.ndarray) -&gt; tuple:\n    dif = cv.absdiff(image0, image1)\n    psnr = cv.PSNR(image0, image1)\n    if dif.size &gt; 1000000000:\n        # split very large array\n        rgb_maxs = []\n        rgb_means = []\n        for dif1 in np.array_split(dif, 16):\n            rgb_dif = np.linalg.norm(dif1, axis=2)\n            rgb_maxs.append(np.max(rgb_dif))\n            rgb_means.append(np.mean(rgb_dif))\n        rgb_max = np.max(rgb_maxs)\n        rgb_mean = np.mean(rgb_means)\n    else:\n        rgb_dif = np.linalg.norm(dif, axis=2)\n        rgb_max = np.max(rgb_dif)\n        rgb_mean = np.mean(rgb_dif)\n    return dif, rgb_max, rgb_mean, psnr\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.compare_image_dist_simple","title":"<code>compare_image_dist_simple(image0, image1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image_dist_simple(image0: np.ndarray, image1: np.ndarray) -&gt; dict:\n    dif = cv.absdiff(image0, image1)\n    psnr = cv.PSNR(image0, image1)\n    rgb_dif = np.linalg.norm(dif, axis=2)\n    dif_max = np.max(rgb_dif)\n    dif_mean = np.mean(rgb_dif)\n    return {'dif_max': dif_max, 'dif_mean': dif_mean, 'psnr': psnr}\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.convert_image_sign_type","title":"<code>convert_image_sign_type(image, target_dtype)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def convert_image_sign_type(image: np.ndarray, target_dtype: np.dtype) -&gt; np.ndarray:\n    source_dtype = image.dtype\n    if source_dtype.kind == target_dtype.kind:\n        new_image = image\n    elif source_dtype.kind == 'i':\n        new_image = ensure_unsigned_image(image)\n    else:\n        # conversion without overhead\n        offset = 2 ** (8 * target_dtype.itemsize - 1)\n        new_image = (image - offset).astype(target_dtype)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.convert_rational_value","title":"<code>convert_rational_value(value)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def convert_rational_value(value) -&gt; float:\n    if value is not None and isinstance(value, tuple):\n        value = value[0] / value[1]\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.create_compression_codecs","title":"<code>create_compression_codecs(compression)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def create_compression_codecs(compression: list) -&gt; list:\n    codecs = None\n    compression = ensure_list(compression)\n    if compression is not None and len(compression) &gt; 0:\n        compression_type = compression[0].lower()\n        if len(compression) &gt; 1:\n            level = int(compression[1])\n        else:\n            level = None\n        if 'lzw' in compression_type:\n            from imagecodecs.numcodecs import Lzw\n            codecs = [Lzw()]\n        elif '2k' in compression_type or '2000' in compression_type:\n            from imagecodecs.numcodecs import Jpeg2k\n            codecs = [Jpeg2k(level=level)]\n        elif 'jpegls' in compression_type:\n            from imagecodecs.numcodecs import Jpegls\n            codecs = [Jpegls(level=level)]\n        elif 'jpegxr' in compression_type:\n            from imagecodecs.numcodecs import Jpegxr\n            codecs = [Jpegxr(level=level)]\n        elif 'jpegxl' in compression_type:\n            from imagecodecs.numcodecs import Jpegxl\n            codecs = [Jpegxl(level=level)]\n        else:\n            codecs = [compression]\n    return codecs\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.create_compression_filter","title":"<code>create_compression_filter(compression)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def create_compression_filter(compression: list) -&gt; tuple:\n    compressor, compression_filters = None, None\n    compression = ensure_list(compression)\n    if compression is not None and len(compression) &gt; 0:\n        compression_type = compression[0].lower()\n        if len(compression) &gt; 1:\n            level = int(compression[1])\n        else:\n            level = None\n        if 'lzw' in compression_type:\n            from imagecodecs.numcodecs import Lzw\n            compression_filters = [Lzw()]\n        elif '2k' in compression_type or '2000' in compression_type:\n            from imagecodecs.numcodecs import Jpeg2k\n            compression_filters = [Jpeg2k(level=level)]\n        elif 'jpegls' in compression_type:\n            from imagecodecs.numcodecs import Jpegls\n            compression_filters = [Jpegls(level=level)]\n        elif 'jpegxr' in compression_type:\n            from imagecodecs.numcodecs import Jpegxr\n            compression_filters = [Jpegxr(level=level)]\n        elif 'jpegxl' in compression_type:\n            from imagecodecs.numcodecs import Jpegxl\n            compression_filters = [Jpegxl(level=level)]\n        else:\n            compressor = compression\n    return compressor, compression_filters\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.desc_to_dict","title":"<code>desc_to_dict(desc)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def desc_to_dict(desc: str) -&gt; dict:\n    desc_dict = {}\n    if desc.startswith('{'):\n        try:\n            metadata = ast.literal_eval(desc)\n            return metadata\n        except:\n            pass\n    for item in re.split(r'[\\r\\n\\t|]', desc):\n        item_sep = '='\n        if ':' in item:\n            item_sep = ':'\n        if item_sep in item:\n            items = item.split(item_sep)\n            key = items[0].strip()\n            value = items[1].strip()\n            for dtype in (int, float, bool):\n                try:\n                    value = dtype(value)\n                    break\n                except:\n                    pass\n            desc_dict[key] = value\n    return desc_dict\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.ensure_list","title":"<code>ensure_list(x)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def ensure_list(x) -&gt; list:\n    if x is None:\n        return []\n    elif isinstance(x, list):\n        return x\n    else:\n        return [x]\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.ensure_unsigned_image","title":"<code>ensure_unsigned_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def ensure_unsigned_image(image: np.ndarray) -&gt; np.ndarray:\n    source_dtype = image.dtype\n    dtype = ensure_unsigned_type(source_dtype)\n    if dtype != source_dtype:\n        # conversion without overhead\n        offset = 2 ** (8 * dtype.itemsize - 1)\n        new_image = image.astype(dtype) + offset\n    else:\n        new_image = image\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.ensure_unsigned_type","title":"<code>ensure_unsigned_type(dtype)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def ensure_unsigned_type(dtype: np.dtype) -&gt; np.dtype:\n    new_dtype = dtype\n    if dtype.kind == 'i' or dtype.byteorder == '&gt;' or dtype.byteorder == '&lt;':\n        new_dtype = np.dtype(f'u{dtype.itemsize}')\n    return new_dtype\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.file_to_dict","title":"<code>file_to_dict(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def file_to_dict(filename: str) -&gt; dict:\n    ext = os.path.splitext(filename)[1]\n    content = open(filename, 'r').read()\n    if ext == '.xml':\n        data = xmltodict.parse(content)\n    elif ext in ['.yml', '.yaml']:\n        data = yaml.safe_load(content)\n    else:   # assume json\n        data = json.loads(content)\n    return data\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.filter_dict","title":"<code>filter_dict(dict0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def filter_dict(dict0: dict) -&gt; dict:\n    new_dict = {}\n    for key, value0 in dict0.items():\n        if value0 is not None:\n            values = []\n            for value in ensure_list(value0):\n                if isinstance(value, dict):\n                    value = filter_dict(value)\n                values.append(value)\n            if len(values) == 1:\n                values = values[0]\n            new_dict[key] = values\n    return new_dict\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.float2int_image","title":"<code>float2int_image(image, target_dtype=np.dtype(np.uint8))</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def float2int_image(image, target_dtype=np.dtype(np.uint8)):\n    source_dtype = image.dtype\n    if source_dtype.kind not in ('i', 'u') and not target_dtype.kind == 'f':\n        maxval = 2 ** (8 * target_dtype.itemsize) - 1\n        return (image * maxval).astype(target_dtype)\n    else:\n        return image\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.get_default","title":"<code>get_default(x, default)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_default(x, default):\n    return default if x is None else x\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.get_filetitle","title":"<code>get_filetitle(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_filetitle(filename: str) -&gt; str:\n    filebase = os.path.basename(filename)\n    title = os.path.splitext(filebase)[0].rstrip('.ome')\n    return title\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.get_image_quantile","title":"<code>get_image_quantile(image, quantile, axis=None)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_image_quantile(image: np.ndarray, quantile: float, axis=None) -&gt; float:\n    value = np.quantile(image, quantile, axis=axis).astype(image.dtype)\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.get_image_size_info","title":"<code>get_image_size_info(sizes_xyzct, pixel_nbytes, pixel_type, channels)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_image_size_info(sizes_xyzct: list, pixel_nbytes: int, pixel_type: np.dtype, channels: list) -&gt; str:\n    image_size_info = 'XYZCT:'\n    size = 0\n    for i, size_xyzct in enumerate(sizes_xyzct):\n        w, h, zs, cs, ts = size_xyzct\n        size += np.int64(pixel_nbytes) * w * h * zs * cs * ts\n        if i &gt; 0:\n            image_size_info += ','\n        image_size_info += f' {w} {h} {zs} {cs} {ts}'\n    image_size_info += f' Pixel type: {pixel_type} Uncompressed: {print_hbytes(size)}'\n    if sizes_xyzct[0][3] == 3:\n        channel_info = 'rgb'\n    else:\n        channel_info = ','.join([channel.get('Name', '') for channel in channels])\n    if channel_info != '':\n        image_size_info += f' Channels: {channel_info}'\n    return image_size_info\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.get_numpy_slicing","title":"<code>get_numpy_slicing(dimension_order, **slicing)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_numpy_slicing(dimension_order, **slicing):\n    slices = []\n    for axis in dimension_order:\n        index = slicing.get(axis)\n        index0 = slicing.get(axis + '0')\n        index1 = slicing.get(axis + '1')\n        if index0 is not None and index1 is not None:\n            slice1 = slice(int(index0), int(index1))\n        elif index is not None:\n            slice1 = int(index)\n        else:\n            slice1 = slice(None)\n        slices.append(slice1)\n    return tuple(slices)\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.get_pil_metadata","title":"<code>get_pil_metadata(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_pil_metadata(image: PIL.Image) -&gt; dict:\n    metadata = {}\n    exifdata = image.getexif()\n    for tag_id in exifdata:\n        tag = TAGS.get(tag_id, tag_id)\n        data = exifdata.get(tag_id)\n        if isinstance(data, bytes):\n            data = data.decode()\n        metadata[tag] = data\n    if metadata == {}:\n        metadata = image.info\n    return metadata\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.get_tiff_pages","title":"<code>get_tiff_pages(tiff)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_tiff_pages(tiff: TiffFile) -&gt; list:\n    # TODO: review so this works for multi-level ome-tiff, tiff-stack, and z pages tiff, then later check for mmstack\n    pages = []\n    found = False\n    if tiff.series and not tiff.is_mmstack:\n        # has series\n        baseline = tiff.series[0]\n        for level in baseline.levels:\n            # has levels\n            level_pages = []\n            for page in level.pages:\n                found = True\n                level_pages.append(page)\n            if level_pages:\n                pages.append(level_pages)\n\n    if not found:\n        for page in tiff.pages:\n            pages.append(page)\n    return pages\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.get_value_units_micrometer","title":"<code>get_value_units_micrometer(value_units0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_value_units_micrometer(value_units0: list) -&gt; list:\n    conversions = {'nm': 1e-3, '\u00b5m': 1, 'um': 1, 'micrometer': 1, 'mm': 1e3, 'cm': 1e4, 'm': 1e6}\n    if value_units0 is None:\n        return None\n\n    values_um = []\n    for value_unit in value_units0:\n        if not (isinstance(value_unit, int) or isinstance(value_unit, float)):\n            value_um = value_unit[0] * conversions.get(value_unit[1], 1)\n        else:\n            value_um = value_unit\n        values_um.append(value_um)\n    return values_um\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.image_reshape","title":"<code>image_reshape(image, target_size)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def image_reshape(image: np.ndarray, target_size: tuple) -&gt; np.ndarray:\n    tw, th = target_size\n    sh, sw = image.shape[0:2]\n    if sw &lt; tw or sh &lt; th:\n        dw = max(tw - sw, 0)\n        dh = max(th - sh, 0)\n        padding = [(0, dh), (0, dw)]\n        if len(image.shape) == 3:\n            padding += [(0, 0)]\n        image = np.pad(image, padding, 'edge')\n    if tw &lt; sw or th &lt; sh:\n        image = image[0:th, 0:tw]\n    return image\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.image_resize","title":"<code>image_resize(image, target_size0, dimension_order='yxc')</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def image_resize(image: np.ndarray, target_size0: tuple, dimension_order: str = 'yxc') -&gt; np.ndarray:\n    shape = image.shape\n    x_index = dimension_order.index('x')\n    y_index = dimension_order.index('y')\n    c_is_at_end = ('c' in dimension_order and dimension_order.endswith('c'))\n    size = shape[x_index], shape[y_index]\n    if np.mean(np.divide(size, target_size0)) &lt; 1:\n        interpolation = cv.INTER_CUBIC\n    else:\n        interpolation = cv.INTER_AREA\n    dtype0 = image.dtype\n    image = ensure_unsigned_image(image)\n    target_size = tuple(np.maximum(np.round(target_size0).astype(int), 1))\n    if dimension_order in ['yxc', 'yx']:\n        new_image = cv.resize(np.asarray(image), target_size, interpolation=interpolation)\n    elif dimension_order == 'cyx':\n        new_image = np.moveaxis(image, 0, -1)\n        new_image = cv.resize(np.asarray(new_image), target_size, interpolation=interpolation)\n        new_image = np.moveaxis(new_image, -1, 0)\n    else:\n        ts = image.shape[dimension_order.index('t')] if 't' in dimension_order else 1\n        zs = image.shape[dimension_order.index('z')] if 'z' in dimension_order else 1\n        target_shape = list(image.shape).copy()\n        target_shape[x_index] = target_size[0]\n        target_shape[y_index] = target_size[1]\n        new_image = np.zeros(target_shape, dtype=image.dtype)\n        for t in range(ts):\n            for z in range(zs):\n                slices = get_numpy_slicing(dimension_order, z=z, t=t)\n                image1 = image[slices]\n                if not c_is_at_end:\n                    image1 = np.moveaxis(image1, 0, -1)\n                new_image1 = np.atleast_3d(cv.resize(np.asarray(image1), target_size, interpolation=interpolation))\n                if not c_is_at_end:\n                    new_image1 = np.moveaxis(new_image1, -1, 0)\n                new_image[slices] = new_image1\n    new_image = convert_image_sign_type(new_image, dtype0)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.int2float_image","title":"<code>int2float_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def int2float_image(image):\n    source_dtype = image.dtype\n    if not source_dtype.kind == 'f':\n        maxval = 2 ** (8 * source_dtype.itemsize) - 1\n        return image / np.float32(maxval)\n    else:\n        return image\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.normalise_values","title":"<code>normalise_values(image, min_value, max_value)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def normalise_values(image: np.ndarray, min_value: float, max_value: float) -&gt; np.ndarray:\n    return np.clip((image.astype(np.float32) - min_value) / (max_value - min_value), 0, 1)\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.pilmode_to_pixelinfo","title":"<code>pilmode_to_pixelinfo(mode)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def pilmode_to_pixelinfo(mode: str) -&gt; tuple:\n    pixelinfo = (np.uint8, 8, 1)\n    mode_types = {\n        'I': (np.uint32, 32, 1),\n        'F': (np.float32, 32, 1),\n        'RGB': (np.uint8, 24, 3),\n        'RGBA': (np.uint8, 32, 4),\n        'CMYK': (np.uint8, 32, 4),\n        'YCbCr': (np.uint8, 24, 3),\n        'LAB': (np.uint8, 24, 3),\n        'HSV': (np.uint8, 24, 3),\n    }\n    if '16' in mode:\n        pixelinfo = (np.uint16, 16, 1)\n    elif '32' in mode:\n        pixelinfo = (np.uint32, 32, 1)\n    elif mode in mode_types:\n        pixelinfo = mode_types[mode]\n    pixelinfo = (np.dtype(pixelinfo[0]), pixelinfo[1])\n    return pixelinfo\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.precise_resize","title":"<code>precise_resize(image, factors)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def precise_resize(image: np.ndarray, factors) -&gt; np.ndarray:\n    if image.ndim &gt; len(factors):\n        factors = list(factors) + [1]\n    new_image = downscale_local_mean(np.asarray(image), tuple(factors)).astype(image.dtype)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.print_dict","title":"<code>print_dict(dct, indent=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_dict(dct: dict, indent: int = 0) -&gt; str:\n    s = ''\n    if isinstance(dct, dict):\n        for key, value in dct.items():\n            s += '\\n'\n            if not isinstance(value, list):\n                s += '\\t' * indent + str(key) + ': '\n            if isinstance(value, dict):\n                s += print_dict(value, indent=indent + 1)\n            elif isinstance(value, list):\n                for v in value:\n                    s += print_dict(v)\n            else:\n                s += str(value)\n    else:\n        s += str(dct)\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.print_hbytes","title":"<code>print_hbytes(nbytes)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_hbytes(nbytes: int) -&gt; str:\n    exps = ['', 'K', 'M', 'G', 'T']\n    div = 1024\n    exp = 0\n\n    while nbytes &gt; div:\n        nbytes /= div\n        exp += 1\n    return f'{nbytes:.1f}{exps[exp]}B'\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.redimension_data","title":"<code>redimension_data(data, old_order, new_order, **indices)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def redimension_data(data, old_order, new_order, **indices):\n    # able to provide optional dimension values e.g. t=0, z=0\n    if new_order == old_order:\n        return data\n\n    new_data = data\n    order = old_order\n    # remove\n    for o in old_order:\n        if o not in new_order:\n            index = order.index(o)\n            dim_value = indices.get(o, 0)\n            new_data = np.take(new_data, indices=dim_value, axis=index)\n            order = order[:index] + order[index + 1:]\n    # add\n    for o in new_order:\n        if o not in order:\n            new_data = np.expand_dims(new_data, 0)\n            order = o + order\n    # move\n    old_indices = [order.index(o) for o in new_order]\n    new_indices = list(range(len(new_order)))\n    new_data = np.moveaxis(new_data, old_indices, new_indices)\n    return new_data\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.reorder","title":"<code>reorder(items, old_order, new_order, default_value=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def reorder(items: list, old_order: str, new_order: str, default_value: int = 0) -&gt; list:\n    new_items = []\n    for label in new_order:\n        if label in old_order:\n            item = items[old_order.index(label)]\n        else:\n            item = default_value\n        new_items.append(item)\n    return new_items\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.round_significants","title":"<code>round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def round_significants(a: float, significant_digits: int) -&gt; float:\n    if a != 0:\n        round_decimals = significant_digits - int(np.floor(np.log10(abs(a)))) - 1\n        return round(a, round_decimals)\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.save_image","title":"<code>save_image(image, filename, output_params={})</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def save_image(image: np.ndarray, filename: str, output_params: dict = {}):\n    compression = output_params.get('compression')\n    PIL.Image.fromarray(image).save(filename, compression=compression)\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.show_image","title":"<code>show_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def show_image(image: np.ndarray):\n    plt.imshow(image)\n    plt.show()\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.show_image_gray","title":"<code>show_image_gray(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def show_image_gray(image: np.ndarray):\n    plt.imshow(image, cmap='gray')\n    plt.show()\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.split_num_text","title":"<code>split_num_text(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_num_text(text: str) -&gt; list:\n    num_texts = []\n    block = ''\n    is_num0 = None\n    if text is None:\n        return None\n\n    for c in text:\n        is_num = (c.isnumeric() or c == '.')\n        if is_num0 is not None and is_num != is_num0:\n            num_texts.append(block)\n            block = ''\n        block += c\n        is_num0 = is_num\n    if block != '':\n        num_texts.append(block)\n\n    num_texts2 = []\n    for block in num_texts:\n        block = block.strip()\n        try:\n            block = float(block)\n        except:\n            pass\n        if block not in [' ', ',', '|']:\n            num_texts2.append(block)\n    return num_texts2\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.split_value_unit_list","title":"<code>split_value_unit_list(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_value_unit_list(text: str) -&gt; list:\n    value_units = []\n    if text is None:\n        return None\n\n    items = split_num_text(text)\n    if isinstance(items[-1], str):\n        def_unit = items[-1]\n    else:\n        def_unit = ''\n\n    i = 0\n    while i &lt; len(items):\n        value = items[i]\n        if i + 1 &lt; len(items):\n            unit = items[i + 1]\n        else:\n            unit = ''\n        if not isinstance(value, str):\n            if isinstance(unit, str):\n                i += 1\n            else:\n                unit = def_unit\n            value_units.append((value, unit))\n        i += 1\n    return value_units\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.tags_to_dict","title":"<code>tags_to_dict(tags)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tags_to_dict(tags: tifffile.TiffTags) -&gt; dict:\n    tag_dict = {}\n    for tag in tags.values():\n        tag_dict[tag.name] = tag.value\n    return tag_dict\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.tiff_info","title":"<code>tiff_info(filename)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tiff_info(filename: str) -&gt; str:\n    s = ''\n    nom_size = 0\n    tiff = TiffFile(filename)\n    real_size = tiff.fstat.st_size\n    s += str(tiff) + '\\n'\n    if tiff.ome_metadata:\n        print(tiff.ome_metadata)\n        s += f'OME: {print_dict(tifffile.xml2dict(tiff.ome_metadata))}\\n'\n    if tiff.metaseries_metadata:\n        s += f'Series: {tiff.metaseries_metadata}\\n'\n    if tiff.imagej_metadata:\n        s += f'ImageJ: {tiff.imagej_metadata}\\n'\n\n    for page0 in get_tiff_pages(tiff):\n        page = page0[0] if isinstance(page0, list) else page0\n        s += str(page) + '\\n'\n        s += f'Size: {np.flip(page.shape)} ({print_hbytes(page.size)})\\n'\n        if page.is_tiled:\n            s += f'Tiling: {page.tilewidth} {page.tilelength} {page.tiledepth}\\n'\n        s += f'Compression: {str(page.compression)} jpegtables: {page.jpegtables is not None}\\n'\n        tag_dict = tags_to_dict(page.tags)\n        if 'TileOffsets' in tag_dict:\n            tag_dict.pop('TileOffsets')\n        if 'TileByteCounts' in tag_dict:\n            tag_dict.pop('TileByteCounts')\n        if 'ImageDescription' in tag_dict and tag_dict['ImageDescription'].startswith('&lt;?xml'):\n            # redundant\n            tag_dict.pop('ImageDescription')\n        s += print_dict(tag_dict) + '\\n\\n'\n        nom_size += page.size\n\n    s += f'Overall compression: 1:{nom_size / real_size:.1f}'\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.PlainImageSource.tiff_info_short","title":"<code>tiff_info_short(filename)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tiff_info_short(filename: str) -&gt; str:\n    nom_size = 0\n    tiff = TiffFile(filename)\n    s = str(filename)\n    real_size = tiff.fstat.st_size\n    for page in tiff.pages:\n        s += ' ' + str(page)\n        nom_size += page.size\n    s += f' Image size:{nom_size} File size:{real_size} Overall compression: 1:{nom_size / real_size:.1f}'\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource","title":"<code>TiffSource</code>","text":""},{"location":"references/#OmeSliCC.TiffSource.TiffSource","title":"<code>TiffSource</code>","text":"<p>               Bases: <code>OmeSource</code></p> <p>Tiff-compatible image source</p> Source code in <code>OmeSliCC\\TiffSource.py</code> <pre><code>class TiffSource(OmeSource):\n    \"\"\"Tiff-compatible image source\"\"\"\n\n    filename: str\n    \"\"\"original filename\"\"\"\n    compressed: bool\n    \"\"\"if image data is loaded compressed\"\"\"\n    decompressed: bool\n    \"\"\"if image data is loaded decompressed\"\"\"\n    pages: list\n    \"\"\"list of all relevant TiffPages\"\"\"\n    data: bytes\n    \"\"\"raw un-decoded image byte data\"\"\"\n    arrays: list\n    \"\"\"list of all image arrays for different sizes\"\"\"\n\n    def __init__(self,\n                 filename: str,\n                 source_pixel_size: list = None,\n                 target_pixel_size: list = None,\n                 source_info_required: bool = False,\n                 executor: ThreadPoolExecutor = None):\n\n        super().__init__()\n        self.compressed = False\n        self.decompressed = False\n        self.executor = executor\n        self.data = bytes()\n        self.arrays = []\n        photometric = None\n        nchannels = 1\n\n        tiff = TiffFile(filename)\n        self.tiff = tiff\n        self.first_page = tiff.pages.first\n        if tiff.is_ome and tiff.ome_metadata is not None:\n            xml_metadata = tiff.ome_metadata\n            self.metadata = XmlDict.xml2dict(xml_metadata)\n            if 'OME' in self.metadata:\n                self.metadata = self.metadata['OME']\n                self.has_ome_metadata = True\n            if 'BinaryOnly' in self.metadata:\n                # binary image only; get metadata from metadata file instead\n                self.has_ome_metadata = False\n                metdata_filename = os.path.join(os.path.dirname(filename),\n                                                self.metadata['BinaryOnly'].get('MetadataFile'))\n                if os.path.isfile(metdata_filename):\n                    metdata_tiff = TiffFile(metdata_filename)\n                    if metdata_tiff.is_ome and metdata_tiff.ome_metadata is not None:\n                        xml_metadata = metdata_tiff.ome_metadata\n                        self.metadata = XmlDict.xml2dict(xml_metadata)\n                        if 'OME' in self.metadata:\n                            self.metadata = self.metadata['OME']\n                            images = self.metadata.get('Image')\n                            if isinstance(images, list):\n                                for image in images:\n                                    if image.get('Name', '').lower() == get_filetitle(filename).lower():\n                                        self.metadata['Image'] = image\n                                        break\n                            self.has_ome_metadata = True\n\n        if self.has_ome_metadata:\n            pass\n        elif tiff.is_imagej:\n            self.metadata = tiff.imagej_metadata\n        elif self.first_page.description:\n            self.metadata = desc_to_dict(self.first_page.description)\n        self.tags = tags_to_dict(self.first_page.tags)\n        if 'FEI_TITAN' in self.tags:\n            metadata = tifffile.xml2dict(self.tags.pop('FEI_TITAN'))\n            if 'FeiImage' in metadata:\n                metadata = metadata['FeiImage']\n            self.metadata.update(metadata)\n\n        if tiff.series:\n            series0 = tiff.series[0]\n            self.dimension_order = series0.axes\n            photometric = series0.keyframe.photometric\n        self.pages = get_tiff_pages(tiff)\n        for page0 in self.pages:\n            if isinstance(page0, list):\n                page = page0[0]\n                npages = len(page0)\n            else:\n                page = page0\n                npages = 1\n            self.npages = npages\n            if not self.dimension_order:\n                self.dimension_order = page.axes\n                photometric = page.photometric\n            shape = page.shape\n            nchannels = shape[2] if len(shape) &gt; 2 else 1\n            nt = 1\n            if isinstance(page, TiffPage):\n                width = page.imagewidth\n                height = page.imagelength\n                self.depth = page.imagedepth\n                depth = self.depth * npages\n                bitspersample = page.bitspersample\n            else:\n                width = shape[1]\n                height = shape[0]\n                depth = npages\n                if len(shape) &gt; 2:\n                    self.depth = shape[2]\n                    depth *= self.depth\n                bitspersample = page.dtype.itemsize * 8\n            if self.has_ome_metadata:\n                pixels = ensure_list(self.metadata.get('Image', {}))[0].get('Pixels', {})\n                depth = int(pixels.get('SizeZ', depth))\n                nchannels = int(pixels.get('SizeC', nchannels))\n                nt = int(pixels.get('SizeT', nt))\n            self.sizes.append((width, height))\n            self.sizes_xyzct.append((width, height, depth, nchannels, nt))\n            self.pixel_types.append(page.dtype)\n            self.pixel_nbits.append(bitspersample)\n\n        self.fh = tiff.filehandle\n        self.dimension_order = self.dimension_order.lower().replace('s', 'c').replace('r', '')\n\n        self.is_rgb = (photometric in (PHOTOMETRIC.RGB, PHOTOMETRIC.PALETTE) and nchannels in (3, 4))\n\n        self._init_metadata(filename,\n                            source_pixel_size=source_pixel_size,\n                            target_pixel_size=target_pixel_size,\n                            source_info_required=source_info_required)\n\n    def _find_metadata(self):\n        pixel_size = []\n        # from OME metadata\n        if self.has_ome_metadata:\n            self._get_ome_metadata()\n            return\n\n        # from imageJ metadata\n        pixel_size_z = None\n        pixel_size_unit = self.metadata.get('unit', '').encode().decode('unicode_escape')\n        if pixel_size_unit == 'micron':\n            pixel_size_unit = self.default_physical_unit\n        if 'scales' in self.metadata:\n            for scale in self.metadata['scales'].split(','):\n                scale = scale.strip()\n                if scale != '':\n                    pixel_size.append((float(scale), pixel_size_unit))\n        if len(pixel_size) == 0 and self.metadata is not None and 'spacing' in self.metadata:\n            pixel_size_z = (self.metadata['spacing'], pixel_size_unit)\n        # from description\n        if len(pixel_size) &lt; 2 and 'pixelWidth' in self.metadata:\n            pixel_info = self.metadata['pixelWidth']\n            pixel_size.append((pixel_info['value'], pixel_info['unit']))\n            pixel_info = self.metadata['pixelHeight']\n            pixel_size.append((pixel_info['value'], pixel_info['unit']))\n        if len(pixel_size) &lt; 2 and 'MPP' in self.metadata:\n            pixel_size.append((self.metadata['MPP'], self.default_physical_unit))\n            pixel_size.append((self.metadata['MPP'], self.default_physical_unit))\n        # from page TAGS\n        if len(pixel_size) &lt; 2:\n            pixel_size_unit = self.tags.get('ResolutionUnit', '')\n            if isinstance(pixel_size_unit, Enum):\n                pixel_size_unit = pixel_size_unit.name\n            pixel_size_unit = pixel_size_unit.lower()\n            if pixel_size_unit == 'none':\n                pixel_size_unit = ''\n            res0 = convert_rational_value(self.tags.get('XResolution'))\n            if res0 is not None and res0 != 0:\n                pixel_size.append((1 / res0, pixel_size_unit))\n            res0 = convert_rational_value(self.tags.get('YResolution'))\n            if res0 is not None and res0 != 0:\n                pixel_size.append((1 / res0, pixel_size_unit))\n\n        position = []\n        xpos = convert_rational_value(self.tags.get('XPosition'))\n        ypos = convert_rational_value(self.tags.get('YPosition'))\n        if xpos is not None and ypos is not None:\n            position = [(xpos, pixel_size_unit), (ypos, pixel_size_unit)]\n\n        if pixel_size_z is not None and len(pixel_size) == 2:\n            pixel_size.append(pixel_size_z)\n\n        mag = self.metadata.get('Mag', self.metadata.get('AppMag', 0))\n\n        nchannels = self.get_nchannels()\n        photometric = str(self.metadata.get('PhotometricInterpretation', '')).lower().split('.')[-1]\n        if nchannels == 3:\n            channels = [{'label': photometric}]\n        else:\n            channels = [{'label': photometric}] * nchannels\n\n        self.source_pixel_size = pixel_size\n        self.source_mag = mag\n        self.channels = channels\n        self.position = position\n\n    def get_source_dask(self):\n        return self._load_as_dask()\n\n    def _load_as_dask(self):\n        if len(self.arrays) == 0:\n            for level in range(len(self.sizes)):\n                if self.tiff.is_mmstack:\n                    page = self.pages[level]\n                    if isinstance(page, list):\n                        page = page[0]\n                    data = da.from_zarr(page.aszarr())\n                else:\n                    data = da.from_zarr(self.tiff.aszarr(level=level))\n                if data.chunksize == data.shape:\n                    data = data.rechunk()\n                self.arrays.append(data)\n        return self.arrays\n\n    def _load_as_zarr(self):\n        if len(self.arrays) == 0:\n            import zarr\n            store = self.tiff.aszarr(multiscales=True)\n            group = zarr.group(store=store)\n            self.arrays = [arr for _, arr in group.arrays()]  # read-only zarr arrays\n        return self.arrays\n\n    def load(self, decompress: bool = False):\n        if decompress:\n            self.decompress()\n            self.decompressed = True\n        else:\n            self.fh.seek(0)\n            self.data = self.fh.read()\n            self.compressed = True\n\n    def unload(self):\n        del self.data\n        self.clear_arrays()\n        self.compressed = False\n        self.decompressed = False\n\n    def decompress(self):\n        self.clear_arrays()\n        for page in self.pages:\n            if isinstance(page, list):\n                array = []\n                for page1 in page:\n                    data = page1.asarray()\n                    if len(page) &gt; 1:\n                        array.append(data)\n                    else:\n                        array = data\n                array = np.asarray(array)\n            else:\n                array = page.asarray()\n            self.arrays.append(array)\n\n    def clear_arrays(self):\n        for array in self.arrays:\n            del array\n        self.arrays = []\n\n    def _asarray_level(self, level: int, **slicing) -&gt; np.ndarray:\n        if self.compressed and not self.decompressed:\n            out = self._decompress(level, **slicing)\n        else:\n            self._load_as_dask()\n            redim = redimension_data(self.arrays[level], self.dimension_order, self.get_dimension_order())\n            slices = get_numpy_slicing(self.get_dimension_order(), **slicing)\n            out = redim[slices]\n        return out\n\n    def _decompress(self, level: int, **slicing) -&gt; np.ndarray:\n        # based on tiffile asarray\n\n        if self.executor is None:\n            max_workers = (os.cpu_count() or 1) + 4\n            self.executor = ThreadPoolExecutor(max_workers)\n\n        x0, x1 = slicing.get('x0', 0), slicing.get('x1', -1)\n        y0, y1 = slicing.get('y0', 0), slicing.get('y1', -1)\n        c, t, z = slicing.get('c'), slicing.get('t'), slicing.get('z')\n        if x1 &lt; 0 or y1 &lt; 0:\n            x1, y1 = self.sizes[level]\n\n        dw = x1 - x0\n        dh = y1 - y0\n        xyzct = list(self.sizes_xyzct[level]).copy()\n        nz = xyzct[2]\n        nc = xyzct[3]\n\n        pages = self.pages[level]\n        if nz == self.npages and z is not None:\n            pages = [pages[z]]\n        elif t is not None:\n            pages = [pages[t]]\n        page = pages[0] if isinstance(pages, list) else pages\n        tile_height, tile_width = page.chunks[:2]\n        tile_y0, tile_x0 = y0 // tile_height, x0 // tile_width\n        tile_y1, tile_x1 = np.ceil([y1 / tile_height, x1 / tile_width]).astype(int)\n        w = (tile_x1 - tile_x0) * tile_width\n        h = (tile_y1 - tile_y0) * tile_height\n        niter_channels = nc if page.dims[0] == 'sample' else 1\n        tile_per_line = int(np.ceil(page.imagewidth / tile_width))\n        tile_per_channel = tile_per_line * int(np.ceil(page.imagelength / tile_height))\n        xyzct[0] = w\n        xyzct[1] = h\n\n        # Match internal Tiff page dimensions [separate sample, depth, length, width, contig sample]\n        n = self.npages\n        d = self.depth\n        s = nc\n        if self.npages == s &gt; 1:\n            # in case channels represented as pages\n            s = 1\n        shape = n, d, h, w, s\n        out = np.zeros(shape, page.dtype)\n\n        dataoffsets = []\n        databytecounts = []\n        tile_locations = []\n        for pagei, page in enumerate(pages):\n            for channeli in range(niter_channels):\n                for y in range(tile_y0, tile_y1):\n                    for x in range(tile_x0, tile_x1):\n                        index = channeli * tile_per_channel + y * tile_per_line + x\n                        if index &lt; len(page.databytecounts):\n                            offset = page.dataoffsets[index]\n                            count = page.databytecounts[index]\n                            if count &gt; 0:\n                                dataoffsets.append(offset)\n                                databytecounts.append(count)\n                                target_y = (y - tile_y0) * tile_height\n                                target_x = (x - tile_x0) * tile_width\n                                tile_locations.append((pagei, 0, target_y, target_x, channeli))\n\n            self._decode(page, dataoffsets, databytecounts, tile_locations, out)\n\n        target_y0 = y0 - tile_y0 * tile_height\n        target_x0 = x0 - tile_x0 * tile_width\n        image = out[:, :, target_y0: target_y0 + dh, target_x0: target_x0 + dw, :]\n        # 'ndyxs' -&gt; 'tzyxc'\n        if image.shape[0] == nc &gt; 1:\n            image = np.swapaxes(image, 0, -1)\n        elif image.shape[0] == nz &gt; 1:\n            image = np.swapaxes(image, 0, 1)\n        # 'tzyxc' -&gt; 'tczyx'\n        image = np.moveaxis(image, -1, 1)\n        return image\n\n    def _decode(self, page: TiffPage, dataoffsets: list, databytecounts: list, tile_locations: list, out: np.ndarray):\n        def process_decoded(decoded, index, out=out):\n            segment, indices, shape = decoded\n            s = tile_locations[index]\n            e = np.array(s) + ([1] + list(shape))\n            # Note: numpy is not thread-safe\n            out[s[0]: e[0],\n                s[1]: e[1],\n                s[2]: e[2],\n                s[3]: e[3],\n                s[4]: e[4]] = segment\n\n        for _ in self._segments(\n                process_function=process_decoded,\n                page=page,\n                dataoffsets=dataoffsets,\n                databytecounts=databytecounts\n        ):\n            pass\n\n    def _segments(self, process_function: callable, page: TiffPage, dataoffsets: list, databytecounts: list) -&gt; tuple:\n        # based on tiffile segments\n        def decode(args, page=page, process_function=process_function):\n            decoded = page.decode(*args, jpegtables=page.jpegtables)\n            return process_function(decoded, args[1])\n\n        tile_segments = []\n        for index in range(len(dataoffsets)):\n            offset = dataoffsets[index]\n            bytecount = databytecounts[index]\n            if self.compressed:\n                segment = self.data[offset:offset + bytecount]\n            else:\n                fh = page.parent.filehandle\n                fh.seek(offset)\n                segment = fh.read(bytecount)\n            tile_segment = (segment, index)\n            tile_segments.append(tile_segment)\n            # yield decode(tile_segment)\n        yield from self.executor.map(decode, tile_segments, timeout=10)\n\n    def close(self):\n        self.tiff.close()\n        self.fh.close()\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.TiffSource.arrays","title":"<code>arrays = []</code>  <code>instance-attribute</code>","text":"<p>list of all image arrays for different sizes</p>"},{"location":"references/#OmeSliCC.TiffSource.TiffSource.compressed","title":"<code>compressed = False</code>  <code>instance-attribute</code>","text":"<p>if image data is loaded compressed</p>"},{"location":"references/#OmeSliCC.TiffSource.TiffSource.data","title":"<code>data = bytes()</code>  <code>instance-attribute</code>","text":"<p>raw un-decoded image byte data</p>"},{"location":"references/#OmeSliCC.TiffSource.TiffSource.decompressed","title":"<code>decompressed = False</code>  <code>instance-attribute</code>","text":"<p>if image data is loaded decompressed</p>"},{"location":"references/#OmeSliCC.TiffSource.TiffSource.depth","title":"<code>depth = page.imagedepth</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.TiffSource.TiffSource.dimension_order","title":"<code>dimension_order = self.dimension_order.lower().replace('s', 'c').replace('r', '')</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.TiffSource.TiffSource.executor","title":"<code>executor = executor</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.TiffSource.TiffSource.fh","title":"<code>fh = tiff.filehandle</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.TiffSource.TiffSource.filename","title":"<code>filename</code>  <code>instance-attribute</code>","text":"<p>original filename</p>"},{"location":"references/#OmeSliCC.TiffSource.TiffSource.first_page","title":"<code>first_page = tiff.pages.first</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.TiffSource.TiffSource.has_ome_metadata","title":"<code>has_ome_metadata = True</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.TiffSource.TiffSource.is_rgb","title":"<code>is_rgb = photometric in (PHOTOMETRIC.RGB, PHOTOMETRIC.PALETTE) and nchannels in (3, 4)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.TiffSource.TiffSource.metadata","title":"<code>metadata = XmlDict.xml2dict(xml_metadata)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.TiffSource.TiffSource.npages","title":"<code>npages = npages</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.TiffSource.TiffSource.pages","title":"<code>pages = get_tiff_pages(tiff)</code>  <code>instance-attribute</code>","text":"<p>list of all relevant TiffPages</p>"},{"location":"references/#OmeSliCC.TiffSource.TiffSource.tags","title":"<code>tags = tags_to_dict(self.first_page.tags)</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.TiffSource.TiffSource.tiff","title":"<code>tiff = tiff</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.TiffSource.TiffSource.__init__","title":"<code>__init__(filename, source_pixel_size=None, target_pixel_size=None, source_info_required=False, executor=None)</code>","text":"Source code in <code>OmeSliCC\\TiffSource.py</code> <pre><code>def __init__(self,\n             filename: str,\n             source_pixel_size: list = None,\n             target_pixel_size: list = None,\n             source_info_required: bool = False,\n             executor: ThreadPoolExecutor = None):\n\n    super().__init__()\n    self.compressed = False\n    self.decompressed = False\n    self.executor = executor\n    self.data = bytes()\n    self.arrays = []\n    photometric = None\n    nchannels = 1\n\n    tiff = TiffFile(filename)\n    self.tiff = tiff\n    self.first_page = tiff.pages.first\n    if tiff.is_ome and tiff.ome_metadata is not None:\n        xml_metadata = tiff.ome_metadata\n        self.metadata = XmlDict.xml2dict(xml_metadata)\n        if 'OME' in self.metadata:\n            self.metadata = self.metadata['OME']\n            self.has_ome_metadata = True\n        if 'BinaryOnly' in self.metadata:\n            # binary image only; get metadata from metadata file instead\n            self.has_ome_metadata = False\n            metdata_filename = os.path.join(os.path.dirname(filename),\n                                            self.metadata['BinaryOnly'].get('MetadataFile'))\n            if os.path.isfile(metdata_filename):\n                metdata_tiff = TiffFile(metdata_filename)\n                if metdata_tiff.is_ome and metdata_tiff.ome_metadata is not None:\n                    xml_metadata = metdata_tiff.ome_metadata\n                    self.metadata = XmlDict.xml2dict(xml_metadata)\n                    if 'OME' in self.metadata:\n                        self.metadata = self.metadata['OME']\n                        images = self.metadata.get('Image')\n                        if isinstance(images, list):\n                            for image in images:\n                                if image.get('Name', '').lower() == get_filetitle(filename).lower():\n                                    self.metadata['Image'] = image\n                                    break\n                        self.has_ome_metadata = True\n\n    if self.has_ome_metadata:\n        pass\n    elif tiff.is_imagej:\n        self.metadata = tiff.imagej_metadata\n    elif self.first_page.description:\n        self.metadata = desc_to_dict(self.first_page.description)\n    self.tags = tags_to_dict(self.first_page.tags)\n    if 'FEI_TITAN' in self.tags:\n        metadata = tifffile.xml2dict(self.tags.pop('FEI_TITAN'))\n        if 'FeiImage' in metadata:\n            metadata = metadata['FeiImage']\n        self.metadata.update(metadata)\n\n    if tiff.series:\n        series0 = tiff.series[0]\n        self.dimension_order = series0.axes\n        photometric = series0.keyframe.photometric\n    self.pages = get_tiff_pages(tiff)\n    for page0 in self.pages:\n        if isinstance(page0, list):\n            page = page0[0]\n            npages = len(page0)\n        else:\n            page = page0\n            npages = 1\n        self.npages = npages\n        if not self.dimension_order:\n            self.dimension_order = page.axes\n            photometric = page.photometric\n        shape = page.shape\n        nchannels = shape[2] if len(shape) &gt; 2 else 1\n        nt = 1\n        if isinstance(page, TiffPage):\n            width = page.imagewidth\n            height = page.imagelength\n            self.depth = page.imagedepth\n            depth = self.depth * npages\n            bitspersample = page.bitspersample\n        else:\n            width = shape[1]\n            height = shape[0]\n            depth = npages\n            if len(shape) &gt; 2:\n                self.depth = shape[2]\n                depth *= self.depth\n            bitspersample = page.dtype.itemsize * 8\n        if self.has_ome_metadata:\n            pixels = ensure_list(self.metadata.get('Image', {}))[0].get('Pixels', {})\n            depth = int(pixels.get('SizeZ', depth))\n            nchannels = int(pixels.get('SizeC', nchannels))\n            nt = int(pixels.get('SizeT', nt))\n        self.sizes.append((width, height))\n        self.sizes_xyzct.append((width, height, depth, nchannels, nt))\n        self.pixel_types.append(page.dtype)\n        self.pixel_nbits.append(bitspersample)\n\n    self.fh = tiff.filehandle\n    self.dimension_order = self.dimension_order.lower().replace('s', 'c').replace('r', '')\n\n    self.is_rgb = (photometric in (PHOTOMETRIC.RGB, PHOTOMETRIC.PALETTE) and nchannels in (3, 4))\n\n    self._init_metadata(filename,\n                        source_pixel_size=source_pixel_size,\n                        target_pixel_size=target_pixel_size,\n                        source_info_required=source_info_required)\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.TiffSource._asarray_level","title":"<code>_asarray_level(level, **slicing)</code>","text":"Source code in <code>OmeSliCC\\TiffSource.py</code> <pre><code>def _asarray_level(self, level: int, **slicing) -&gt; np.ndarray:\n    if self.compressed and not self.decompressed:\n        out = self._decompress(level, **slicing)\n    else:\n        self._load_as_dask()\n        redim = redimension_data(self.arrays[level], self.dimension_order, self.get_dimension_order())\n        slices = get_numpy_slicing(self.get_dimension_order(), **slicing)\n        out = redim[slices]\n    return out\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.TiffSource._decode","title":"<code>_decode(page, dataoffsets, databytecounts, tile_locations, out)</code>","text":"Source code in <code>OmeSliCC\\TiffSource.py</code> <pre><code>def _decode(self, page: TiffPage, dataoffsets: list, databytecounts: list, tile_locations: list, out: np.ndarray):\n    def process_decoded(decoded, index, out=out):\n        segment, indices, shape = decoded\n        s = tile_locations[index]\n        e = np.array(s) + ([1] + list(shape))\n        # Note: numpy is not thread-safe\n        out[s[0]: e[0],\n            s[1]: e[1],\n            s[2]: e[2],\n            s[3]: e[3],\n            s[4]: e[4]] = segment\n\n    for _ in self._segments(\n            process_function=process_decoded,\n            page=page,\n            dataoffsets=dataoffsets,\n            databytecounts=databytecounts\n    ):\n        pass\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.TiffSource._decompress","title":"<code>_decompress(level, **slicing)</code>","text":"Source code in <code>OmeSliCC\\TiffSource.py</code> <pre><code>def _decompress(self, level: int, **slicing) -&gt; np.ndarray:\n    # based on tiffile asarray\n\n    if self.executor is None:\n        max_workers = (os.cpu_count() or 1) + 4\n        self.executor = ThreadPoolExecutor(max_workers)\n\n    x0, x1 = slicing.get('x0', 0), slicing.get('x1', -1)\n    y0, y1 = slicing.get('y0', 0), slicing.get('y1', -1)\n    c, t, z = slicing.get('c'), slicing.get('t'), slicing.get('z')\n    if x1 &lt; 0 or y1 &lt; 0:\n        x1, y1 = self.sizes[level]\n\n    dw = x1 - x0\n    dh = y1 - y0\n    xyzct = list(self.sizes_xyzct[level]).copy()\n    nz = xyzct[2]\n    nc = xyzct[3]\n\n    pages = self.pages[level]\n    if nz == self.npages and z is not None:\n        pages = [pages[z]]\n    elif t is not None:\n        pages = [pages[t]]\n    page = pages[0] if isinstance(pages, list) else pages\n    tile_height, tile_width = page.chunks[:2]\n    tile_y0, tile_x0 = y0 // tile_height, x0 // tile_width\n    tile_y1, tile_x1 = np.ceil([y1 / tile_height, x1 / tile_width]).astype(int)\n    w = (tile_x1 - tile_x0) * tile_width\n    h = (tile_y1 - tile_y0) * tile_height\n    niter_channels = nc if page.dims[0] == 'sample' else 1\n    tile_per_line = int(np.ceil(page.imagewidth / tile_width))\n    tile_per_channel = tile_per_line * int(np.ceil(page.imagelength / tile_height))\n    xyzct[0] = w\n    xyzct[1] = h\n\n    # Match internal Tiff page dimensions [separate sample, depth, length, width, contig sample]\n    n = self.npages\n    d = self.depth\n    s = nc\n    if self.npages == s &gt; 1:\n        # in case channels represented as pages\n        s = 1\n    shape = n, d, h, w, s\n    out = np.zeros(shape, page.dtype)\n\n    dataoffsets = []\n    databytecounts = []\n    tile_locations = []\n    for pagei, page in enumerate(pages):\n        for channeli in range(niter_channels):\n            for y in range(tile_y0, tile_y1):\n                for x in range(tile_x0, tile_x1):\n                    index = channeli * tile_per_channel + y * tile_per_line + x\n                    if index &lt; len(page.databytecounts):\n                        offset = page.dataoffsets[index]\n                        count = page.databytecounts[index]\n                        if count &gt; 0:\n                            dataoffsets.append(offset)\n                            databytecounts.append(count)\n                            target_y = (y - tile_y0) * tile_height\n                            target_x = (x - tile_x0) * tile_width\n                            tile_locations.append((pagei, 0, target_y, target_x, channeli))\n\n        self._decode(page, dataoffsets, databytecounts, tile_locations, out)\n\n    target_y0 = y0 - tile_y0 * tile_height\n    target_x0 = x0 - tile_x0 * tile_width\n    image = out[:, :, target_y0: target_y0 + dh, target_x0: target_x0 + dw, :]\n    # 'ndyxs' -&gt; 'tzyxc'\n    if image.shape[0] == nc &gt; 1:\n        image = np.swapaxes(image, 0, -1)\n    elif image.shape[0] == nz &gt; 1:\n        image = np.swapaxes(image, 0, 1)\n    # 'tzyxc' -&gt; 'tczyx'\n    image = np.moveaxis(image, -1, 1)\n    return image\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.TiffSource._find_metadata","title":"<code>_find_metadata()</code>","text":"Source code in <code>OmeSliCC\\TiffSource.py</code> <pre><code>def _find_metadata(self):\n    pixel_size = []\n    # from OME metadata\n    if self.has_ome_metadata:\n        self._get_ome_metadata()\n        return\n\n    # from imageJ metadata\n    pixel_size_z = None\n    pixel_size_unit = self.metadata.get('unit', '').encode().decode('unicode_escape')\n    if pixel_size_unit == 'micron':\n        pixel_size_unit = self.default_physical_unit\n    if 'scales' in self.metadata:\n        for scale in self.metadata['scales'].split(','):\n            scale = scale.strip()\n            if scale != '':\n                pixel_size.append((float(scale), pixel_size_unit))\n    if len(pixel_size) == 0 and self.metadata is not None and 'spacing' in self.metadata:\n        pixel_size_z = (self.metadata['spacing'], pixel_size_unit)\n    # from description\n    if len(pixel_size) &lt; 2 and 'pixelWidth' in self.metadata:\n        pixel_info = self.metadata['pixelWidth']\n        pixel_size.append((pixel_info['value'], pixel_info['unit']))\n        pixel_info = self.metadata['pixelHeight']\n        pixel_size.append((pixel_info['value'], pixel_info['unit']))\n    if len(pixel_size) &lt; 2 and 'MPP' in self.metadata:\n        pixel_size.append((self.metadata['MPP'], self.default_physical_unit))\n        pixel_size.append((self.metadata['MPP'], self.default_physical_unit))\n    # from page TAGS\n    if len(pixel_size) &lt; 2:\n        pixel_size_unit = self.tags.get('ResolutionUnit', '')\n        if isinstance(pixel_size_unit, Enum):\n            pixel_size_unit = pixel_size_unit.name\n        pixel_size_unit = pixel_size_unit.lower()\n        if pixel_size_unit == 'none':\n            pixel_size_unit = ''\n        res0 = convert_rational_value(self.tags.get('XResolution'))\n        if res0 is not None and res0 != 0:\n            pixel_size.append((1 / res0, pixel_size_unit))\n        res0 = convert_rational_value(self.tags.get('YResolution'))\n        if res0 is not None and res0 != 0:\n            pixel_size.append((1 / res0, pixel_size_unit))\n\n    position = []\n    xpos = convert_rational_value(self.tags.get('XPosition'))\n    ypos = convert_rational_value(self.tags.get('YPosition'))\n    if xpos is not None and ypos is not None:\n        position = [(xpos, pixel_size_unit), (ypos, pixel_size_unit)]\n\n    if pixel_size_z is not None and len(pixel_size) == 2:\n        pixel_size.append(pixel_size_z)\n\n    mag = self.metadata.get('Mag', self.metadata.get('AppMag', 0))\n\n    nchannels = self.get_nchannels()\n    photometric = str(self.metadata.get('PhotometricInterpretation', '')).lower().split('.')[-1]\n    if nchannels == 3:\n        channels = [{'label': photometric}]\n    else:\n        channels = [{'label': photometric}] * nchannels\n\n    self.source_pixel_size = pixel_size\n    self.source_mag = mag\n    self.channels = channels\n    self.position = position\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.TiffSource._load_as_dask","title":"<code>_load_as_dask()</code>","text":"Source code in <code>OmeSliCC\\TiffSource.py</code> <pre><code>def _load_as_dask(self):\n    if len(self.arrays) == 0:\n        for level in range(len(self.sizes)):\n            if self.tiff.is_mmstack:\n                page = self.pages[level]\n                if isinstance(page, list):\n                    page = page[0]\n                data = da.from_zarr(page.aszarr())\n            else:\n                data = da.from_zarr(self.tiff.aszarr(level=level))\n            if data.chunksize == data.shape:\n                data = data.rechunk()\n            self.arrays.append(data)\n    return self.arrays\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.TiffSource._load_as_zarr","title":"<code>_load_as_zarr()</code>","text":"Source code in <code>OmeSliCC\\TiffSource.py</code> <pre><code>def _load_as_zarr(self):\n    if len(self.arrays) == 0:\n        import zarr\n        store = self.tiff.aszarr(multiscales=True)\n        group = zarr.group(store=store)\n        self.arrays = [arr for _, arr in group.arrays()]  # read-only zarr arrays\n    return self.arrays\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.TiffSource._segments","title":"<code>_segments(process_function, page, dataoffsets, databytecounts)</code>","text":"Source code in <code>OmeSliCC\\TiffSource.py</code> <pre><code>def _segments(self, process_function: callable, page: TiffPage, dataoffsets: list, databytecounts: list) -&gt; tuple:\n    # based on tiffile segments\n    def decode(args, page=page, process_function=process_function):\n        decoded = page.decode(*args, jpegtables=page.jpegtables)\n        return process_function(decoded, args[1])\n\n    tile_segments = []\n    for index in range(len(dataoffsets)):\n        offset = dataoffsets[index]\n        bytecount = databytecounts[index]\n        if self.compressed:\n            segment = self.data[offset:offset + bytecount]\n        else:\n            fh = page.parent.filehandle\n            fh.seek(offset)\n            segment = fh.read(bytecount)\n        tile_segment = (segment, index)\n        tile_segments.append(tile_segment)\n        # yield decode(tile_segment)\n    yield from self.executor.map(decode, tile_segments, timeout=10)\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.TiffSource.clear_arrays","title":"<code>clear_arrays()</code>","text":"Source code in <code>OmeSliCC\\TiffSource.py</code> <pre><code>def clear_arrays(self):\n    for array in self.arrays:\n        del array\n    self.arrays = []\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.TiffSource.close","title":"<code>close()</code>","text":"Source code in <code>OmeSliCC\\TiffSource.py</code> <pre><code>def close(self):\n    self.tiff.close()\n    self.fh.close()\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.TiffSource.decompress","title":"<code>decompress()</code>","text":"Source code in <code>OmeSliCC\\TiffSource.py</code> <pre><code>def decompress(self):\n    self.clear_arrays()\n    for page in self.pages:\n        if isinstance(page, list):\n            array = []\n            for page1 in page:\n                data = page1.asarray()\n                if len(page) &gt; 1:\n                    array.append(data)\n                else:\n                    array = data\n            array = np.asarray(array)\n        else:\n            array = page.asarray()\n        self.arrays.append(array)\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.TiffSource.get_source_dask","title":"<code>get_source_dask()</code>","text":"Source code in <code>OmeSliCC\\TiffSource.py</code> <pre><code>def get_source_dask(self):\n    return self._load_as_dask()\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.TiffSource.load","title":"<code>load(decompress=False)</code>","text":"Source code in <code>OmeSliCC\\TiffSource.py</code> <pre><code>def load(self, decompress: bool = False):\n    if decompress:\n        self.decompress()\n        self.decompressed = True\n    else:\n        self.fh.seek(0)\n        self.data = self.fh.read()\n        self.compressed = True\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.TiffSource.unload","title":"<code>unload()</code>","text":"Source code in <code>OmeSliCC\\TiffSource.py</code> <pre><code>def unload(self):\n    del self.data\n    self.clear_arrays()\n    self.compressed = False\n    self.decompressed = False\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.blur_image","title":"<code>blur_image(image, sigma)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def blur_image(image, sigma):\n    nchannels = image.shape[2] if image.ndim == 3 else 1\n    if nchannels not in [1, 3]:\n        new_image = np.zeros_like(image)\n        for channeli in range(nchannels):\n            new_image[..., channeli] = blur_image_single(image[..., channeli], sigma)\n    else:\n        new_image = blur_image_single(image, sigma)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.blur_image_single","title":"<code>blur_image_single(image, sigma)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def blur_image_single(image, sigma):\n    return gaussian_filter(image, sigma)\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.calc_fraction_used","title":"<code>calc_fraction_used(image, threshold=0.1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_fraction_used(image: np.ndarray, threshold: float = 0.1) -&gt; float:\n    low = int(round(threshold * 255))\n    high = int(round((1 - threshold) * 255))\n    shape = image.shape\n    total = shape[0] * shape[1]\n    good = 0\n    for y in range(shape[0]):\n        for x in range(shape[1]):\n            pixel = image[y, x]\n            if low &lt;= pixel[0] &lt; high and low &lt;= pixel[1] &lt; high and low &lt;= pixel[2] &lt; high:\n                good += 1\n    fraction = good / total\n    return fraction\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.calc_pyramid","title":"<code>calc_pyramid(xyzct, npyramid_add=0, pyramid_downsample=2, volumetric_resize=False)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_pyramid(xyzct: tuple, npyramid_add: int = 0, pyramid_downsample: float = 2,\n                 volumetric_resize: bool = False) -&gt; list:\n    x, y, z, c, t = xyzct\n    if volumetric_resize and z &gt; 1:\n        size = (x, y, z)\n    else:\n        size = (x, y)\n    sizes_add = []\n    scale = 1\n    for _ in range(npyramid_add):\n        scale /= pyramid_downsample\n        scaled_size = np.maximum(np.round(np.multiply(size, scale)).astype(int), 1)\n        sizes_add.append(scaled_size)\n    return sizes_add\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.calc_tiles_median","title":"<code>calc_tiles_median(images)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_tiles_median(images):\n    out_image = np.zeros_like(images[0])\n    median_image = np.median(images, 0, out_image)\n    return median_image\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.calc_tiles_quantiles","title":"<code>calc_tiles_quantiles(images, quantiles)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_tiles_quantiles(images, quantiles):\n    out_quantiles = []\n    quantile_images = np.quantile(images, quantiles, 0)\n    for quantile_image in quantile_images:\n        maxval = 2 ** (8 * images[0].dtype.itemsize) - 1\n        image = (quantile_image / maxval).astype(np.float32)\n        out_quantiles.append(image)\n    return out_quantiles\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.check_round_significants","title":"<code>check_round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def check_round_significants(a: float, significant_digits: int) -&gt; float:\n    rounded = round_significants(a, significant_digits)\n    if a != 0:\n        dif = 1 - rounded / a\n    else:\n        dif = rounded - a\n    if abs(dif) &lt; 10 ** -significant_digits:\n        return rounded\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.check_versions","title":"<code>check_versions()</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def check_versions():\n    print(f'tifffile {tifffile.__version__}')\n    print(imagecodecs.version())\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.compare_image","title":"<code>compare_image(image0, image1, show=False)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image(image0, image1, show=False) -&gt; float:\n    dif, dif_max, dif_mean, psnr = compare_image_dist(image0, image1)\n    print(f'rgb dist max: {dif_max:.1f} mean: {dif_mean:.1f} PSNR: {psnr:.1f}')\n    if show:\n        show_image(dif)\n        show_image((dif * 10).astype(np.uint8))\n    return dif\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.compare_image_dist","title":"<code>compare_image_dist(image0, image1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image_dist(image0: np.ndarray, image1: np.ndarray) -&gt; tuple:\n    dif = cv.absdiff(image0, image1)\n    psnr = cv.PSNR(image0, image1)\n    if dif.size &gt; 1000000000:\n        # split very large array\n        rgb_maxs = []\n        rgb_means = []\n        for dif1 in np.array_split(dif, 16):\n            rgb_dif = np.linalg.norm(dif1, axis=2)\n            rgb_maxs.append(np.max(rgb_dif))\n            rgb_means.append(np.mean(rgb_dif))\n        rgb_max = np.max(rgb_maxs)\n        rgb_mean = np.mean(rgb_means)\n    else:\n        rgb_dif = np.linalg.norm(dif, axis=2)\n        rgb_max = np.max(rgb_dif)\n        rgb_mean = np.mean(rgb_dif)\n    return dif, rgb_max, rgb_mean, psnr\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.compare_image_dist_simple","title":"<code>compare_image_dist_simple(image0, image1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image_dist_simple(image0: np.ndarray, image1: np.ndarray) -&gt; dict:\n    dif = cv.absdiff(image0, image1)\n    psnr = cv.PSNR(image0, image1)\n    rgb_dif = np.linalg.norm(dif, axis=2)\n    dif_max = np.max(rgb_dif)\n    dif_mean = np.mean(rgb_dif)\n    return {'dif_max': dif_max, 'dif_mean': dif_mean, 'psnr': psnr}\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.convert_image_sign_type","title":"<code>convert_image_sign_type(image, target_dtype)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def convert_image_sign_type(image: np.ndarray, target_dtype: np.dtype) -&gt; np.ndarray:\n    source_dtype = image.dtype\n    if source_dtype.kind == target_dtype.kind:\n        new_image = image\n    elif source_dtype.kind == 'i':\n        new_image = ensure_unsigned_image(image)\n    else:\n        # conversion without overhead\n        offset = 2 ** (8 * target_dtype.itemsize - 1)\n        new_image = (image - offset).astype(target_dtype)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.convert_rational_value","title":"<code>convert_rational_value(value)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def convert_rational_value(value) -&gt; float:\n    if value is not None and isinstance(value, tuple):\n        value = value[0] / value[1]\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.create_compression_codecs","title":"<code>create_compression_codecs(compression)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def create_compression_codecs(compression: list) -&gt; list:\n    codecs = None\n    compression = ensure_list(compression)\n    if compression is not None and len(compression) &gt; 0:\n        compression_type = compression[0].lower()\n        if len(compression) &gt; 1:\n            level = int(compression[1])\n        else:\n            level = None\n        if 'lzw' in compression_type:\n            from imagecodecs.numcodecs import Lzw\n            codecs = [Lzw()]\n        elif '2k' in compression_type or '2000' in compression_type:\n            from imagecodecs.numcodecs import Jpeg2k\n            codecs = [Jpeg2k(level=level)]\n        elif 'jpegls' in compression_type:\n            from imagecodecs.numcodecs import Jpegls\n            codecs = [Jpegls(level=level)]\n        elif 'jpegxr' in compression_type:\n            from imagecodecs.numcodecs import Jpegxr\n            codecs = [Jpegxr(level=level)]\n        elif 'jpegxl' in compression_type:\n            from imagecodecs.numcodecs import Jpegxl\n            codecs = [Jpegxl(level=level)]\n        else:\n            codecs = [compression]\n    return codecs\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.create_compression_filter","title":"<code>create_compression_filter(compression)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def create_compression_filter(compression: list) -&gt; tuple:\n    compressor, compression_filters = None, None\n    compression = ensure_list(compression)\n    if compression is not None and len(compression) &gt; 0:\n        compression_type = compression[0].lower()\n        if len(compression) &gt; 1:\n            level = int(compression[1])\n        else:\n            level = None\n        if 'lzw' in compression_type:\n            from imagecodecs.numcodecs import Lzw\n            compression_filters = [Lzw()]\n        elif '2k' in compression_type or '2000' in compression_type:\n            from imagecodecs.numcodecs import Jpeg2k\n            compression_filters = [Jpeg2k(level=level)]\n        elif 'jpegls' in compression_type:\n            from imagecodecs.numcodecs import Jpegls\n            compression_filters = [Jpegls(level=level)]\n        elif 'jpegxr' in compression_type:\n            from imagecodecs.numcodecs import Jpegxr\n            compression_filters = [Jpegxr(level=level)]\n        elif 'jpegxl' in compression_type:\n            from imagecodecs.numcodecs import Jpegxl\n            compression_filters = [Jpegxl(level=level)]\n        else:\n            compressor = compression\n    return compressor, compression_filters\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.desc_to_dict","title":"<code>desc_to_dict(desc)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def desc_to_dict(desc: str) -&gt; dict:\n    desc_dict = {}\n    if desc.startswith('{'):\n        try:\n            metadata = ast.literal_eval(desc)\n            return metadata\n        except:\n            pass\n    for item in re.split(r'[\\r\\n\\t|]', desc):\n        item_sep = '='\n        if ':' in item:\n            item_sep = ':'\n        if item_sep in item:\n            items = item.split(item_sep)\n            key = items[0].strip()\n            value = items[1].strip()\n            for dtype in (int, float, bool):\n                try:\n                    value = dtype(value)\n                    break\n                except:\n                    pass\n            desc_dict[key] = value\n    return desc_dict\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.ensure_list","title":"<code>ensure_list(x)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def ensure_list(x) -&gt; list:\n    if x is None:\n        return []\n    elif isinstance(x, list):\n        return x\n    else:\n        return [x]\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.ensure_unsigned_image","title":"<code>ensure_unsigned_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def ensure_unsigned_image(image: np.ndarray) -&gt; np.ndarray:\n    source_dtype = image.dtype\n    dtype = ensure_unsigned_type(source_dtype)\n    if dtype != source_dtype:\n        # conversion without overhead\n        offset = 2 ** (8 * dtype.itemsize - 1)\n        new_image = image.astype(dtype) + offset\n    else:\n        new_image = image\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.ensure_unsigned_type","title":"<code>ensure_unsigned_type(dtype)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def ensure_unsigned_type(dtype: np.dtype) -&gt; np.dtype:\n    new_dtype = dtype\n    if dtype.kind == 'i' or dtype.byteorder == '&gt;' or dtype.byteorder == '&lt;':\n        new_dtype = np.dtype(f'u{dtype.itemsize}')\n    return new_dtype\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.file_to_dict","title":"<code>file_to_dict(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def file_to_dict(filename: str) -&gt; dict:\n    ext = os.path.splitext(filename)[1]\n    content = open(filename, 'r').read()\n    if ext == '.xml':\n        data = xmltodict.parse(content)\n    elif ext in ['.yml', '.yaml']:\n        data = yaml.safe_load(content)\n    else:   # assume json\n        data = json.loads(content)\n    return data\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.filter_dict","title":"<code>filter_dict(dict0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def filter_dict(dict0: dict) -&gt; dict:\n    new_dict = {}\n    for key, value0 in dict0.items():\n        if value0 is not None:\n            values = []\n            for value in ensure_list(value0):\n                if isinstance(value, dict):\n                    value = filter_dict(value)\n                values.append(value)\n            if len(values) == 1:\n                values = values[0]\n            new_dict[key] = values\n    return new_dict\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.float2int_image","title":"<code>float2int_image(image, target_dtype=np.dtype(np.uint8))</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def float2int_image(image, target_dtype=np.dtype(np.uint8)):\n    source_dtype = image.dtype\n    if source_dtype.kind not in ('i', 'u') and not target_dtype.kind == 'f':\n        maxval = 2 ** (8 * target_dtype.itemsize) - 1\n        return (image * maxval).astype(target_dtype)\n    else:\n        return image\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.get_default","title":"<code>get_default(x, default)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_default(x, default):\n    return default if x is None else x\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.get_filetitle","title":"<code>get_filetitle(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_filetitle(filename: str) -&gt; str:\n    filebase = os.path.basename(filename)\n    title = os.path.splitext(filebase)[0].rstrip('.ome')\n    return title\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.get_image_quantile","title":"<code>get_image_quantile(image, quantile, axis=None)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_image_quantile(image: np.ndarray, quantile: float, axis=None) -&gt; float:\n    value = np.quantile(image, quantile, axis=axis).astype(image.dtype)\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.get_image_size_info","title":"<code>get_image_size_info(sizes_xyzct, pixel_nbytes, pixel_type, channels)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_image_size_info(sizes_xyzct: list, pixel_nbytes: int, pixel_type: np.dtype, channels: list) -&gt; str:\n    image_size_info = 'XYZCT:'\n    size = 0\n    for i, size_xyzct in enumerate(sizes_xyzct):\n        w, h, zs, cs, ts = size_xyzct\n        size += np.int64(pixel_nbytes) * w * h * zs * cs * ts\n        if i &gt; 0:\n            image_size_info += ','\n        image_size_info += f' {w} {h} {zs} {cs} {ts}'\n    image_size_info += f' Pixel type: {pixel_type} Uncompressed: {print_hbytes(size)}'\n    if sizes_xyzct[0][3] == 3:\n        channel_info = 'rgb'\n    else:\n        channel_info = ','.join([channel.get('Name', '') for channel in channels])\n    if channel_info != '':\n        image_size_info += f' Channels: {channel_info}'\n    return image_size_info\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.get_numpy_slicing","title":"<code>get_numpy_slicing(dimension_order, **slicing)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_numpy_slicing(dimension_order, **slicing):\n    slices = []\n    for axis in dimension_order:\n        index = slicing.get(axis)\n        index0 = slicing.get(axis + '0')\n        index1 = slicing.get(axis + '1')\n        if index0 is not None and index1 is not None:\n            slice1 = slice(int(index0), int(index1))\n        elif index is not None:\n            slice1 = int(index)\n        else:\n            slice1 = slice(None)\n        slices.append(slice1)\n    return tuple(slices)\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.get_pil_metadata","title":"<code>get_pil_metadata(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_pil_metadata(image: PIL.Image) -&gt; dict:\n    metadata = {}\n    exifdata = image.getexif()\n    for tag_id in exifdata:\n        tag = TAGS.get(tag_id, tag_id)\n        data = exifdata.get(tag_id)\n        if isinstance(data, bytes):\n            data = data.decode()\n        metadata[tag] = data\n    if metadata == {}:\n        metadata = image.info\n    return metadata\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.get_tiff_pages","title":"<code>get_tiff_pages(tiff)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_tiff_pages(tiff: TiffFile) -&gt; list:\n    # TODO: review so this works for multi-level ome-tiff, tiff-stack, and z pages tiff, then later check for mmstack\n    pages = []\n    found = False\n    if tiff.series and not tiff.is_mmstack:\n        # has series\n        baseline = tiff.series[0]\n        for level in baseline.levels:\n            # has levels\n            level_pages = []\n            for page in level.pages:\n                found = True\n                level_pages.append(page)\n            if level_pages:\n                pages.append(level_pages)\n\n    if not found:\n        for page in tiff.pages:\n            pages.append(page)\n    return pages\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.get_value_units_micrometer","title":"<code>get_value_units_micrometer(value_units0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_value_units_micrometer(value_units0: list) -&gt; list:\n    conversions = {'nm': 1e-3, '\u00b5m': 1, 'um': 1, 'micrometer': 1, 'mm': 1e3, 'cm': 1e4, 'm': 1e6}\n    if value_units0 is None:\n        return None\n\n    values_um = []\n    for value_unit in value_units0:\n        if not (isinstance(value_unit, int) or isinstance(value_unit, float)):\n            value_um = value_unit[0] * conversions.get(value_unit[1], 1)\n        else:\n            value_um = value_unit\n        values_um.append(value_um)\n    return values_um\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.image_reshape","title":"<code>image_reshape(image, target_size)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def image_reshape(image: np.ndarray, target_size: tuple) -&gt; np.ndarray:\n    tw, th = target_size\n    sh, sw = image.shape[0:2]\n    if sw &lt; tw or sh &lt; th:\n        dw = max(tw - sw, 0)\n        dh = max(th - sh, 0)\n        padding = [(0, dh), (0, dw)]\n        if len(image.shape) == 3:\n            padding += [(0, 0)]\n        image = np.pad(image, padding, 'edge')\n    if tw &lt; sw or th &lt; sh:\n        image = image[0:th, 0:tw]\n    return image\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.image_resize","title":"<code>image_resize(image, target_size0, dimension_order='yxc')</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def image_resize(image: np.ndarray, target_size0: tuple, dimension_order: str = 'yxc') -&gt; np.ndarray:\n    shape = image.shape\n    x_index = dimension_order.index('x')\n    y_index = dimension_order.index('y')\n    c_is_at_end = ('c' in dimension_order and dimension_order.endswith('c'))\n    size = shape[x_index], shape[y_index]\n    if np.mean(np.divide(size, target_size0)) &lt; 1:\n        interpolation = cv.INTER_CUBIC\n    else:\n        interpolation = cv.INTER_AREA\n    dtype0 = image.dtype\n    image = ensure_unsigned_image(image)\n    target_size = tuple(np.maximum(np.round(target_size0).astype(int), 1))\n    if dimension_order in ['yxc', 'yx']:\n        new_image = cv.resize(np.asarray(image), target_size, interpolation=interpolation)\n    elif dimension_order == 'cyx':\n        new_image = np.moveaxis(image, 0, -1)\n        new_image = cv.resize(np.asarray(new_image), target_size, interpolation=interpolation)\n        new_image = np.moveaxis(new_image, -1, 0)\n    else:\n        ts = image.shape[dimension_order.index('t')] if 't' in dimension_order else 1\n        zs = image.shape[dimension_order.index('z')] if 'z' in dimension_order else 1\n        target_shape = list(image.shape).copy()\n        target_shape[x_index] = target_size[0]\n        target_shape[y_index] = target_size[1]\n        new_image = np.zeros(target_shape, dtype=image.dtype)\n        for t in range(ts):\n            for z in range(zs):\n                slices = get_numpy_slicing(dimension_order, z=z, t=t)\n                image1 = image[slices]\n                if not c_is_at_end:\n                    image1 = np.moveaxis(image1, 0, -1)\n                new_image1 = np.atleast_3d(cv.resize(np.asarray(image1), target_size, interpolation=interpolation))\n                if not c_is_at_end:\n                    new_image1 = np.moveaxis(new_image1, -1, 0)\n                new_image[slices] = new_image1\n    new_image = convert_image_sign_type(new_image, dtype0)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.int2float_image","title":"<code>int2float_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def int2float_image(image):\n    source_dtype = image.dtype\n    if not source_dtype.kind == 'f':\n        maxval = 2 ** (8 * source_dtype.itemsize) - 1\n        return image / np.float32(maxval)\n    else:\n        return image\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.normalise_values","title":"<code>normalise_values(image, min_value, max_value)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def normalise_values(image: np.ndarray, min_value: float, max_value: float) -&gt; np.ndarray:\n    return np.clip((image.astype(np.float32) - min_value) / (max_value - min_value), 0, 1)\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.pilmode_to_pixelinfo","title":"<code>pilmode_to_pixelinfo(mode)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def pilmode_to_pixelinfo(mode: str) -&gt; tuple:\n    pixelinfo = (np.uint8, 8, 1)\n    mode_types = {\n        'I': (np.uint32, 32, 1),\n        'F': (np.float32, 32, 1),\n        'RGB': (np.uint8, 24, 3),\n        'RGBA': (np.uint8, 32, 4),\n        'CMYK': (np.uint8, 32, 4),\n        'YCbCr': (np.uint8, 24, 3),\n        'LAB': (np.uint8, 24, 3),\n        'HSV': (np.uint8, 24, 3),\n    }\n    if '16' in mode:\n        pixelinfo = (np.uint16, 16, 1)\n    elif '32' in mode:\n        pixelinfo = (np.uint32, 32, 1)\n    elif mode in mode_types:\n        pixelinfo = mode_types[mode]\n    pixelinfo = (np.dtype(pixelinfo[0]), pixelinfo[1])\n    return pixelinfo\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.precise_resize","title":"<code>precise_resize(image, factors)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def precise_resize(image: np.ndarray, factors) -&gt; np.ndarray:\n    if image.ndim &gt; len(factors):\n        factors = list(factors) + [1]\n    new_image = downscale_local_mean(np.asarray(image), tuple(factors)).astype(image.dtype)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.print_dict","title":"<code>print_dict(dct, indent=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_dict(dct: dict, indent: int = 0) -&gt; str:\n    s = ''\n    if isinstance(dct, dict):\n        for key, value in dct.items():\n            s += '\\n'\n            if not isinstance(value, list):\n                s += '\\t' * indent + str(key) + ': '\n            if isinstance(value, dict):\n                s += print_dict(value, indent=indent + 1)\n            elif isinstance(value, list):\n                for v in value:\n                    s += print_dict(v)\n            else:\n                s += str(value)\n    else:\n        s += str(dct)\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.print_hbytes","title":"<code>print_hbytes(nbytes)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_hbytes(nbytes: int) -&gt; str:\n    exps = ['', 'K', 'M', 'G', 'T']\n    div = 1024\n    exp = 0\n\n    while nbytes &gt; div:\n        nbytes /= div\n        exp += 1\n    return f'{nbytes:.1f}{exps[exp]}B'\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.redimension_data","title":"<code>redimension_data(data, old_order, new_order, **indices)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def redimension_data(data, old_order, new_order, **indices):\n    # able to provide optional dimension values e.g. t=0, z=0\n    if new_order == old_order:\n        return data\n\n    new_data = data\n    order = old_order\n    # remove\n    for o in old_order:\n        if o not in new_order:\n            index = order.index(o)\n            dim_value = indices.get(o, 0)\n            new_data = np.take(new_data, indices=dim_value, axis=index)\n            order = order[:index] + order[index + 1:]\n    # add\n    for o in new_order:\n        if o not in order:\n            new_data = np.expand_dims(new_data, 0)\n            order = o + order\n    # move\n    old_indices = [order.index(o) for o in new_order]\n    new_indices = list(range(len(new_order)))\n    new_data = np.moveaxis(new_data, old_indices, new_indices)\n    return new_data\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.reorder","title":"<code>reorder(items, old_order, new_order, default_value=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def reorder(items: list, old_order: str, new_order: str, default_value: int = 0) -&gt; list:\n    new_items = []\n    for label in new_order:\n        if label in old_order:\n            item = items[old_order.index(label)]\n        else:\n            item = default_value\n        new_items.append(item)\n    return new_items\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.round_significants","title":"<code>round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def round_significants(a: float, significant_digits: int) -&gt; float:\n    if a != 0:\n        round_decimals = significant_digits - int(np.floor(np.log10(abs(a)))) - 1\n        return round(a, round_decimals)\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.save_image","title":"<code>save_image(image, filename, output_params={})</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def save_image(image: np.ndarray, filename: str, output_params: dict = {}):\n    compression = output_params.get('compression')\n    PIL.Image.fromarray(image).save(filename, compression=compression)\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.show_image","title":"<code>show_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def show_image(image: np.ndarray):\n    plt.imshow(image)\n    plt.show()\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.show_image_gray","title":"<code>show_image_gray(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def show_image_gray(image: np.ndarray):\n    plt.imshow(image, cmap='gray')\n    plt.show()\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.split_num_text","title":"<code>split_num_text(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_num_text(text: str) -&gt; list:\n    num_texts = []\n    block = ''\n    is_num0 = None\n    if text is None:\n        return None\n\n    for c in text:\n        is_num = (c.isnumeric() or c == '.')\n        if is_num0 is not None and is_num != is_num0:\n            num_texts.append(block)\n            block = ''\n        block += c\n        is_num0 = is_num\n    if block != '':\n        num_texts.append(block)\n\n    num_texts2 = []\n    for block in num_texts:\n        block = block.strip()\n        try:\n            block = float(block)\n        except:\n            pass\n        if block not in [' ', ',', '|']:\n            num_texts2.append(block)\n    return num_texts2\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.split_value_unit_list","title":"<code>split_value_unit_list(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_value_unit_list(text: str) -&gt; list:\n    value_units = []\n    if text is None:\n        return None\n\n    items = split_num_text(text)\n    if isinstance(items[-1], str):\n        def_unit = items[-1]\n    else:\n        def_unit = ''\n\n    i = 0\n    while i &lt; len(items):\n        value = items[i]\n        if i + 1 &lt; len(items):\n            unit = items[i + 1]\n        else:\n            unit = ''\n        if not isinstance(value, str):\n            if isinstance(unit, str):\n                i += 1\n            else:\n                unit = def_unit\n            value_units.append((value, unit))\n        i += 1\n    return value_units\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.tags_to_dict","title":"<code>tags_to_dict(tags)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tags_to_dict(tags: tifffile.TiffTags) -&gt; dict:\n    tag_dict = {}\n    for tag in tags.values():\n        tag_dict[tag.name] = tag.value\n    return tag_dict\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.tiff_info","title":"<code>tiff_info(filename)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tiff_info(filename: str) -&gt; str:\n    s = ''\n    nom_size = 0\n    tiff = TiffFile(filename)\n    real_size = tiff.fstat.st_size\n    s += str(tiff) + '\\n'\n    if tiff.ome_metadata:\n        print(tiff.ome_metadata)\n        s += f'OME: {print_dict(tifffile.xml2dict(tiff.ome_metadata))}\\n'\n    if tiff.metaseries_metadata:\n        s += f'Series: {tiff.metaseries_metadata}\\n'\n    if tiff.imagej_metadata:\n        s += f'ImageJ: {tiff.imagej_metadata}\\n'\n\n    for page0 in get_tiff_pages(tiff):\n        page = page0[0] if isinstance(page0, list) else page0\n        s += str(page) + '\\n'\n        s += f'Size: {np.flip(page.shape)} ({print_hbytes(page.size)})\\n'\n        if page.is_tiled:\n            s += f'Tiling: {page.tilewidth} {page.tilelength} {page.tiledepth}\\n'\n        s += f'Compression: {str(page.compression)} jpegtables: {page.jpegtables is not None}\\n'\n        tag_dict = tags_to_dict(page.tags)\n        if 'TileOffsets' in tag_dict:\n            tag_dict.pop('TileOffsets')\n        if 'TileByteCounts' in tag_dict:\n            tag_dict.pop('TileByteCounts')\n        if 'ImageDescription' in tag_dict and tag_dict['ImageDescription'].startswith('&lt;?xml'):\n            # redundant\n            tag_dict.pop('ImageDescription')\n        s += print_dict(tag_dict) + '\\n\\n'\n        nom_size += page.size\n\n    s += f'Overall compression: 1:{nom_size / real_size:.1f}'\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.TiffSource.tiff_info_short","title":"<code>tiff_info_short(filename)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tiff_info_short(filename: str) -&gt; str:\n    nom_size = 0\n    tiff = TiffFile(filename)\n    s = str(filename)\n    real_size = tiff.fstat.st_size\n    for page in tiff.pages:\n        s += ' ' + str(page)\n        nom_size += page.size\n    s += f' Image size:{nom_size} File size:{real_size} Overall compression: 1:{nom_size / real_size:.1f}'\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.XmlDict","title":"<code>XmlDict</code>","text":""},{"location":"references/#OmeSliCC.XmlDict.dct","title":"<code>dct = {'@a': 1, 'b': {'@aa': 2, 'bb': 3}}</code>  <code>module-attribute</code>","text":""},{"location":"references/#OmeSliCC.XmlDict.test","title":"<code>test = XmlDict(dct)</code>  <code>module-attribute</code>","text":""},{"location":"references/#OmeSliCC.XmlDict.xml","title":"<code>xml = xmltodict.unparse({'TEST': test}, short_empty_elements=True, pretty=True)</code>  <code>module-attribute</code>","text":""},{"location":"references/#OmeSliCC.XmlDict.XmlDict","title":"<code>XmlDict</code>","text":"<p>               Bases: <code>dict</code></p> <p>xmltodict type dictionary providing and propagating access to keys without @ sign</p> Source code in <code>OmeSliCC\\XmlDict.py</code> <pre><code>class XmlDict(dict):\n    \"\"\"xmltodict type dictionary providing and propagating access to keys without @ sign\"\"\"\n\n    def __getitem__(self, key: str):\n        at_key = '@' + key\n        if key not in self and at_key in self:\n            key = at_key\n        value = dict.__getitem__(self, key)\n        if isinstance(value, dict):\n            value = XmlDict(value)\n        if isinstance(value, list):\n            value = XmlList(value)\n        return value\n\n    def get(self, key: str, default=None):\n        try:\n            return self[key]\n        except KeyError:\n            return default\n\n    def copy(self) -&gt; XmlDict:\n        return XmlDict(dict.copy(self))\n</code></pre>"},{"location":"references/#OmeSliCC.XmlDict.XmlDict.__getitem__","title":"<code>__getitem__(key)</code>","text":"Source code in <code>OmeSliCC\\XmlDict.py</code> <pre><code>def __getitem__(self, key: str):\n    at_key = '@' + key\n    if key not in self and at_key in self:\n        key = at_key\n    value = dict.__getitem__(self, key)\n    if isinstance(value, dict):\n        value = XmlDict(value)\n    if isinstance(value, list):\n        value = XmlList(value)\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.XmlDict.XmlDict.copy","title":"<code>copy()</code>","text":"Source code in <code>OmeSliCC\\XmlDict.py</code> <pre><code>def copy(self) -&gt; XmlDict:\n    return XmlDict(dict.copy(self))\n</code></pre>"},{"location":"references/#OmeSliCC.XmlDict.XmlDict.get","title":"<code>get(key, default=None)</code>","text":"Source code in <code>OmeSliCC\\XmlDict.py</code> <pre><code>def get(self, key: str, default=None):\n    try:\n        return self[key]\n    except KeyError:\n        return default\n</code></pre>"},{"location":"references/#OmeSliCC.XmlDict.XmlList","title":"<code>XmlList</code>","text":"<p>               Bases: <code>list</code></p> <p>xmltodict type list propagating access to keys without @ sign</p> Source code in <code>OmeSliCC\\XmlDict.py</code> <pre><code>class XmlList(list):\n    \"\"\"xmltodict type list propagating access to keys without @ sign\"\"\"\n\n    def __getitem__(self, index: int):\n        value = list.__getitem__(self, index)\n        if isinstance(value, dict):\n            value = XmlDict(value)\n        if isinstance(value, list):\n            value = XmlList(value)\n        return value\n\n    def __iter__(self) -&gt; XmlList:\n        self.i = 0\n        return self\n\n    def __next__(self):\n        if self.i &lt; len(self):\n            item = self[self.i]\n            self.i += 1\n            return item\n        else:\n            raise StopIteration\n</code></pre>"},{"location":"references/#OmeSliCC.XmlDict.XmlList.__getitem__","title":"<code>__getitem__(index)</code>","text":"Source code in <code>OmeSliCC\\XmlDict.py</code> <pre><code>def __getitem__(self, index: int):\n    value = list.__getitem__(self, index)\n    if isinstance(value, dict):\n        value = XmlDict(value)\n    if isinstance(value, list):\n        value = XmlList(value)\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.XmlDict.XmlList.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>OmeSliCC\\XmlDict.py</code> <pre><code>def __iter__(self) -&gt; XmlList:\n    self.i = 0\n    return self\n</code></pre>"},{"location":"references/#OmeSliCC.XmlDict.XmlList.__next__","title":"<code>__next__()</code>","text":"Source code in <code>OmeSliCC\\XmlDict.py</code> <pre><code>def __next__(self):\n    if self.i &lt; len(self):\n        item = self[self.i]\n        self.i += 1\n        return item\n    else:\n        raise StopIteration\n</code></pre>"},{"location":"references/#OmeSliCC.XmlDict.dict2xml","title":"<code>dict2xml(dct)</code>","text":"Source code in <code>OmeSliCC\\XmlDict.py</code> <pre><code>def dict2xml(dct: dict) -&gt; str:\n    return xmltodict.unparse(dct, short_empty_elements=True, pretty=True)\n</code></pre>"},{"location":"references/#OmeSliCC.XmlDict.xml2dict","title":"<code>xml2dict(xml_metadata)</code>","text":"Source code in <code>OmeSliCC\\XmlDict.py</code> <pre><code>def xml2dict(xml_metadata: str) -&gt; dict:\n    return XmlDict(xmltodict.parse(xml_metadata))\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr","title":"<code>Zarr</code>","text":""},{"location":"references/#OmeSliCC.Zarr.Zarr","title":"<code>Zarr</code>","text":"Source code in <code>OmeSliCC\\Zarr.py</code> <pre><code>class Zarr:\n    def __init__(self, filename, ome=None, v3=False):\n        self.filename = filename\n        if ome is not None:\n            self.ome = ome\n        else:\n            self.ome = ('ome' == self.filename.split('.')[1].lower())\n        self.v3 = v3\n        self.data = []\n\n    def create(self, source, shapes=[], chunk_shapes=[], level_scales=[],\n               tile_size=None, npyramid_add=0, pyramid_downsample=2, compression=[]):\n        # create empty dataset\n        dimension_order = source.get_dimension_order()\n        self.dimension_order = dimension_order\n        nlevels = max(1 + npyramid_add, len(shapes))\n        self.npyramid_add = npyramid_add\n        self.pyramid_downsample = pyramid_downsample\n        self.level_scales = level_scales\n        if self.v3:\n            import zarrita\n            store_path = zarrita.store.make_store_path(self.filename)\n            if os.path.exists(self.filename):\n                shutil.rmtree(self.filename)\n            self.zarr_root = zarrita.Group.create(store=store_path, exists_ok=True)\n            ome_version = '0.5-dev1'\n        else:\n            file_url = pathlib.Path(self.filename, mode='w').as_uri()\n            self.zarr_root = zarr.open_group(store=file_url, mode='w', storage_options={'dimension_separator': '/'})\n            ome_version = '0.4'\n        xyzct = source.get_size_xyzct()\n        self.scaler = Scaler(downscale=pyramid_downsample, max_layer=npyramid_add)\n        shape0 = [xyzct['xyzct'.index(dimension)] for dimension in dimension_order]\n        dtype = source.pixel_types[0]\n        pixel_size_um = source.get_pixel_size_micrometer()\n        translation_um = source.get_position_micrometer()\n        scale = 1\n        datasets = []\n        if tile_size and len(tile_size) &lt; 5:\n            if isinstance(tile_size, int):\n                tile_size = [tile_size] * 2\n            elif len(tile_size) == 1:\n                tile_size = tile_size * 2\n            tile_size = list(np.flip(tile_size))\n            while len(tile_size) &lt; 5:\n                tile_size = [1] + tile_size\n        for level in range(nlevels):\n            if len(shapes) &gt; 0:\n                shape = shapes[level]\n            else:\n                shape = scale_dimensions_xy(shape0, dimension_order, scale)\n            if len(chunk_shapes) &gt; 0:\n                chunk_shape = chunk_shapes[level]\n            else:\n                chunk_shape = np.min([tile_size, shape], axis=0)\n            if self.v3:\n                import zarrita\n                shape = np.array(shape).tolist()                # convert to basic int\n                chunk_shape = np.array(chunk_shape).tolist()    # convert to basic int\n                codecs = create_compression_codecs(compression)\n                dataset = self.zarr_root.create_array(str(level), shape=shape, chunk_shape=chunk_shape, dtype=dtype,\n                                                      codecs=codecs)\n            else:\n                chunk_shape = tile_size\n                compressor, compression_filters = create_compression_filter(compression)\n                dataset = self.zarr_root.create_dataset(str(level), shape=shape, chunks=chunk_shape, dtype=dtype,\n                                                        compressor=compressor, filters=compression_filters)\n            self.data.append(dataset)\n            # used for ome metadata:\n            datasets.append({\n                'path': str(level),\n                'coordinateTransformations': create_transformation_metadata(dimension_order, pixel_size_um, scale, translation_um)\n            })\n            scale /= pyramid_downsample\n\n        if self.ome:\n            multiscales = {\n                'version': ome_version,\n                'axes': create_axes_metadata(dimension_order),\n                'name': get_filetitle(source.source_reference),\n                'datasets': datasets,\n            }\n            metadata = {'multiscales': [multiscales], 'omero': create_channel_metadata(source, ome_version)}\n            if self.v3:\n                self.zarr_root.update_attributes(metadata)\n            else:\n                self.zarr_root.attrs = metadata\n\n    def get(self, level, **slicing):\n        slices = get_numpy_slicing(self.dimension_order, **slicing)\n        data = self.data[level][slices]\n        return data\n\n    def set(self, data, **slicing):\n        scale = 1\n        for level, sized_data in enumerate(self.scaler.nearest(data)):\n            resized_slicing = scale_dimensions_dict(slicing, scale)\n            slices = get_numpy_slicing(self.dimension_order, **resized_slicing)\n            self.data[level][slices] = np.asarray(sized_data)\n            scale /= self.pyramid_downsample\n\n    def set_level(self, level, data, **slicing):\n        resized_slicing = scale_dimensions_dict(slicing, 1 / self.level_scales[level])\n        slices = get_numpy_slicing(self.dimension_order, **resized_slicing)\n        self.data[level][slices] = np.asarray(data)\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.Zarr.data","title":"<code>data = []</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.Zarr.Zarr.filename","title":"<code>filename = filename</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.Zarr.Zarr.ome","title":"<code>ome = ome</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.Zarr.Zarr.v3","title":"<code>v3 = v3</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.Zarr.Zarr.__init__","title":"<code>__init__(filename, ome=None, v3=False)</code>","text":"Source code in <code>OmeSliCC\\Zarr.py</code> <pre><code>def __init__(self, filename, ome=None, v3=False):\n    self.filename = filename\n    if ome is not None:\n        self.ome = ome\n    else:\n        self.ome = ('ome' == self.filename.split('.')[1].lower())\n    self.v3 = v3\n    self.data = []\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.Zarr.create","title":"<code>create(source, shapes=[], chunk_shapes=[], level_scales=[], tile_size=None, npyramid_add=0, pyramid_downsample=2, compression=[])</code>","text":"Source code in <code>OmeSliCC\\Zarr.py</code> <pre><code>def create(self, source, shapes=[], chunk_shapes=[], level_scales=[],\n           tile_size=None, npyramid_add=0, pyramid_downsample=2, compression=[]):\n    # create empty dataset\n    dimension_order = source.get_dimension_order()\n    self.dimension_order = dimension_order\n    nlevels = max(1 + npyramid_add, len(shapes))\n    self.npyramid_add = npyramid_add\n    self.pyramid_downsample = pyramid_downsample\n    self.level_scales = level_scales\n    if self.v3:\n        import zarrita\n        store_path = zarrita.store.make_store_path(self.filename)\n        if os.path.exists(self.filename):\n            shutil.rmtree(self.filename)\n        self.zarr_root = zarrita.Group.create(store=store_path, exists_ok=True)\n        ome_version = '0.5-dev1'\n    else:\n        file_url = pathlib.Path(self.filename, mode='w').as_uri()\n        self.zarr_root = zarr.open_group(store=file_url, mode='w', storage_options={'dimension_separator': '/'})\n        ome_version = '0.4'\n    xyzct = source.get_size_xyzct()\n    self.scaler = Scaler(downscale=pyramid_downsample, max_layer=npyramid_add)\n    shape0 = [xyzct['xyzct'.index(dimension)] for dimension in dimension_order]\n    dtype = source.pixel_types[0]\n    pixel_size_um = source.get_pixel_size_micrometer()\n    translation_um = source.get_position_micrometer()\n    scale = 1\n    datasets = []\n    if tile_size and len(tile_size) &lt; 5:\n        if isinstance(tile_size, int):\n            tile_size = [tile_size] * 2\n        elif len(tile_size) == 1:\n            tile_size = tile_size * 2\n        tile_size = list(np.flip(tile_size))\n        while len(tile_size) &lt; 5:\n            tile_size = [1] + tile_size\n    for level in range(nlevels):\n        if len(shapes) &gt; 0:\n            shape = shapes[level]\n        else:\n            shape = scale_dimensions_xy(shape0, dimension_order, scale)\n        if len(chunk_shapes) &gt; 0:\n            chunk_shape = chunk_shapes[level]\n        else:\n            chunk_shape = np.min([tile_size, shape], axis=0)\n        if self.v3:\n            import zarrita\n            shape = np.array(shape).tolist()                # convert to basic int\n            chunk_shape = np.array(chunk_shape).tolist()    # convert to basic int\n            codecs = create_compression_codecs(compression)\n            dataset = self.zarr_root.create_array(str(level), shape=shape, chunk_shape=chunk_shape, dtype=dtype,\n                                                  codecs=codecs)\n        else:\n            chunk_shape = tile_size\n            compressor, compression_filters = create_compression_filter(compression)\n            dataset = self.zarr_root.create_dataset(str(level), shape=shape, chunks=chunk_shape, dtype=dtype,\n                                                    compressor=compressor, filters=compression_filters)\n        self.data.append(dataset)\n        # used for ome metadata:\n        datasets.append({\n            'path': str(level),\n            'coordinateTransformations': create_transformation_metadata(dimension_order, pixel_size_um, scale, translation_um)\n        })\n        scale /= pyramid_downsample\n\n    if self.ome:\n        multiscales = {\n            'version': ome_version,\n            'axes': create_axes_metadata(dimension_order),\n            'name': get_filetitle(source.source_reference),\n            'datasets': datasets,\n        }\n        metadata = {'multiscales': [multiscales], 'omero': create_channel_metadata(source, ome_version)}\n        if self.v3:\n            self.zarr_root.update_attributes(metadata)\n        else:\n            self.zarr_root.attrs = metadata\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.Zarr.get","title":"<code>get(level, **slicing)</code>","text":"Source code in <code>OmeSliCC\\Zarr.py</code> <pre><code>def get(self, level, **slicing):\n    slices = get_numpy_slicing(self.dimension_order, **slicing)\n    data = self.data[level][slices]\n    return data\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.Zarr.set","title":"<code>set(data, **slicing)</code>","text":"Source code in <code>OmeSliCC\\Zarr.py</code> <pre><code>def set(self, data, **slicing):\n    scale = 1\n    for level, sized_data in enumerate(self.scaler.nearest(data)):\n        resized_slicing = scale_dimensions_dict(slicing, scale)\n        slices = get_numpy_slicing(self.dimension_order, **resized_slicing)\n        self.data[level][slices] = np.asarray(sized_data)\n        scale /= self.pyramid_downsample\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.Zarr.set_level","title":"<code>set_level(level, data, **slicing)</code>","text":"Source code in <code>OmeSliCC\\Zarr.py</code> <pre><code>def set_level(self, level, data, **slicing):\n    resized_slicing = scale_dimensions_dict(slicing, 1 / self.level_scales[level])\n    slices = get_numpy_slicing(self.dimension_order, **resized_slicing)\n    self.data[level][slices] = np.asarray(data)\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.blur_image","title":"<code>blur_image(image, sigma)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def blur_image(image, sigma):\n    nchannels = image.shape[2] if image.ndim == 3 else 1\n    if nchannels not in [1, 3]:\n        new_image = np.zeros_like(image)\n        for channeli in range(nchannels):\n            new_image[..., channeli] = blur_image_single(image[..., channeli], sigma)\n    else:\n        new_image = blur_image_single(image, sigma)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.blur_image_single","title":"<code>blur_image_single(image, sigma)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def blur_image_single(image, sigma):\n    return gaussian_filter(image, sigma)\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.calc_fraction_used","title":"<code>calc_fraction_used(image, threshold=0.1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_fraction_used(image: np.ndarray, threshold: float = 0.1) -&gt; float:\n    low = int(round(threshold * 255))\n    high = int(round((1 - threshold) * 255))\n    shape = image.shape\n    total = shape[0] * shape[1]\n    good = 0\n    for y in range(shape[0]):\n        for x in range(shape[1]):\n            pixel = image[y, x]\n            if low &lt;= pixel[0] &lt; high and low &lt;= pixel[1] &lt; high and low &lt;= pixel[2] &lt; high:\n                good += 1\n    fraction = good / total\n    return fraction\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.calc_pyramid","title":"<code>calc_pyramid(xyzct, npyramid_add=0, pyramid_downsample=2, volumetric_resize=False)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_pyramid(xyzct: tuple, npyramid_add: int = 0, pyramid_downsample: float = 2,\n                 volumetric_resize: bool = False) -&gt; list:\n    x, y, z, c, t = xyzct\n    if volumetric_resize and z &gt; 1:\n        size = (x, y, z)\n    else:\n        size = (x, y)\n    sizes_add = []\n    scale = 1\n    for _ in range(npyramid_add):\n        scale /= pyramid_downsample\n        scaled_size = np.maximum(np.round(np.multiply(size, scale)).astype(int), 1)\n        sizes_add.append(scaled_size)\n    return sizes_add\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.calc_tiles_median","title":"<code>calc_tiles_median(images)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_tiles_median(images):\n    out_image = np.zeros_like(images[0])\n    median_image = np.median(images, 0, out_image)\n    return median_image\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.calc_tiles_quantiles","title":"<code>calc_tiles_quantiles(images, quantiles)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_tiles_quantiles(images, quantiles):\n    out_quantiles = []\n    quantile_images = np.quantile(images, quantiles, 0)\n    for quantile_image in quantile_images:\n        maxval = 2 ** (8 * images[0].dtype.itemsize) - 1\n        image = (quantile_image / maxval).astype(np.float32)\n        out_quantiles.append(image)\n    return out_quantiles\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.check_round_significants","title":"<code>check_round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def check_round_significants(a: float, significant_digits: int) -&gt; float:\n    rounded = round_significants(a, significant_digits)\n    if a != 0:\n        dif = 1 - rounded / a\n    else:\n        dif = rounded - a\n    if abs(dif) &lt; 10 ** -significant_digits:\n        return rounded\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.check_versions","title":"<code>check_versions()</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def check_versions():\n    print(f'tifffile {tifffile.__version__}')\n    print(imagecodecs.version())\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.compare_image","title":"<code>compare_image(image0, image1, show=False)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image(image0, image1, show=False) -&gt; float:\n    dif, dif_max, dif_mean, psnr = compare_image_dist(image0, image1)\n    print(f'rgb dist max: {dif_max:.1f} mean: {dif_mean:.1f} PSNR: {psnr:.1f}')\n    if show:\n        show_image(dif)\n        show_image((dif * 10).astype(np.uint8))\n    return dif\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.compare_image_dist","title":"<code>compare_image_dist(image0, image1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image_dist(image0: np.ndarray, image1: np.ndarray) -&gt; tuple:\n    dif = cv.absdiff(image0, image1)\n    psnr = cv.PSNR(image0, image1)\n    if dif.size &gt; 1000000000:\n        # split very large array\n        rgb_maxs = []\n        rgb_means = []\n        for dif1 in np.array_split(dif, 16):\n            rgb_dif = np.linalg.norm(dif1, axis=2)\n            rgb_maxs.append(np.max(rgb_dif))\n            rgb_means.append(np.mean(rgb_dif))\n        rgb_max = np.max(rgb_maxs)\n        rgb_mean = np.mean(rgb_means)\n    else:\n        rgb_dif = np.linalg.norm(dif, axis=2)\n        rgb_max = np.max(rgb_dif)\n        rgb_mean = np.mean(rgb_dif)\n    return dif, rgb_max, rgb_mean, psnr\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.compare_image_dist_simple","title":"<code>compare_image_dist_simple(image0, image1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image_dist_simple(image0: np.ndarray, image1: np.ndarray) -&gt; dict:\n    dif = cv.absdiff(image0, image1)\n    psnr = cv.PSNR(image0, image1)\n    rgb_dif = np.linalg.norm(dif, axis=2)\n    dif_max = np.max(rgb_dif)\n    dif_mean = np.mean(rgb_dif)\n    return {'dif_max': dif_max, 'dif_mean': dif_mean, 'psnr': psnr}\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.convert_image_sign_type","title":"<code>convert_image_sign_type(image, target_dtype)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def convert_image_sign_type(image: np.ndarray, target_dtype: np.dtype) -&gt; np.ndarray:\n    source_dtype = image.dtype\n    if source_dtype.kind == target_dtype.kind:\n        new_image = image\n    elif source_dtype.kind == 'i':\n        new_image = ensure_unsigned_image(image)\n    else:\n        # conversion without overhead\n        offset = 2 ** (8 * target_dtype.itemsize - 1)\n        new_image = (image - offset).astype(target_dtype)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.convert_rational_value","title":"<code>convert_rational_value(value)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def convert_rational_value(value) -&gt; float:\n    if value is not None and isinstance(value, tuple):\n        value = value[0] / value[1]\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.create_axes_metadata","title":"<code>create_axes_metadata(dimension_order)</code>","text":"Source code in <code>OmeSliCC\\ome_zarr_util.py</code> <pre><code>def create_axes_metadata(dimension_order):\n    axes = []\n    for dimension in dimension_order:\n        unit1 = None\n        if dimension == 't':\n            type1 = 'time'\n            unit1 = 'millisecond'\n        elif dimension == 'c':\n            type1 = 'channel'\n        else:\n            type1 = 'space'\n            unit1 = 'micrometer'\n        axis = {'name': dimension, 'type': type1}\n        if unit1 is not None and unit1 != '':\n            axis['unit'] = unit1\n        axes.append(axis)\n    return axes\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.create_channel_metadata","title":"<code>create_channel_metadata(source, ome_version)</code>","text":"Source code in <code>OmeSliCC\\ome_zarr_util.py</code> <pre><code>def create_channel_metadata(source, ome_version):\n    channels = source.get_channels()\n    nchannels = source.get_nchannels()\n\n    if len(channels) &lt; nchannels == 3:\n        labels = ['Red', 'Green', 'Blue']\n        colors = [(1, 0, 0, 1), (0, 1, 0, 1), (0, 0, 1, 1)]\n        channels = [{'label': label, 'color': color} for label, color in zip(labels, colors)]\n\n    omezarr_channels = []\n    for channeli, channel0 in enumerate(channels):\n        channel = channel0.copy()\n        color = channel.get('color', (1, 1, 1, 1))\n        channel['color'] = rgba_to_hexrgb(color)\n        if 'window' not in channel:\n            channel['window'] = source.get_channel_window(channeli)\n        omezarr_channels.append(channel)\n\n    metadata = {\n        'version': ome_version,\n        'channels': omezarr_channels,\n    }\n    return metadata\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.create_compression_codecs","title":"<code>create_compression_codecs(compression)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def create_compression_codecs(compression: list) -&gt; list:\n    codecs = None\n    compression = ensure_list(compression)\n    if compression is not None and len(compression) &gt; 0:\n        compression_type = compression[0].lower()\n        if len(compression) &gt; 1:\n            level = int(compression[1])\n        else:\n            level = None\n        if 'lzw' in compression_type:\n            from imagecodecs.numcodecs import Lzw\n            codecs = [Lzw()]\n        elif '2k' in compression_type or '2000' in compression_type:\n            from imagecodecs.numcodecs import Jpeg2k\n            codecs = [Jpeg2k(level=level)]\n        elif 'jpegls' in compression_type:\n            from imagecodecs.numcodecs import Jpegls\n            codecs = [Jpegls(level=level)]\n        elif 'jpegxr' in compression_type:\n            from imagecodecs.numcodecs import Jpegxr\n            codecs = [Jpegxr(level=level)]\n        elif 'jpegxl' in compression_type:\n            from imagecodecs.numcodecs import Jpegxl\n            codecs = [Jpegxl(level=level)]\n        else:\n            codecs = [compression]\n    return codecs\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.create_compression_filter","title":"<code>create_compression_filter(compression)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def create_compression_filter(compression: list) -&gt; tuple:\n    compressor, compression_filters = None, None\n    compression = ensure_list(compression)\n    if compression is not None and len(compression) &gt; 0:\n        compression_type = compression[0].lower()\n        if len(compression) &gt; 1:\n            level = int(compression[1])\n        else:\n            level = None\n        if 'lzw' in compression_type:\n            from imagecodecs.numcodecs import Lzw\n            compression_filters = [Lzw()]\n        elif '2k' in compression_type or '2000' in compression_type:\n            from imagecodecs.numcodecs import Jpeg2k\n            compression_filters = [Jpeg2k(level=level)]\n        elif 'jpegls' in compression_type:\n            from imagecodecs.numcodecs import Jpegls\n            compression_filters = [Jpegls(level=level)]\n        elif 'jpegxr' in compression_type:\n            from imagecodecs.numcodecs import Jpegxr\n            compression_filters = [Jpegxr(level=level)]\n        elif 'jpegxl' in compression_type:\n            from imagecodecs.numcodecs import Jpegxl\n            compression_filters = [Jpegxl(level=level)]\n        else:\n            compressor = compression\n    return compressor, compression_filters\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.create_transformation_metadata","title":"<code>create_transformation_metadata(dimension_order, pixel_size_um, scale, translation_um=[])</code>","text":"Source code in <code>OmeSliCC\\ome_zarr_util.py</code> <pre><code>def create_transformation_metadata(dimension_order, pixel_size_um, scale, translation_um=[]):\n    metadata = []\n    pixel_size_scale = []\n    translation_scale = []\n    for dimension in dimension_order:\n        if dimension == 'z' and len(pixel_size_um) &gt; 2:\n            pixel_size_scale1 = pixel_size_um[2]\n        elif dimension == 'y' and len(pixel_size_um) &gt; 1:\n            pixel_size_scale1 = pixel_size_um[1] / scale\n        elif dimension == 'x' and len(pixel_size_um) &gt; 0:\n            pixel_size_scale1 = pixel_size_um[0] / scale\n        else:\n            pixel_size_scale1 = 1\n        if pixel_size_scale1 == 0:\n            pixel_size_scale1 = 1\n        pixel_size_scale.append(pixel_size_scale1)\n\n        if dimension == 'z' and len(translation_um) &gt; 2:\n            translation1 = translation_um[2]\n        elif dimension == 'y' and len(translation_um) &gt; 1:\n            translation1 = translation_um[1] * scale\n        elif dimension == 'x' and len(translation_um) &gt; 0:\n            translation1 = translation_um[0] * scale\n        else:\n            translation1 = 0\n        translation_scale.append(translation1)\n\n    metadata.append({'type': 'scale', 'scale': pixel_size_scale})\n    if not all(v == 0 for v in translation_scale):\n        metadata.append({'type': 'translation', 'translation': translation_scale})\n    return metadata\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.desc_to_dict","title":"<code>desc_to_dict(desc)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def desc_to_dict(desc: str) -&gt; dict:\n    desc_dict = {}\n    if desc.startswith('{'):\n        try:\n            metadata = ast.literal_eval(desc)\n            return metadata\n        except:\n            pass\n    for item in re.split(r'[\\r\\n\\t|]', desc):\n        item_sep = '='\n        if ':' in item:\n            item_sep = ':'\n        if item_sep in item:\n            items = item.split(item_sep)\n            key = items[0].strip()\n            value = items[1].strip()\n            for dtype in (int, float, bool):\n                try:\n                    value = dtype(value)\n                    break\n                except:\n                    pass\n            desc_dict[key] = value\n    return desc_dict\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.ensure_list","title":"<code>ensure_list(x)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def ensure_list(x) -&gt; list:\n    if x is None:\n        return []\n    elif isinstance(x, list):\n        return x\n    else:\n        return [x]\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.ensure_unsigned_image","title":"<code>ensure_unsigned_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def ensure_unsigned_image(image: np.ndarray) -&gt; np.ndarray:\n    source_dtype = image.dtype\n    dtype = ensure_unsigned_type(source_dtype)\n    if dtype != source_dtype:\n        # conversion without overhead\n        offset = 2 ** (8 * dtype.itemsize - 1)\n        new_image = image.astype(dtype) + offset\n    else:\n        new_image = image\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.ensure_unsigned_type","title":"<code>ensure_unsigned_type(dtype)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def ensure_unsigned_type(dtype: np.dtype) -&gt; np.dtype:\n    new_dtype = dtype\n    if dtype.kind == 'i' or dtype.byteorder == '&gt;' or dtype.byteorder == '&lt;':\n        new_dtype = np.dtype(f'u{dtype.itemsize}')\n    return new_dtype\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.file_to_dict","title":"<code>file_to_dict(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def file_to_dict(filename: str) -&gt; dict:\n    ext = os.path.splitext(filename)[1]\n    content = open(filename, 'r').read()\n    if ext == '.xml':\n        data = xmltodict.parse(content)\n    elif ext in ['.yml', '.yaml']:\n        data = yaml.safe_load(content)\n    else:   # assume json\n        data = json.loads(content)\n    return data\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.filter_dict","title":"<code>filter_dict(dict0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def filter_dict(dict0: dict) -&gt; dict:\n    new_dict = {}\n    for key, value0 in dict0.items():\n        if value0 is not None:\n            values = []\n            for value in ensure_list(value0):\n                if isinstance(value, dict):\n                    value = filter_dict(value)\n                values.append(value)\n            if len(values) == 1:\n                values = values[0]\n            new_dict[key] = values\n    return new_dict\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.float2int_image","title":"<code>float2int_image(image, target_dtype=np.dtype(np.uint8))</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def float2int_image(image, target_dtype=np.dtype(np.uint8)):\n    source_dtype = image.dtype\n    if source_dtype.kind not in ('i', 'u') and not target_dtype.kind == 'f':\n        maxval = 2 ** (8 * target_dtype.itemsize) - 1\n        return (image * maxval).astype(target_dtype)\n    else:\n        return image\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.get_default","title":"<code>get_default(x, default)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_default(x, default):\n    return default if x is None else x\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.get_filetitle","title":"<code>get_filetitle(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_filetitle(filename: str) -&gt; str:\n    filebase = os.path.basename(filename)\n    title = os.path.splitext(filebase)[0].rstrip('.ome')\n    return title\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.get_image_quantile","title":"<code>get_image_quantile(image, quantile, axis=None)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_image_quantile(image: np.ndarray, quantile: float, axis=None) -&gt; float:\n    value = np.quantile(image, quantile, axis=axis).astype(image.dtype)\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.get_image_size_info","title":"<code>get_image_size_info(sizes_xyzct, pixel_nbytes, pixel_type, channels)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_image_size_info(sizes_xyzct: list, pixel_nbytes: int, pixel_type: np.dtype, channels: list) -&gt; str:\n    image_size_info = 'XYZCT:'\n    size = 0\n    for i, size_xyzct in enumerate(sizes_xyzct):\n        w, h, zs, cs, ts = size_xyzct\n        size += np.int64(pixel_nbytes) * w * h * zs * cs * ts\n        if i &gt; 0:\n            image_size_info += ','\n        image_size_info += f' {w} {h} {zs} {cs} {ts}'\n    image_size_info += f' Pixel type: {pixel_type} Uncompressed: {print_hbytes(size)}'\n    if sizes_xyzct[0][3] == 3:\n        channel_info = 'rgb'\n    else:\n        channel_info = ','.join([channel.get('Name', '') for channel in channels])\n    if channel_info != '':\n        image_size_info += f' Channels: {channel_info}'\n    return image_size_info\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.get_numpy_slicing","title":"<code>get_numpy_slicing(dimension_order, **slicing)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_numpy_slicing(dimension_order, **slicing):\n    slices = []\n    for axis in dimension_order:\n        index = slicing.get(axis)\n        index0 = slicing.get(axis + '0')\n        index1 = slicing.get(axis + '1')\n        if index0 is not None and index1 is not None:\n            slice1 = slice(int(index0), int(index1))\n        elif index is not None:\n            slice1 = int(index)\n        else:\n            slice1 = slice(None)\n        slices.append(slice1)\n    return tuple(slices)\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.get_pil_metadata","title":"<code>get_pil_metadata(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_pil_metadata(image: PIL.Image) -&gt; dict:\n    metadata = {}\n    exifdata = image.getexif()\n    for tag_id in exifdata:\n        tag = TAGS.get(tag_id, tag_id)\n        data = exifdata.get(tag_id)\n        if isinstance(data, bytes):\n            data = data.decode()\n        metadata[tag] = data\n    if metadata == {}:\n        metadata = image.info\n    return metadata\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.get_tiff_pages","title":"<code>get_tiff_pages(tiff)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_tiff_pages(tiff: TiffFile) -&gt; list:\n    # TODO: review so this works for multi-level ome-tiff, tiff-stack, and z pages tiff, then later check for mmstack\n    pages = []\n    found = False\n    if tiff.series and not tiff.is_mmstack:\n        # has series\n        baseline = tiff.series[0]\n        for level in baseline.levels:\n            # has levels\n            level_pages = []\n            for page in level.pages:\n                found = True\n                level_pages.append(page)\n            if level_pages:\n                pages.append(level_pages)\n\n    if not found:\n        for page in tiff.pages:\n            pages.append(page)\n    return pages\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.get_value_units_micrometer","title":"<code>get_value_units_micrometer(value_units0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_value_units_micrometer(value_units0: list) -&gt; list:\n    conversions = {'nm': 1e-3, '\u00b5m': 1, 'um': 1, 'micrometer': 1, 'mm': 1e3, 'cm': 1e4, 'm': 1e6}\n    if value_units0 is None:\n        return None\n\n    values_um = []\n    for value_unit in value_units0:\n        if not (isinstance(value_unit, int) or isinstance(value_unit, float)):\n            value_um = value_unit[0] * conversions.get(value_unit[1], 1)\n        else:\n            value_um = value_unit\n        values_um.append(value_um)\n    return values_um\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.hexrgb_to_rgba","title":"<code>hexrgb_to_rgba(hexrgb)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def hexrgb_to_rgba(hexrgb: str) -&gt; list:\n    rgba = int_to_rgba(eval('0x' + hexrgb + 'FF'))\n    return rgba\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.image_reshape","title":"<code>image_reshape(image, target_size)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def image_reshape(image: np.ndarray, target_size: tuple) -&gt; np.ndarray:\n    tw, th = target_size\n    sh, sw = image.shape[0:2]\n    if sw &lt; tw or sh &lt; th:\n        dw = max(tw - sw, 0)\n        dh = max(th - sh, 0)\n        padding = [(0, dh), (0, dw)]\n        if len(image.shape) == 3:\n            padding += [(0, 0)]\n        image = np.pad(image, padding, 'edge')\n    if tw &lt; sw or th &lt; sh:\n        image = image[0:th, 0:tw]\n    return image\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.image_resize","title":"<code>image_resize(image, target_size0, dimension_order='yxc')</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def image_resize(image: np.ndarray, target_size0: tuple, dimension_order: str = 'yxc') -&gt; np.ndarray:\n    shape = image.shape\n    x_index = dimension_order.index('x')\n    y_index = dimension_order.index('y')\n    c_is_at_end = ('c' in dimension_order and dimension_order.endswith('c'))\n    size = shape[x_index], shape[y_index]\n    if np.mean(np.divide(size, target_size0)) &lt; 1:\n        interpolation = cv.INTER_CUBIC\n    else:\n        interpolation = cv.INTER_AREA\n    dtype0 = image.dtype\n    image = ensure_unsigned_image(image)\n    target_size = tuple(np.maximum(np.round(target_size0).astype(int), 1))\n    if dimension_order in ['yxc', 'yx']:\n        new_image = cv.resize(np.asarray(image), target_size, interpolation=interpolation)\n    elif dimension_order == 'cyx':\n        new_image = np.moveaxis(image, 0, -1)\n        new_image = cv.resize(np.asarray(new_image), target_size, interpolation=interpolation)\n        new_image = np.moveaxis(new_image, -1, 0)\n    else:\n        ts = image.shape[dimension_order.index('t')] if 't' in dimension_order else 1\n        zs = image.shape[dimension_order.index('z')] if 'z' in dimension_order else 1\n        target_shape = list(image.shape).copy()\n        target_shape[x_index] = target_size[0]\n        target_shape[y_index] = target_size[1]\n        new_image = np.zeros(target_shape, dtype=image.dtype)\n        for t in range(ts):\n            for z in range(zs):\n                slices = get_numpy_slicing(dimension_order, z=z, t=t)\n                image1 = image[slices]\n                if not c_is_at_end:\n                    image1 = np.moveaxis(image1, 0, -1)\n                new_image1 = np.atleast_3d(cv.resize(np.asarray(image1), target_size, interpolation=interpolation))\n                if not c_is_at_end:\n                    new_image1 = np.moveaxis(new_image1, -1, 0)\n                new_image[slices] = new_image1\n    new_image = convert_image_sign_type(new_image, dtype0)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.int2float_image","title":"<code>int2float_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def int2float_image(image):\n    source_dtype = image.dtype\n    if not source_dtype.kind == 'f':\n        maxval = 2 ** (8 * source_dtype.itemsize) - 1\n        return image / np.float32(maxval)\n    else:\n        return image\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.int_to_rgba","title":"<code>int_to_rgba(intrgba)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def int_to_rgba(intrgba: int) -&gt; list:\n    signed = (intrgba &lt; 0)\n    rgba = [x / 255 for x in intrgba.to_bytes(4, signed=signed, byteorder=\"big\")]\n    if rgba[-1] == 0:\n        rgba[-1] = 1\n    return rgba\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.normalise_values","title":"<code>normalise_values(image, min_value, max_value)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def normalise_values(image: np.ndarray, min_value: float, max_value: float) -&gt; np.ndarray:\n    return np.clip((image.astype(np.float32) - min_value) / (max_value - min_value), 0, 1)\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.pilmode_to_pixelinfo","title":"<code>pilmode_to_pixelinfo(mode)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def pilmode_to_pixelinfo(mode: str) -&gt; tuple:\n    pixelinfo = (np.uint8, 8, 1)\n    mode_types = {\n        'I': (np.uint32, 32, 1),\n        'F': (np.float32, 32, 1),\n        'RGB': (np.uint8, 24, 3),\n        'RGBA': (np.uint8, 32, 4),\n        'CMYK': (np.uint8, 32, 4),\n        'YCbCr': (np.uint8, 24, 3),\n        'LAB': (np.uint8, 24, 3),\n        'HSV': (np.uint8, 24, 3),\n    }\n    if '16' in mode:\n        pixelinfo = (np.uint16, 16, 1)\n    elif '32' in mode:\n        pixelinfo = (np.uint32, 32, 1)\n    elif mode in mode_types:\n        pixelinfo = mode_types[mode]\n    pixelinfo = (np.dtype(pixelinfo[0]), pixelinfo[1])\n    return pixelinfo\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.precise_resize","title":"<code>precise_resize(image, factors)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def precise_resize(image: np.ndarray, factors) -&gt; np.ndarray:\n    if image.ndim &gt; len(factors):\n        factors = list(factors) + [1]\n    new_image = downscale_local_mean(np.asarray(image), tuple(factors)).astype(image.dtype)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.print_dict","title":"<code>print_dict(dct, indent=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_dict(dct: dict, indent: int = 0) -&gt; str:\n    s = ''\n    if isinstance(dct, dict):\n        for key, value in dct.items():\n            s += '\\n'\n            if not isinstance(value, list):\n                s += '\\t' * indent + str(key) + ': '\n            if isinstance(value, dict):\n                s += print_dict(value, indent=indent + 1)\n            elif isinstance(value, list):\n                for v in value:\n                    s += print_dict(v)\n            else:\n                s += str(value)\n    else:\n        s += str(dct)\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.print_hbytes","title":"<code>print_hbytes(nbytes)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_hbytes(nbytes: int) -&gt; str:\n    exps = ['', 'K', 'M', 'G', 'T']\n    div = 1024\n    exp = 0\n\n    while nbytes &gt; div:\n        nbytes /= div\n        exp += 1\n    return f'{nbytes:.1f}{exps[exp]}B'\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.redimension_data","title":"<code>redimension_data(data, old_order, new_order, **indices)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def redimension_data(data, old_order, new_order, **indices):\n    # able to provide optional dimension values e.g. t=0, z=0\n    if new_order == old_order:\n        return data\n\n    new_data = data\n    order = old_order\n    # remove\n    for o in old_order:\n        if o not in new_order:\n            index = order.index(o)\n            dim_value = indices.get(o, 0)\n            new_data = np.take(new_data, indices=dim_value, axis=index)\n            order = order[:index] + order[index + 1:]\n    # add\n    for o in new_order:\n        if o not in order:\n            new_data = np.expand_dims(new_data, 0)\n            order = o + order\n    # move\n    old_indices = [order.index(o) for o in new_order]\n    new_indices = list(range(len(new_order)))\n    new_data = np.moveaxis(new_data, old_indices, new_indices)\n    return new_data\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.reorder","title":"<code>reorder(items, old_order, new_order, default_value=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def reorder(items: list, old_order: str, new_order: str, default_value: int = 0) -&gt; list:\n    new_items = []\n    for label in new_order:\n        if label in old_order:\n            item = items[old_order.index(label)]\n        else:\n            item = default_value\n        new_items.append(item)\n    return new_items\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.rgba_to_hexrgb","title":"<code>rgba_to_hexrgb(rgba)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def rgba_to_hexrgb(rgba: list) -&gt; str:\n    hexrgb = ''.join([hex(int(x * 255))[2:].upper().zfill(2) for x in rgba[:3]])\n    return hexrgb\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.rgba_to_int","title":"<code>rgba_to_int(rgba)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def rgba_to_int(rgba: list) -&gt; int:\n    intrgba = int.from_bytes([int(x * 255) for x in rgba], signed=True, byteorder=\"big\")\n    return intrgba\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.round_significants","title":"<code>round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def round_significants(a: float, significant_digits: int) -&gt; float:\n    if a != 0:\n        round_decimals = significant_digits - int(np.floor(np.log10(abs(a)))) - 1\n        return round(a, round_decimals)\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.save_image","title":"<code>save_image(image, filename, output_params={})</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def save_image(image: np.ndarray, filename: str, output_params: dict = {}):\n    compression = output_params.get('compression')\n    PIL.Image.fromarray(image).save(filename, compression=compression)\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.scale_dimensions_dict","title":"<code>scale_dimensions_dict(shape0, scale)</code>","text":"Source code in <code>OmeSliCC\\ome_zarr_util.py</code> <pre><code>def scale_dimensions_dict(shape0, scale):\n    shape = {}\n    if scale == 1:\n        return shape0\n    for dimension, shape1 in shape0.items():\n        if dimension[0] in ['x', 'y']:\n            shape1 = int(shape1 * scale)\n        shape[dimension] = shape1\n    return shape\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.scale_dimensions_xy","title":"<code>scale_dimensions_xy(shape0, dimension_order, scale)</code>","text":"Source code in <code>OmeSliCC\\ome_zarr_util.py</code> <pre><code>def scale_dimensions_xy(shape0, dimension_order, scale):\n    shape = []\n    if scale == 1:\n        return shape0\n    for shape1, dimension in zip(shape0, dimension_order):\n        if dimension[0] in ['x', 'y']:\n            shape1 = int(shape1 * scale)\n        shape.append(shape1)\n    return shape\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.show_image","title":"<code>show_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def show_image(image: np.ndarray):\n    plt.imshow(image)\n    plt.show()\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.show_image_gray","title":"<code>show_image_gray(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def show_image_gray(image: np.ndarray):\n    plt.imshow(image, cmap='gray')\n    plt.show()\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.split_num_text","title":"<code>split_num_text(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_num_text(text: str) -&gt; list:\n    num_texts = []\n    block = ''\n    is_num0 = None\n    if text is None:\n        return None\n\n    for c in text:\n        is_num = (c.isnumeric() or c == '.')\n        if is_num0 is not None and is_num != is_num0:\n            num_texts.append(block)\n            block = ''\n        block += c\n        is_num0 = is_num\n    if block != '':\n        num_texts.append(block)\n\n    num_texts2 = []\n    for block in num_texts:\n        block = block.strip()\n        try:\n            block = float(block)\n        except:\n            pass\n        if block not in [' ', ',', '|']:\n            num_texts2.append(block)\n    return num_texts2\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.split_value_unit_list","title":"<code>split_value_unit_list(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_value_unit_list(text: str) -&gt; list:\n    value_units = []\n    if text is None:\n        return None\n\n    items = split_num_text(text)\n    if isinstance(items[-1], str):\n        def_unit = items[-1]\n    else:\n        def_unit = ''\n\n    i = 0\n    while i &lt; len(items):\n        value = items[i]\n        if i + 1 &lt; len(items):\n            unit = items[i + 1]\n        else:\n            unit = ''\n        if not isinstance(value, str):\n            if isinstance(unit, str):\n                i += 1\n            else:\n                unit = def_unit\n            value_units.append((value, unit))\n        i += 1\n    return value_units\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.tags_to_dict","title":"<code>tags_to_dict(tags)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tags_to_dict(tags: tifffile.TiffTags) -&gt; dict:\n    tag_dict = {}\n    for tag in tags.values():\n        tag_dict[tag.name] = tag.value\n    return tag_dict\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.tiff_info","title":"<code>tiff_info(filename)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tiff_info(filename: str) -&gt; str:\n    s = ''\n    nom_size = 0\n    tiff = TiffFile(filename)\n    real_size = tiff.fstat.st_size\n    s += str(tiff) + '\\n'\n    if tiff.ome_metadata:\n        print(tiff.ome_metadata)\n        s += f'OME: {print_dict(tifffile.xml2dict(tiff.ome_metadata))}\\n'\n    if tiff.metaseries_metadata:\n        s += f'Series: {tiff.metaseries_metadata}\\n'\n    if tiff.imagej_metadata:\n        s += f'ImageJ: {tiff.imagej_metadata}\\n'\n\n    for page0 in get_tiff_pages(tiff):\n        page = page0[0] if isinstance(page0, list) else page0\n        s += str(page) + '\\n'\n        s += f'Size: {np.flip(page.shape)} ({print_hbytes(page.size)})\\n'\n        if page.is_tiled:\n            s += f'Tiling: {page.tilewidth} {page.tilelength} {page.tiledepth}\\n'\n        s += f'Compression: {str(page.compression)} jpegtables: {page.jpegtables is not None}\\n'\n        tag_dict = tags_to_dict(page.tags)\n        if 'TileOffsets' in tag_dict:\n            tag_dict.pop('TileOffsets')\n        if 'TileByteCounts' in tag_dict:\n            tag_dict.pop('TileByteCounts')\n        if 'ImageDescription' in tag_dict and tag_dict['ImageDescription'].startswith('&lt;?xml'):\n            # redundant\n            tag_dict.pop('ImageDescription')\n        s += print_dict(tag_dict) + '\\n\\n'\n        nom_size += page.size\n\n    s += f'Overall compression: 1:{nom_size / real_size:.1f}'\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.Zarr.tiff_info_short","title":"<code>tiff_info_short(filename)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tiff_info_short(filename: str) -&gt; str:\n    nom_size = 0\n    tiff = TiffFile(filename)\n    s = str(filename)\n    real_size = tiff.fstat.st_size\n    for page in tiff.pages:\n        s += ' ' + str(page)\n        nom_size += page.size\n    s += f' Image size:{nom_size} File size:{real_size} Overall compression: 1:{nom_size / real_size:.1f}'\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.ZarrSource","title":"<code>ZarrSource</code>","text":""},{"location":"references/#OmeSliCC.ZarrSource.ZarrSource","title":"<code>ZarrSource</code>","text":"<p>               Bases: <code>OmeSource</code></p> <p>Zarr-compatible image source</p> Source code in <code>OmeSliCC\\ZarrSource.py</code> <pre><code>class ZarrSource(OmeSource):\n    \"\"\"Zarr-compatible image source\"\"\"\n\n    filename: str\n    \"\"\"original filename / URL\"\"\"\n    levels: list\n    \"\"\"list of all image arrays for different sizes\"\"\"\n\n    def __init__(self, filename: str,\n                 source_pixel_size: list = None,\n                 target_pixel_size: list = None,\n                 source_info_required: bool = False):\n\n        super().__init__()\n\n        try:\n            if filename.startswith((\"http\", \"s3\")):\n                cls = RemoteStore\n            else:\n                cls = LocalStore\n            store_path = cls(filename)\n            root = zarr.open_group(store=store_path)\n            self.metadata = root.attrs.asdict()\n\n            paths = []\n            dimension_order = 'tczyx'\n            if 'multiscales' in self.metadata:\n                for scale in self.metadata.get('multiscales', []):\n                    for index, dataset in enumerate(scale.get('datasets', [])):\n                        paths.append(dataset.get('path', str(index)))\n                    axes = scale.get('axes', [])\n                    if len(axes) &gt; 0:\n                        dimension_order = ''.join([axis.get('name') for axis in axes])\n            else:\n                paths = root.array_keys()\n            self.dimension_order = dimension_order\n\n            self.levels = []\n            for path in paths:\n                data = root.get(path)\n                self.levels.append(data)\n\n                xyzct = [1, 1, 1, 1, 1]\n                for i, n in enumerate(data.shape):\n                    xyzct_index = 'xyzct'.index(dimension_order[i])\n                    xyzct[xyzct_index] = n\n                self.sizes_xyzct.append(xyzct)\n                self.sizes.append((xyzct[0], xyzct[1]))\n                self.pixel_types.append(data.dtype)\n                self.pixel_nbits.append(data.dtype.itemsize * 8)\n        except Exception as e:\n            raise FileNotFoundError(f'Read error: {e}')\n\n        self._init_metadata(filename,\n                            source_pixel_size=source_pixel_size,\n                            target_pixel_size=target_pixel_size,\n                            source_info_required=source_info_required)\n\n    def _find_metadata(self):\n        pixel_size = []\n        channels = []\n        for scale in self.metadata.get('multiscales', []):\n            axes = ''.join([axis.get('name', '') for axis in scale.get('axes', [])])\n            units = [axis.get('unit', '') for axis in scale.get('axes', [])]\n            scale1 = [0, 0, 0, 0, 0]\n            datasets = scale.get('datasets')\n            if datasets is not None:\n                coordinateTransformations = datasets[0].get('coordinateTransformations')\n                if coordinateTransformations is not None:\n                    scale1 = coordinateTransformations[0].get('scale', scale1)\n            if 'z' in axes:\n                pixel_size = [\n                    (scale1[axes.index('x')], units[axes.index('x')]),\n                    (scale1[axes.index('y')], units[axes.index('y')]),\n                    (scale1[axes.index('z')], units[axes.index('z')])]\n            else:\n                pixel_size = [(0, ''), (0, ''), (0, '')]\n        nchannels = self.sizes_xyzct[0][3]\n        for data in self.metadata.values():\n            if isinstance(data, dict):\n                n = len(data.get('channels', []))\n                for channel0 in data.get('channels', []):\n                    channel = XmlDict({'@Name': channel0.get('label'), '@SamplesPerPixel': nchannels // n})\n                    if 'color' in channel0:\n                        channel['@Color'] = channel0['color']\n                    channels.append(channel)\n        if len(channels) == 0:\n            if nchannels == 3:\n                channels = [XmlDict({'@Name': '', '@SamplesPerPixel': nchannels})]\n            else:\n                channels = [XmlDict({'@Name': '', '@SamplesPerPixel': 1})] * nchannels\n        self.source_pixel_size = pixel_size\n        self.channels = channels\n        self.source_mag = 0\n\n    def _asarray_level(self, level: int, x0: float = 0, y0: float = 0, x1: float = -1, y1: float = -1) -&gt; np.ndarray:\n        size_xyzct = self.sizes_xyzct[level]\n        if x1 &lt; 0 or y1 &lt; 0:\n            x1, y1, _, _, _ = size_xyzct\n        if self.dimension_order.endswith('yx'):\n            image = self.levels[level][..., y0:y1, x0:x1].squeeze()\n            if len(image.shape) &gt; 2:\n                image = np.moveaxis(image, 0, -1)  # move axis 0 (channel/z) to end\n        else:\n            image = self.levels[level][y0:y1, x0:x1].squeeze()\n        return image\n</code></pre>"},{"location":"references/#OmeSliCC.ZarrSource.ZarrSource.dimension_order","title":"<code>dimension_order = dimension_order</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.ZarrSource.ZarrSource.filename","title":"<code>filename</code>  <code>instance-attribute</code>","text":"<p>original filename / URL</p>"},{"location":"references/#OmeSliCC.ZarrSource.ZarrSource.levels","title":"<code>levels = []</code>  <code>instance-attribute</code>","text":"<p>list of all image arrays for different sizes</p>"},{"location":"references/#OmeSliCC.ZarrSource.ZarrSource.metadata","title":"<code>metadata = root.attrs.asdict()</code>  <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.ZarrSource.ZarrSource.__init__","title":"<code>__init__(filename, source_pixel_size=None, target_pixel_size=None, source_info_required=False)</code>","text":"Source code in <code>OmeSliCC\\ZarrSource.py</code> <pre><code>def __init__(self, filename: str,\n             source_pixel_size: list = None,\n             target_pixel_size: list = None,\n             source_info_required: bool = False):\n\n    super().__init__()\n\n    try:\n        if filename.startswith((\"http\", \"s3\")):\n            cls = RemoteStore\n        else:\n            cls = LocalStore\n        store_path = cls(filename)\n        root = zarr.open_group(store=store_path)\n        self.metadata = root.attrs.asdict()\n\n        paths = []\n        dimension_order = 'tczyx'\n        if 'multiscales' in self.metadata:\n            for scale in self.metadata.get('multiscales', []):\n                for index, dataset in enumerate(scale.get('datasets', [])):\n                    paths.append(dataset.get('path', str(index)))\n                axes = scale.get('axes', [])\n                if len(axes) &gt; 0:\n                    dimension_order = ''.join([axis.get('name') for axis in axes])\n        else:\n            paths = root.array_keys()\n        self.dimension_order = dimension_order\n\n        self.levels = []\n        for path in paths:\n            data = root.get(path)\n            self.levels.append(data)\n\n            xyzct = [1, 1, 1, 1, 1]\n            for i, n in enumerate(data.shape):\n                xyzct_index = 'xyzct'.index(dimension_order[i])\n                xyzct[xyzct_index] = n\n            self.sizes_xyzct.append(xyzct)\n            self.sizes.append((xyzct[0], xyzct[1]))\n            self.pixel_types.append(data.dtype)\n            self.pixel_nbits.append(data.dtype.itemsize * 8)\n    except Exception as e:\n        raise FileNotFoundError(f'Read error: {e}')\n\n    self._init_metadata(filename,\n                        source_pixel_size=source_pixel_size,\n                        target_pixel_size=target_pixel_size,\n                        source_info_required=source_info_required)\n</code></pre>"},{"location":"references/#OmeSliCC.ZarrSource.ZarrSource._asarray_level","title":"<code>_asarray_level(level, x0=0, y0=0, x1=-1, y1=-1)</code>","text":"Source code in <code>OmeSliCC\\ZarrSource.py</code> <pre><code>def _asarray_level(self, level: int, x0: float = 0, y0: float = 0, x1: float = -1, y1: float = -1) -&gt; np.ndarray:\n    size_xyzct = self.sizes_xyzct[level]\n    if x1 &lt; 0 or y1 &lt; 0:\n        x1, y1, _, _, _ = size_xyzct\n    if self.dimension_order.endswith('yx'):\n        image = self.levels[level][..., y0:y1, x0:x1].squeeze()\n        if len(image.shape) &gt; 2:\n            image = np.moveaxis(image, 0, -1)  # move axis 0 (channel/z) to end\n    else:\n        image = self.levels[level][y0:y1, x0:x1].squeeze()\n    return image\n</code></pre>"},{"location":"references/#OmeSliCC.ZarrSource.ZarrSource._find_metadata","title":"<code>_find_metadata()</code>","text":"Source code in <code>OmeSliCC\\ZarrSource.py</code> <pre><code>def _find_metadata(self):\n    pixel_size = []\n    channels = []\n    for scale in self.metadata.get('multiscales', []):\n        axes = ''.join([axis.get('name', '') for axis in scale.get('axes', [])])\n        units = [axis.get('unit', '') for axis in scale.get('axes', [])]\n        scale1 = [0, 0, 0, 0, 0]\n        datasets = scale.get('datasets')\n        if datasets is not None:\n            coordinateTransformations = datasets[0].get('coordinateTransformations')\n            if coordinateTransformations is not None:\n                scale1 = coordinateTransformations[0].get('scale', scale1)\n        if 'z' in axes:\n            pixel_size = [\n                (scale1[axes.index('x')], units[axes.index('x')]),\n                (scale1[axes.index('y')], units[axes.index('y')]),\n                (scale1[axes.index('z')], units[axes.index('z')])]\n        else:\n            pixel_size = [(0, ''), (0, ''), (0, '')]\n    nchannels = self.sizes_xyzct[0][3]\n    for data in self.metadata.values():\n        if isinstance(data, dict):\n            n = len(data.get('channels', []))\n            for channel0 in data.get('channels', []):\n                channel = XmlDict({'@Name': channel0.get('label'), '@SamplesPerPixel': nchannels // n})\n                if 'color' in channel0:\n                    channel['@Color'] = channel0['color']\n                channels.append(channel)\n    if len(channels) == 0:\n        if nchannels == 3:\n            channels = [XmlDict({'@Name': '', '@SamplesPerPixel': nchannels})]\n        else:\n            channels = [XmlDict({'@Name': '', '@SamplesPerPixel': 1})] * nchannels\n    self.source_pixel_size = pixel_size\n    self.channels = channels\n    self.source_mag = 0\n</code></pre>"},{"location":"references/#OmeSliCC.color_conversion","title":"<code>color_conversion</code>","text":""},{"location":"references/#OmeSliCC.color_conversion.hexrgb_to_rgba","title":"<code>hexrgb_to_rgba(hexrgb)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def hexrgb_to_rgba(hexrgb: str) -&gt; list:\n    rgba = int_to_rgba(eval('0x' + hexrgb + 'FF'))\n    return rgba\n</code></pre>"},{"location":"references/#OmeSliCC.color_conversion.int_to_rgba","title":"<code>int_to_rgba(intrgba)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def int_to_rgba(intrgba: int) -&gt; list:\n    signed = (intrgba &lt; 0)\n    rgba = [x / 255 for x in intrgba.to_bytes(4, signed=signed, byteorder=\"big\")]\n    if rgba[-1] == 0:\n        rgba[-1] = 1\n    return rgba\n</code></pre>"},{"location":"references/#OmeSliCC.color_conversion.rgba_to_hexrgb","title":"<code>rgba_to_hexrgb(rgba)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def rgba_to_hexrgb(rgba: list) -&gt; str:\n    hexrgb = ''.join([hex(int(x * 255))[2:].upper().zfill(2) for x in rgba[:3]])\n    return hexrgb\n</code></pre>"},{"location":"references/#OmeSliCC.color_conversion.rgba_to_int","title":"<code>rgba_to_int(rgba)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def rgba_to_int(rgba: list) -&gt; int:\n    intrgba = int.from_bytes([int(x * 255) for x in rgba], signed=True, byteorder=\"big\")\n    return intrgba\n</code></pre>"},{"location":"references/#OmeSliCC.conversion","title":"<code>conversion</code>","text":""},{"location":"references/#OmeSliCC.conversion.blur_image","title":"<code>blur_image(image, sigma)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def blur_image(image, sigma):\n    nchannels = image.shape[2] if image.ndim == 3 else 1\n    if nchannels not in [1, 3]:\n        new_image = np.zeros_like(image)\n        for channeli in range(nchannels):\n            new_image[..., channeli] = blur_image_single(image[..., channeli], sigma)\n    else:\n        new_image = blur_image_single(image, sigma)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.blur_image_single","title":"<code>blur_image_single(image, sigma)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def blur_image_single(image, sigma):\n    return gaussian_filter(image, sigma)\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.calc_fraction_used","title":"<code>calc_fraction_used(image, threshold=0.1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_fraction_used(image: np.ndarray, threshold: float = 0.1) -&gt; float:\n    low = int(round(threshold * 255))\n    high = int(round((1 - threshold) * 255))\n    shape = image.shape\n    total = shape[0] * shape[1]\n    good = 0\n    for y in range(shape[0]):\n        for x in range(shape[1]):\n            pixel = image[y, x]\n            if low &lt;= pixel[0] &lt; high and low &lt;= pixel[1] &lt; high and low &lt;= pixel[2] &lt; high:\n                good += 1\n    fraction = good / total\n    return fraction\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.calc_pyramid","title":"<code>calc_pyramid(xyzct, npyramid_add=0, pyramid_downsample=2, volumetric_resize=False)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_pyramid(xyzct: tuple, npyramid_add: int = 0, pyramid_downsample: float = 2,\n                 volumetric_resize: bool = False) -&gt; list:\n    x, y, z, c, t = xyzct\n    if volumetric_resize and z &gt; 1:\n        size = (x, y, z)\n    else:\n        size = (x, y)\n    sizes_add = []\n    scale = 1\n    for _ in range(npyramid_add):\n        scale /= pyramid_downsample\n        scaled_size = np.maximum(np.round(np.multiply(size, scale)).astype(int), 1)\n        sizes_add.append(scaled_size)\n    return sizes_add\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.calc_tiles_median","title":"<code>calc_tiles_median(images)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_tiles_median(images):\n    out_image = np.zeros_like(images[0])\n    median_image = np.median(images, 0, out_image)\n    return median_image\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.calc_tiles_quantiles","title":"<code>calc_tiles_quantiles(images, quantiles)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_tiles_quantiles(images, quantiles):\n    out_quantiles = []\n    quantile_images = np.quantile(images, quantiles, 0)\n    for quantile_image in quantile_images:\n        maxval = 2 ** (8 * images[0].dtype.itemsize) - 1\n        image = (quantile_image / maxval).astype(np.float32)\n        out_quantiles.append(image)\n    return out_quantiles\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.check_image","title":"<code>check_image(source, image, converted_filename)</code>","text":"Source code in <code>OmeSliCC\\conversion.py</code> <pre><code>def check_image(source, image, converted_filename):\n    error_message = None\n    try:\n        dummy_params = {'input': {}, 'output': {}}\n        converted_source = create_source(converted_filename, dummy_params)\n        w, h = converted_source.get_size()\n        x1, y1 = min(16, w), min(16, h)\n        slicing = {'x0': 0, 'x1': x1, 'y0': 0, 'y1': y1, 'z': 0, 't': 0}\n        slices = get_numpy_slicing(source.get_dimension_order(), **slicing)\n        patch_original = image[slices]\n        patch_converted = converted_source.asarray(**slicing)\n        np.testing.assert_allclose(patch_original, patch_converted, verbose=False)\n    except Exception as e:\n        error_message = str(e)\n    if error_message:\n        raise ValueError(f'Converted image check\\n{error_message}')\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.check_round_significants","title":"<code>check_round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def check_round_significants(a: float, significant_digits: int) -&gt; float:\n    rounded = round_significants(a, significant_digits)\n    if a != 0:\n        dif = 1 - rounded / a\n    else:\n        dif = rounded - a\n    if abs(dif) &lt; 10 ** -significant_digits:\n        return rounded\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.check_versions","title":"<code>check_versions()</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def check_versions():\n    print(f'tifffile {tifffile.__version__}')\n    print(imagecodecs.version())\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.combine_images","title":"<code>combine_images(sources, params)</code>","text":"Source code in <code>OmeSliCC\\conversion.py</code> <pre><code>def combine_images(sources: list[OmeSource], params: dict):\n    source0 = sources[0]\n    source_ref = source0.source_reference\n    output_params = params['output']\n    output_folder = output_params['folder']\n    output_format = output_params['format']\n    extra_metadata = output_params.get('extra_metadata', {})\n\n    images = [get_source_image(source) for source in sources]\n    image = da.concatenate(images, axis=1)\n\n    # Experimental metadata\n    #metadatas = []\n    #for source in sources:\n    #    image_filename = source.source_reference\n    #    filepattern = os.path.splitext(image_filename)[0].rstrip('.ome') + '*'\n    #    for metadata_filename in glob.glob(filepattern):\n    #        if metadata_filename != image_filename:\n    #            metadata = file_to_dict(metadata_filename)\n    #            if metadata is not None:\n    #                metadatas.append(metadata)\n\n    new_source = OmeSource()\n    ome = ('ome' in output_format)\n    filetitle = get_filetitle(source_ref).rstrip('.ome')\n    output_filename = str(os.path.join(output_folder, filetitle + '_combined.' + output_format))\n    new_source.source_reference = output_filename\n    new_source.target_pixel_size = source0.get_pixel_size()\n    new_source.position = source0.get_position()\n    new_source.rotation = source0.get_rotation()\n\n    channels = extra_metadata.get('channels', [])\n    if not channels:\n        channels = []\n        for source in sources:\n            for channeli, channel in enumerate(source.get_channels()):\n                label = channel.get('label', '')\n                if label == '' or label in [standard_type.name.lower() for standard_type in TIFF.PHOTOMETRIC]:\n                    channel = channel.copy()\n                    label = get_filetitle(source.source_reference).rstrip('.ome')\n                    if len(source.get_channels()) &gt; 1:\n                        label += f'#{channeli}'\n                    channel['label'] = label\n                channels.append(channel)\n    nchannels = len(channels)\n\n    if image.shape[1] != nchannels:\n        logging.warning('#Combined image channels does not match #data channels')\n\n    new_source.channels = channels\n\n    new_source.sizes = [source0.get_size()]\n    sizes_xyzc = list(source0.get_size_xyzct())\n    sizes_xyzc[3] = nchannels\n    new_source.sizes_xyzct = [tuple(sizes_xyzc)]\n    new_source.pixel_types = source0.pixel_types\n    new_source.pixel_nbits = source0.pixel_nbits\n    new_source.best_level, new_source.best_factor, new_source.full_factor = 0, 1, 1\n    new_source.source_mag = source0.source_mag\n    new_source.output_dimension_order = source0.output_dimension_order\n\n    if 'zar' in output_format:\n        if 'ome.' in output_format:\n            save_image_as_ome_zarr(new_source, image, output_filename, output_params)\n        else:\n            save_image_as_zarr(new_source, image, output_filename, output_params)\n    elif 'tif' in output_format:\n        save_image_as_tiff(new_source, image, output_filename, output_params, ome=ome)\n    else:\n        save_image(image, output_filename, output_params)\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.compare_image","title":"<code>compare_image(image0, image1, show=False)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image(image0, image1, show=False) -&gt; float:\n    dif, dif_max, dif_mean, psnr = compare_image_dist(image0, image1)\n    print(f'rgb dist max: {dif_max:.1f} mean: {dif_mean:.1f} PSNR: {psnr:.1f}')\n    if show:\n        show_image(dif)\n        show_image((dif * 10).astype(np.uint8))\n    return dif\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.compare_image_dist","title":"<code>compare_image_dist(image0, image1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image_dist(image0: np.ndarray, image1: np.ndarray) -&gt; tuple:\n    dif = cv.absdiff(image0, image1)\n    psnr = cv.PSNR(image0, image1)\n    if dif.size &gt; 1000000000:\n        # split very large array\n        rgb_maxs = []\n        rgb_means = []\n        for dif1 in np.array_split(dif, 16):\n            rgb_dif = np.linalg.norm(dif1, axis=2)\n            rgb_maxs.append(np.max(rgb_dif))\n            rgb_means.append(np.mean(rgb_dif))\n        rgb_max = np.max(rgb_maxs)\n        rgb_mean = np.mean(rgb_means)\n    else:\n        rgb_dif = np.linalg.norm(dif, axis=2)\n        rgb_max = np.max(rgb_dif)\n        rgb_mean = np.mean(rgb_dif)\n    return dif, rgb_max, rgb_mean, psnr\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.compare_image_dist_simple","title":"<code>compare_image_dist_simple(image0, image1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image_dist_simple(image0: np.ndarray, image1: np.ndarray) -&gt; dict:\n    dif = cv.absdiff(image0, image1)\n    psnr = cv.PSNR(image0, image1)\n    rgb_dif = np.linalg.norm(dif, axis=2)\n    dif_max = np.max(rgb_dif)\n    dif_mean = np.mean(rgb_dif)\n    return {'dif_max': dif_max, 'dif_mean': dif_mean, 'psnr': psnr}\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.convert_image","title":"<code>convert_image(source, params, load_chunked=False)</code>","text":"Source code in <code>OmeSliCC\\conversion.py</code> <pre><code>def convert_image(source: OmeSource, params: dict, load_chunked: bool = False):\n    source_ref = source.source_reference\n    output_params = params['output']\n    output_folder = output_params['folder']\n    output_format = output_params['format']\n    ome = ('ome' in output_format)\n    overwrite = output_params.get('overwrite', True)\n    if not os.path.exists(output_folder):\n        os.makedirs(output_folder)\n    filetitle = get_filetitle(source_ref).rstrip('.ome')\n    output_filename = str(os.path.join(output_folder, filetitle + '.' + output_format))\n    if overwrite or not os.path.exists(output_filename):\n        if load_chunked:\n            image = get_source_image_chunked(source)\n            #image = get_source_image_dask(source)\n        else:\n            image = get_source_image(source)\n        if 'ome.zarr' in output_format:\n            save_image_as_ome_zarr(source, image, output_filename, output_params)\n        elif 'zarr' in output_format:\n            save_image_as_zarr(source, image, output_filename, output_params)\n        elif 'tif' in output_format:\n            save_image_as_tiff(source, image, output_filename, output_params, ome=ome)\n        else:\n            save_image(image, output_filename, output_params)\n        check_image(source, image, output_filename)\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.convert_image_sign_type","title":"<code>convert_image_sign_type(image, target_dtype)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def convert_image_sign_type(image: np.ndarray, target_dtype: np.dtype) -&gt; np.ndarray:\n    source_dtype = image.dtype\n    if source_dtype.kind == target_dtype.kind:\n        new_image = image\n    elif source_dtype.kind == 'i':\n        new_image = ensure_unsigned_image(image)\n    else:\n        # conversion without overhead\n        offset = 2 ** (8 * target_dtype.itemsize - 1)\n        new_image = (image - offset).astype(target_dtype)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.convert_rational_value","title":"<code>convert_rational_value(value)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def convert_rational_value(value) -&gt; float:\n    if value is not None and isinstance(value, tuple):\n        value = value[0] / value[1]\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.create_compression_codecs","title":"<code>create_compression_codecs(compression)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def create_compression_codecs(compression: list) -&gt; list:\n    codecs = None\n    compression = ensure_list(compression)\n    if compression is not None and len(compression) &gt; 0:\n        compression_type = compression[0].lower()\n        if len(compression) &gt; 1:\n            level = int(compression[1])\n        else:\n            level = None\n        if 'lzw' in compression_type:\n            from imagecodecs.numcodecs import Lzw\n            codecs = [Lzw()]\n        elif '2k' in compression_type or '2000' in compression_type:\n            from imagecodecs.numcodecs import Jpeg2k\n            codecs = [Jpeg2k(level=level)]\n        elif 'jpegls' in compression_type:\n            from imagecodecs.numcodecs import Jpegls\n            codecs = [Jpegls(level=level)]\n        elif 'jpegxr' in compression_type:\n            from imagecodecs.numcodecs import Jpegxr\n            codecs = [Jpegxr(level=level)]\n        elif 'jpegxl' in compression_type:\n            from imagecodecs.numcodecs import Jpegxl\n            codecs = [Jpegxl(level=level)]\n        else:\n            codecs = [compression]\n    return codecs\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.create_compression_filter","title":"<code>create_compression_filter(compression)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def create_compression_filter(compression: list) -&gt; tuple:\n    compressor, compression_filters = None, None\n    compression = ensure_list(compression)\n    if compression is not None and len(compression) &gt; 0:\n        compression_type = compression[0].lower()\n        if len(compression) &gt; 1:\n            level = int(compression[1])\n        else:\n            level = None\n        if 'lzw' in compression_type:\n            from imagecodecs.numcodecs import Lzw\n            compression_filters = [Lzw()]\n        elif '2k' in compression_type or '2000' in compression_type:\n            from imagecodecs.numcodecs import Jpeg2k\n            compression_filters = [Jpeg2k(level=level)]\n        elif 'jpegls' in compression_type:\n            from imagecodecs.numcodecs import Jpegls\n            compression_filters = [Jpegls(level=level)]\n        elif 'jpegxr' in compression_type:\n            from imagecodecs.numcodecs import Jpegxr\n            compression_filters = [Jpegxr(level=level)]\n        elif 'jpegxl' in compression_type:\n            from imagecodecs.numcodecs import Jpegxl\n            compression_filters = [Jpegxl(level=level)]\n        else:\n            compressor = compression\n    return compressor, compression_filters\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.create_source","title":"<code>create_source(source_ref, params, omero=None)</code>","text":"Source code in <code>OmeSliCC\\conversion.py</code> <pre><code>def create_source(source_ref: str, params: dict, omero=None) -&gt; OmeSource:\n    source_pixel_size = split_value_unit_list(params.get('input', {}).get('pixel_size'))\n    target_pixel_size = split_value_unit_list(params.get('output', {}).get('pixel_size'))\n    ext = os.path.splitext(source_ref)[1].lower()\n    if omero is not None:\n        from OmeSliCC.OmeroSource import OmeroSource\n        source = OmeroSource(omero, int(source_ref), source_pixel_size=source_pixel_size, target_pixel_size=target_pixel_size)\n    elif ext == '.zarr':\n        source = OmeZarrSource(source_ref, source_pixel_size=source_pixel_size, target_pixel_size=target_pixel_size)\n    elif ext.lstrip('.') in TIFF.FILE_EXTENSIONS:\n        source = TiffSource(source_ref, source_pixel_size=source_pixel_size, target_pixel_size=target_pixel_size)\n    elif ext in Image.registered_extensions().keys():\n        source = PlainImageSource(source_ref, source_pixel_size=source_pixel_size, target_pixel_size=target_pixel_size)\n    else:\n        try:\n            from OmeSliCC.BioSource import BioSource\n            source = BioSource(source_ref, source_pixel_size=source_pixel_size, target_pixel_size=target_pixel_size)\n        except ImportError:\n            raise NotImplementedError('Unsupported: Bioformats not installed')\n    return source\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.desc_to_dict","title":"<code>desc_to_dict(desc)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def desc_to_dict(desc: str) -&gt; dict:\n    desc_dict = {}\n    if desc.startswith('{'):\n        try:\n            metadata = ast.literal_eval(desc)\n            return metadata\n        except:\n            pass\n    for item in re.split(r'[\\r\\n\\t|]', desc):\n        item_sep = '='\n        if ':' in item:\n            item_sep = ':'\n        if item_sep in item:\n            items = item.split(item_sep)\n            key = items[0].strip()\n            value = items[1].strip()\n            for dtype in (int, float, bool):\n                try:\n                    value = dtype(value)\n                    break\n                except:\n                    pass\n            desc_dict[key] = value\n    return desc_dict\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.ensure_list","title":"<code>ensure_list(x)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def ensure_list(x) -&gt; list:\n    if x is None:\n        return []\n    elif isinstance(x, list):\n        return x\n    else:\n        return [x]\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.ensure_unsigned_image","title":"<code>ensure_unsigned_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def ensure_unsigned_image(image: np.ndarray) -&gt; np.ndarray:\n    source_dtype = image.dtype\n    dtype = ensure_unsigned_type(source_dtype)\n    if dtype != source_dtype:\n        # conversion without overhead\n        offset = 2 ** (8 * dtype.itemsize - 1)\n        new_image = image.astype(dtype) + offset\n    else:\n        new_image = image\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.ensure_unsigned_type","title":"<code>ensure_unsigned_type(dtype)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def ensure_unsigned_type(dtype: np.dtype) -&gt; np.dtype:\n    new_dtype = dtype\n    if dtype.kind == 'i' or dtype.byteorder == '&gt;' or dtype.byteorder == '&lt;':\n        new_dtype = np.dtype(f'u{dtype.itemsize}')\n    return new_dtype\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.extract_thumbnail","title":"<code>extract_thumbnail(source, params)</code>","text":"Source code in <code>OmeSliCC\\conversion.py</code> <pre><code>def extract_thumbnail(source: OmeSource, params: dict):\n    source_ref = source.source_reference\n    output_params = params['output']\n    output_folder = output_params['folder']\n    target_size = output_params.get('thumbnail_size', 1000)\n    if not os.path.exists(output_folder):\n        os.makedirs(output_folder)\n\n    output_filename = os.path.join(output_folder, f'{get_filetitle(source_ref)}_thumb.tiff')\n    size = source.get_size()\n    nchannels = source.get_size_xyzct()[3]\n\n    if target_size &lt; 1:\n        factor = target_size\n    else:\n        factor = np.max(np.divide(size, target_size))\n    thumb_size = np.round(np.divide(size, factor)).astype(int)\n    thumb = source.get_thumbnail(thumb_size)\n\n    if nchannels not in [1, 3]:\n        for channeli in range(nchannels):\n            output_filename = os.path.join(output_folder, f'{get_filetitle(source_ref)}_channel{channeli}_thumb.tiff')\n            save_tiff(output_filename, thumb[..., channeli], dimension_order='yx')\n    else:\n        save_tiff(output_filename, thumb, dimension_order='yxc')\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.file_to_dict","title":"<code>file_to_dict(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def file_to_dict(filename: str) -&gt; dict:\n    ext = os.path.splitext(filename)[1]\n    content = open(filename, 'r').read()\n    if ext == '.xml':\n        data = xmltodict.parse(content)\n    elif ext in ['.yml', '.yaml']:\n        data = yaml.safe_load(content)\n    else:   # assume json\n        data = json.loads(content)\n    return data\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.filter_dict","title":"<code>filter_dict(dict0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def filter_dict(dict0: dict) -&gt; dict:\n    new_dict = {}\n    for key, value0 in dict0.items():\n        if value0 is not None:\n            values = []\n            for value in ensure_list(value0):\n                if isinstance(value, dict):\n                    value = filter_dict(value)\n                values.append(value)\n            if len(values) == 1:\n                values = values[0]\n            new_dict[key] = values\n    return new_dict\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.float2int_image","title":"<code>float2int_image(image, target_dtype=np.dtype(np.uint8))</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def float2int_image(image, target_dtype=np.dtype(np.uint8)):\n    source_dtype = image.dtype\n    if source_dtype.kind not in ('i', 'u') and not target_dtype.kind == 'f':\n        maxval = 2 ** (8 * target_dtype.itemsize) - 1\n        return (image * maxval).astype(target_dtype)\n    else:\n        return image\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.get_default","title":"<code>get_default(x, default)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_default(x, default):\n    return default if x is None else x\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.get_filetitle","title":"<code>get_filetitle(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_filetitle(filename: str) -&gt; str:\n    filebase = os.path.basename(filename)\n    title = os.path.splitext(filebase)[0].rstrip('.ome')\n    return title\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.get_image_info","title":"<code>get_image_info(source)</code>","text":"Source code in <code>OmeSliCC\\conversion.py</code> <pre><code>def get_image_info(source: OmeSource) -&gt; str:\n    sizes_xyzct = source.sizes_xyzct\n    pixel_nbytes = source.get_pixel_nbytes()\n    pixel_type = source.get_pixel_type()\n    channels = source.get_channels()\n    image_info = os.path.basename(source.source_reference)\n    image_info += ' ' + get_image_size_info(sizes_xyzct, pixel_nbytes, pixel_type, channels)\n    sizes = source.get_physical_size()\n    if len(sizes) &gt; 0:\n        image_info += ' Physical size:'\n        infos = []\n        for size in sizes:\n            if size[0] &gt; 0:\n                infos.append(f' {size[0]:.2f} {size[1]}')\n        image_info += ' x'.join(infos)\n    return image_info\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.get_image_quantile","title":"<code>get_image_quantile(image, quantile, axis=None)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_image_quantile(image: np.ndarray, quantile: float, axis=None) -&gt; float:\n    value = np.quantile(image, quantile, axis=axis).astype(image.dtype)\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.get_image_size_info","title":"<code>get_image_size_info(sizes_xyzct, pixel_nbytes, pixel_type, channels)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_image_size_info(sizes_xyzct: list, pixel_nbytes: int, pixel_type: np.dtype, channels: list) -&gt; str:\n    image_size_info = 'XYZCT:'\n    size = 0\n    for i, size_xyzct in enumerate(sizes_xyzct):\n        w, h, zs, cs, ts = size_xyzct\n        size += np.int64(pixel_nbytes) * w * h * zs * cs * ts\n        if i &gt; 0:\n            image_size_info += ','\n        image_size_info += f' {w} {h} {zs} {cs} {ts}'\n    image_size_info += f' Pixel type: {pixel_type} Uncompressed: {print_hbytes(size)}'\n    if sizes_xyzct[0][3] == 3:\n        channel_info = 'rgb'\n    else:\n        channel_info = ','.join([channel.get('Name', '') for channel in channels])\n    if channel_info != '':\n        image_size_info += f' Channels: {channel_info}'\n    return image_size_info\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.get_numpy_slicing","title":"<code>get_numpy_slicing(dimension_order, **slicing)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_numpy_slicing(dimension_order, **slicing):\n    slices = []\n    for axis in dimension_order:\n        index = slicing.get(axis)\n        index0 = slicing.get(axis + '0')\n        index1 = slicing.get(axis + '1')\n        if index0 is not None and index1 is not None:\n            slice1 = slice(int(index0), int(index1))\n        elif index is not None:\n            slice1 = int(index)\n        else:\n            slice1 = slice(None)\n        slices.append(slice1)\n    return tuple(slices)\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.get_pil_metadata","title":"<code>get_pil_metadata(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_pil_metadata(image: PIL.Image) -&gt; dict:\n    metadata = {}\n    exifdata = image.getexif()\n    for tag_id in exifdata:\n        tag = TAGS.get(tag_id, tag_id)\n        data = exifdata.get(tag_id)\n        if isinstance(data, bytes):\n            data = data.decode()\n        metadata[tag] = data\n    if metadata == {}:\n        metadata = image.info\n    return metadata\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.get_source_image","title":"<code>get_source_image(source)</code>","text":"Source code in <code>OmeSliCC\\conversion.py</code> <pre><code>def get_source_image(source: OmeSource):\n    image = source.asarray()\n    image_size = image.size * image.itemsize\n    if image_size &lt; psutil.virtual_memory().total:\n        image = np.asarray(image)   # pre-computing is way faster than dask saving/scaling\n    return image\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.get_source_image_chunked","title":"<code>get_source_image_chunked(source, chunk_size=(10240, 10240))</code>","text":"Source code in <code>OmeSliCC\\conversion.py</code> <pre><code>def get_source_image_chunked(source: OmeSource, chunk_size=(10240, 10240)):\n    image = source.clone_empty()\n    for indices, chunk in source.produce_chunks(chunk_size):\n        s = indices\n        e = np.array(s) + chunk.shape\n        image[s[0]:e[0],\n              s[1]:e[1],\n              s[2]:e[2],\n              s[3]:e[3],\n              s[4]:e[4]] = chunk\n    return image\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.get_source_image_dask","title":"<code>get_source_image_dask(source, chunk_size=(10240, 10240))</code>","text":"Source code in <code>OmeSliCC\\conversion.py</code> <pre><code>def get_source_image_dask(source: OmeSource, chunk_size=(10240, 10240)):\n    image = source.asdask(chunk_size)\n    return image\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.get_tiff_pages","title":"<code>get_tiff_pages(tiff)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_tiff_pages(tiff: TiffFile) -&gt; list:\n    # TODO: review so this works for multi-level ome-tiff, tiff-stack, and z pages tiff, then later check for mmstack\n    pages = []\n    found = False\n    if tiff.series and not tiff.is_mmstack:\n        # has series\n        baseline = tiff.series[0]\n        for level in baseline.levels:\n            # has levels\n            level_pages = []\n            for page in level.pages:\n                found = True\n                level_pages.append(page)\n            if level_pages:\n                pages.append(level_pages)\n\n    if not found:\n        for page in tiff.pages:\n            pages.append(page)\n    return pages\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.get_value_units_micrometer","title":"<code>get_value_units_micrometer(value_units0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_value_units_micrometer(value_units0: list) -&gt; list:\n    conversions = {'nm': 1e-3, '\u00b5m': 1, 'um': 1, 'micrometer': 1, 'mm': 1e3, 'cm': 1e4, 'm': 1e6}\n    if value_units0 is None:\n        return None\n\n    values_um = []\n    for value_unit in value_units0:\n        if not (isinstance(value_unit, int) or isinstance(value_unit, float)):\n            value_um = value_unit[0] * conversions.get(value_unit[1], 1)\n        else:\n            value_um = value_unit\n        values_um.append(value_um)\n    return values_um\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.image_reshape","title":"<code>image_reshape(image, target_size)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def image_reshape(image: np.ndarray, target_size: tuple) -&gt; np.ndarray:\n    tw, th = target_size\n    sh, sw = image.shape[0:2]\n    if sw &lt; tw or sh &lt; th:\n        dw = max(tw - sw, 0)\n        dh = max(th - sh, 0)\n        padding = [(0, dh), (0, dw)]\n        if len(image.shape) == 3:\n            padding += [(0, 0)]\n        image = np.pad(image, padding, 'edge')\n    if tw &lt; sw or th &lt; sh:\n        image = image[0:th, 0:tw]\n    return image\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.image_resize","title":"<code>image_resize(image, target_size0, dimension_order='yxc')</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def image_resize(image: np.ndarray, target_size0: tuple, dimension_order: str = 'yxc') -&gt; np.ndarray:\n    shape = image.shape\n    x_index = dimension_order.index('x')\n    y_index = dimension_order.index('y')\n    c_is_at_end = ('c' in dimension_order and dimension_order.endswith('c'))\n    size = shape[x_index], shape[y_index]\n    if np.mean(np.divide(size, target_size0)) &lt; 1:\n        interpolation = cv.INTER_CUBIC\n    else:\n        interpolation = cv.INTER_AREA\n    dtype0 = image.dtype\n    image = ensure_unsigned_image(image)\n    target_size = tuple(np.maximum(np.round(target_size0).astype(int), 1))\n    if dimension_order in ['yxc', 'yx']:\n        new_image = cv.resize(np.asarray(image), target_size, interpolation=interpolation)\n    elif dimension_order == 'cyx':\n        new_image = np.moveaxis(image, 0, -1)\n        new_image = cv.resize(np.asarray(new_image), target_size, interpolation=interpolation)\n        new_image = np.moveaxis(new_image, -1, 0)\n    else:\n        ts = image.shape[dimension_order.index('t')] if 't' in dimension_order else 1\n        zs = image.shape[dimension_order.index('z')] if 'z' in dimension_order else 1\n        target_shape = list(image.shape).copy()\n        target_shape[x_index] = target_size[0]\n        target_shape[y_index] = target_size[1]\n        new_image = np.zeros(target_shape, dtype=image.dtype)\n        for t in range(ts):\n            for z in range(zs):\n                slices = get_numpy_slicing(dimension_order, z=z, t=t)\n                image1 = image[slices]\n                if not c_is_at_end:\n                    image1 = np.moveaxis(image1, 0, -1)\n                new_image1 = np.atleast_3d(cv.resize(np.asarray(image1), target_size, interpolation=interpolation))\n                if not c_is_at_end:\n                    new_image1 = np.moveaxis(new_image1, -1, 0)\n                new_image[slices] = new_image1\n    new_image = convert_image_sign_type(new_image, dtype0)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.int2float_image","title":"<code>int2float_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def int2float_image(image):\n    source_dtype = image.dtype\n    if not source_dtype.kind == 'f':\n        maxval = 2 ** (8 * source_dtype.itemsize) - 1\n        return image / np.float32(maxval)\n    else:\n        return image\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.normalise_values","title":"<code>normalise_values(image, min_value, max_value)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def normalise_values(image: np.ndarray, min_value: float, max_value: float) -&gt; np.ndarray:\n    return np.clip((image.astype(np.float32) - min_value) / (max_value - min_value), 0, 1)\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.pilmode_to_pixelinfo","title":"<code>pilmode_to_pixelinfo(mode)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def pilmode_to_pixelinfo(mode: str) -&gt; tuple:\n    pixelinfo = (np.uint8, 8, 1)\n    mode_types = {\n        'I': (np.uint32, 32, 1),\n        'F': (np.float32, 32, 1),\n        'RGB': (np.uint8, 24, 3),\n        'RGBA': (np.uint8, 32, 4),\n        'CMYK': (np.uint8, 32, 4),\n        'YCbCr': (np.uint8, 24, 3),\n        'LAB': (np.uint8, 24, 3),\n        'HSV': (np.uint8, 24, 3),\n    }\n    if '16' in mode:\n        pixelinfo = (np.uint16, 16, 1)\n    elif '32' in mode:\n        pixelinfo = (np.uint32, 32, 1)\n    elif mode in mode_types:\n        pixelinfo = mode_types[mode]\n    pixelinfo = (np.dtype(pixelinfo[0]), pixelinfo[1])\n    return pixelinfo\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.precise_resize","title":"<code>precise_resize(image, factors)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def precise_resize(image: np.ndarray, factors) -&gt; np.ndarray:\n    if image.ndim &gt; len(factors):\n        factors = list(factors) + [1]\n    new_image = downscale_local_mean(np.asarray(image), tuple(factors)).astype(image.dtype)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.print_dict","title":"<code>print_dict(dct, indent=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_dict(dct: dict, indent: int = 0) -&gt; str:\n    s = ''\n    if isinstance(dct, dict):\n        for key, value in dct.items():\n            s += '\\n'\n            if not isinstance(value, list):\n                s += '\\t' * indent + str(key) + ': '\n            if isinstance(value, dict):\n                s += print_dict(value, indent=indent + 1)\n            elif isinstance(value, list):\n                for v in value:\n                    s += print_dict(v)\n            else:\n                s += str(value)\n    else:\n        s += str(dct)\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.print_hbytes","title":"<code>print_hbytes(nbytes)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_hbytes(nbytes: int) -&gt; str:\n    exps = ['', 'K', 'M', 'G', 'T']\n    div = 1024\n    exp = 0\n\n    while nbytes &gt; div:\n        nbytes /= div\n        exp += 1\n    return f'{nbytes:.1f}{exps[exp]}B'\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.redimension_data","title":"<code>redimension_data(data, old_order, new_order, **indices)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def redimension_data(data, old_order, new_order, **indices):\n    # able to provide optional dimension values e.g. t=0, z=0\n    if new_order == old_order:\n        return data\n\n    new_data = data\n    order = old_order\n    # remove\n    for o in old_order:\n        if o not in new_order:\n            index = order.index(o)\n            dim_value = indices.get(o, 0)\n            new_data = np.take(new_data, indices=dim_value, axis=index)\n            order = order[:index] + order[index + 1:]\n    # add\n    for o in new_order:\n        if o not in order:\n            new_data = np.expand_dims(new_data, 0)\n            order = o + order\n    # move\n    old_indices = [order.index(o) for o in new_order]\n    new_indices = list(range(len(new_order)))\n    new_data = np.moveaxis(new_data, old_indices, new_indices)\n    return new_data\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.reorder","title":"<code>reorder(items, old_order, new_order, default_value=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def reorder(items: list, old_order: str, new_order: str, default_value: int = 0) -&gt; list:\n    new_items = []\n    for label in new_order:\n        if label in old_order:\n            item = items[old_order.index(label)]\n        else:\n            item = default_value\n        new_items.append(item)\n    return new_items\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.round_significants","title":"<code>round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def round_significants(a: float, significant_digits: int) -&gt; float:\n    if a != 0:\n        round_decimals = significant_digits - int(np.floor(np.log10(abs(a)))) - 1\n        return round(a, round_decimals)\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.save_image","title":"<code>save_image(image, filename, output_params={})</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def save_image(image: np.ndarray, filename: str, output_params: dict = {}):\n    compression = output_params.get('compression')\n    PIL.Image.fromarray(image).save(filename, compression=compression)\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.save_image_as_ome_zarr","title":"<code>save_image_as_ome_zarr(source, data, output_filename, output_params)</code>","text":"Source code in <code>OmeSliCC\\conversion.py</code> <pre><code>def save_image_as_ome_zarr(source: OmeSource, data: np.ndarray, output_filename: str, output_params: dict):\n    # ome-zarr: https://ngff.openmicroscopy.org/latest/\n    tile_size = output_params.get('tile_size')\n    compression = output_params.get('compression')\n    npyramid_add = output_params.get('npyramid_add', 0)\n    pyramid_downsample = output_params.get('pyramid_downsample')\n\n    zarr = OmeZarr(output_filename)\n    zarr.write(source, tile_size=tile_size, compression=compression,\n               npyramid_add=npyramid_add, pyramid_downsample=pyramid_downsample)\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.save_image_as_tiff","title":"<code>save_image_as_tiff(source, image, output_filename, output_params, ome=False)</code>","text":"Source code in <code>OmeSliCC\\conversion.py</code> <pre><code>def save_image_as_tiff(source: OmeSource, image: np.ndarray, output_filename: str, output_params: dict, ome: bool = False):\n    tile_size = output_params.get('tile_size')\n    compression = output_params.get('compression')\n    combine_rgb = output_params.get('combine_rgb', True)\n\n    npyramid_add = output_params.get('npyramid_add', 0)\n    pyramid_downsample = output_params.get('pyramid_downsample')\n    if npyramid_add &gt; 0:\n        pyramid_sizes_add = calc_pyramid(source.get_size_xyzct(), npyramid_add, pyramid_downsample)\n    else:\n        pyramid_sizes_add = []\n\n    if ome:\n        metadata = None\n        xml_metadata = source.create_xml_metadata(output_filename, combine_rgb=combine_rgb,\n                                                  pyramid_sizes_add=pyramid_sizes_add)\n    else:\n        metadata = source.get_metadata()\n        xml_metadata = None\n    resolution, resolution_unit = get_resolution_from_pixel_size(source.get_pixel_size())\n\n    save_tiff(output_filename, image, metadata=metadata, xml_metadata=xml_metadata,\n              dimension_order=source.get_dimension_order(),\n              resolution=resolution, resolution_unit=resolution_unit, tile_size=tile_size,\n              compression=compression, combine_rgb=combine_rgb, pyramid_sizes_add=pyramid_sizes_add)\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.save_image_as_zarr","title":"<code>save_image_as_zarr(source, data, output_filename, output_params, ome=None, v3=False)</code>","text":"Source code in <code>OmeSliCC\\conversion.py</code> <pre><code>def save_image_as_zarr(source: OmeSource, data: np.ndarray, output_filename: str, output_params: dict,\n                       ome: bool = None, v3: bool = False):\n    # ome-zarr: https://ngff.openmicroscopy.org/latest/\n    tile_size = output_params.get('tile_size')\n    compression = output_params.get('compression')\n    npyramid_add = output_params.get('npyramid_add', 0)\n    pyramid_downsample = output_params.get('pyramid_downsample')\n\n    zarr = Zarr(output_filename, ome=ome, v3=v3)\n    zarr.create(source, tile_size=tile_size, npyramid_add=npyramid_add, pyramid_downsample=pyramid_downsample,\n                compression=compression)\n    zarr.set(data)\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.save_tiff","title":"<code>save_tiff(filename, image, metadata=None, xml_metadata=None, dimension_order='yxc', resolution=None, resolution_unit=None, tile_size=None, compression=None, combine_rgb=True, pyramid_sizes_add=[])</code>","text":"Source code in <code>OmeSliCC\\conversion.py</code> <pre><code>def save_tiff(filename: str, image: np.ndarray, metadata: dict = None, xml_metadata: str = None,\n              dimension_order: str = 'yxc',\n              resolution: tuple = None, resolution_unit: str = None, tile_size: tuple = None, compression: [] = None,\n              combine_rgb=True, pyramid_sizes_add: list = []):\n    x_index = dimension_order.index('x')\n    y_index = dimension_order.index('y')\n    size = image.shape[x_index], image.shape[y_index]\n\n    nchannels = 1\n    if 'c' in dimension_order:\n        c_index = dimension_order.index('c')\n        nchannels = image.shape[c_index]\n    else:\n        c_index = -1\n\n    if tile_size is not None and isinstance(tile_size, int):\n        tile_size = [tile_size] * 2\n\n    split_channels = not (combine_rgb and nchannels == 3)\n    if nchannels == 3 and not split_channels:\n        photometric = PHOTOMETRIC.RGB\n        image = np.moveaxis(image, c_index, -1)\n        dimension_order = dimension_order.replace('c', '') + 'c'\n    else:\n        photometric = PHOTOMETRIC.MINISBLACK\n\n    if resolution is not None:\n        # tifffile only supports x/y pyramid resolution\n        resolution = tuple(resolution[0:2])\n\n    # maximum size (w/o compression)\n    max_size = image.size * image.itemsize\n    base_size = np.divide(max_size, np.prod(size))\n    for new_size in pyramid_sizes_add:\n        max_size += np.prod(new_size) * base_size\n    bigtiff = (max_size &gt; 2 ** 32)\n\n    #scaler = Scaler(downscale=..., max_layer=len(pyramid_sizes_add))   # use ome-zarr-py dask scaling\n\n    if xml_metadata is not None:\n        # set ome=False to provide custom OME xml in description\n        xml_metadata_bytes = xml_metadata.encode()\n        is_ome = False\n    else:\n        xml_metadata_bytes = None\n        is_ome = None\n    with TiffWriter(filename, ome=is_ome, bigtiff=bigtiff) as writer:\n        writer.write(image, photometric=photometric, subifds=len(pyramid_sizes_add),\n                     resolution=resolution, resolutionunit=resolution_unit, tile=tile_size, compression=compression,\n                     metadata=metadata, description=xml_metadata_bytes)\n        for new_size in pyramid_sizes_add:\n            image = image_resize(image, new_size, dimension_order=dimension_order)\n            #image = scaler.resize_image(image)    # significantly slower\n            writer.write(image, photometric=photometric, subfiletype=1,\n                         resolution=resolution, resolutionunit=resolution_unit, tile=tile_size, compression=compression)\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.show_image","title":"<code>show_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def show_image(image: np.ndarray):\n    plt.imshow(image)\n    plt.show()\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.show_image_gray","title":"<code>show_image_gray(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def show_image_gray(image: np.ndarray):\n    plt.imshow(image, cmap='gray')\n    plt.show()\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.split_num_text","title":"<code>split_num_text(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_num_text(text: str) -&gt; list:\n    num_texts = []\n    block = ''\n    is_num0 = None\n    if text is None:\n        return None\n\n    for c in text:\n        is_num = (c.isnumeric() or c == '.')\n        if is_num0 is not None and is_num != is_num0:\n            num_texts.append(block)\n            block = ''\n        block += c\n        is_num0 = is_num\n    if block != '':\n        num_texts.append(block)\n\n    num_texts2 = []\n    for block in num_texts:\n        block = block.strip()\n        try:\n            block = float(block)\n        except:\n            pass\n        if block not in [' ', ',', '|']:\n            num_texts2.append(block)\n    return num_texts2\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.split_value_unit_list","title":"<code>split_value_unit_list(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_value_unit_list(text: str) -&gt; list:\n    value_units = []\n    if text is None:\n        return None\n\n    items = split_num_text(text)\n    if isinstance(items[-1], str):\n        def_unit = items[-1]\n    else:\n        def_unit = ''\n\n    i = 0\n    while i &lt; len(items):\n        value = items[i]\n        if i + 1 &lt; len(items):\n            unit = items[i + 1]\n        else:\n            unit = ''\n        if not isinstance(value, str):\n            if isinstance(unit, str):\n                i += 1\n            else:\n                unit = def_unit\n            value_units.append((value, unit))\n        i += 1\n    return value_units\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.store_tiles","title":"<code>store_tiles(sources, output_filename, params, composition_metadata=[], image_operations=[])</code>","text":"Source code in <code>OmeSliCC\\conversion.py</code> <pre><code>def store_tiles(sources: list[OmeSource], output_filename: str, params: dict,\n                composition_metadata: list = [], image_operations: list = []):\n    output_params = params['output']\n    tile_size = output_params.get('tile_size')\n    compression = output_params.get('compression')\n    npyramid_add = output_params.get('npyramid_add', 0)\n    pyramid_downsample = output_params.get('pyramid_downsample')\n\n    translations = []\n    pixel_size = sources[0].get_pixel_size_micrometer()\n    for meta in composition_metadata:\n        bounds = meta['Bounds']\n        translation = bounds['StartX'], bounds['StartY']\n        translation_um = np.multiply(translation, pixel_size[:2])\n        translations.append(translation_um)\n\n    zarr = OmeZarr(output_filename)\n    zarr.write(sources, tile_size=tile_size, compression=compression,\n               npyramid_add=npyramid_add, pyramid_downsample=pyramid_downsample,\n               translations=translations, image_operations=image_operations)\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.tags_to_dict","title":"<code>tags_to_dict(tags)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tags_to_dict(tags: tifffile.TiffTags) -&gt; dict:\n    tag_dict = {}\n    for tag in tags.values():\n        tag_dict[tag.name] = tag.value\n    return tag_dict\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.tiff_info","title":"<code>tiff_info(filename)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tiff_info(filename: str) -&gt; str:\n    s = ''\n    nom_size = 0\n    tiff = TiffFile(filename)\n    real_size = tiff.fstat.st_size\n    s += str(tiff) + '\\n'\n    if tiff.ome_metadata:\n        print(tiff.ome_metadata)\n        s += f'OME: {print_dict(tifffile.xml2dict(tiff.ome_metadata))}\\n'\n    if tiff.metaseries_metadata:\n        s += f'Series: {tiff.metaseries_metadata}\\n'\n    if tiff.imagej_metadata:\n        s += f'ImageJ: {tiff.imagej_metadata}\\n'\n\n    for page0 in get_tiff_pages(tiff):\n        page = page0[0] if isinstance(page0, list) else page0\n        s += str(page) + '\\n'\n        s += f'Size: {np.flip(page.shape)} ({print_hbytes(page.size)})\\n'\n        if page.is_tiled:\n            s += f'Tiling: {page.tilewidth} {page.tilelength} {page.tiledepth}\\n'\n        s += f'Compression: {str(page.compression)} jpegtables: {page.jpegtables is not None}\\n'\n        tag_dict = tags_to_dict(page.tags)\n        if 'TileOffsets' in tag_dict:\n            tag_dict.pop('TileOffsets')\n        if 'TileByteCounts' in tag_dict:\n            tag_dict.pop('TileByteCounts')\n        if 'ImageDescription' in tag_dict and tag_dict['ImageDescription'].startswith('&lt;?xml'):\n            # redundant\n            tag_dict.pop('ImageDescription')\n        s += print_dict(tag_dict) + '\\n\\n'\n        nom_size += page.size\n\n    s += f'Overall compression: 1:{nom_size / real_size:.1f}'\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.conversion.tiff_info_short","title":"<code>tiff_info_short(filename)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tiff_info_short(filename: str) -&gt; str:\n    nom_size = 0\n    tiff = TiffFile(filename)\n    s = str(filename)\n    real_size = tiff.fstat.st_size\n    for page in tiff.pages:\n        s += ' ' + str(page)\n        nom_size += page.size\n    s += f' Image size:{nom_size} File size:{real_size} Overall compression: 1:{nom_size / real_size:.1f}'\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.image_util","title":"<code>image_util</code>","text":""},{"location":"references/#OmeSliCC.image_util.blur_image","title":"<code>blur_image(image, sigma)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def blur_image(image, sigma):\n    nchannels = image.shape[2] if image.ndim == 3 else 1\n    if nchannels not in [1, 3]:\n        new_image = np.zeros_like(image)\n        for channeli in range(nchannels):\n            new_image[..., channeli] = blur_image_single(image[..., channeli], sigma)\n    else:\n        new_image = blur_image_single(image, sigma)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.blur_image_single","title":"<code>blur_image_single(image, sigma)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def blur_image_single(image, sigma):\n    return gaussian_filter(image, sigma)\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.calc_fraction_used","title":"<code>calc_fraction_used(image, threshold=0.1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_fraction_used(image: np.ndarray, threshold: float = 0.1) -&gt; float:\n    low = int(round(threshold * 255))\n    high = int(round((1 - threshold) * 255))\n    shape = image.shape\n    total = shape[0] * shape[1]\n    good = 0\n    for y in range(shape[0]):\n        for x in range(shape[1]):\n            pixel = image[y, x]\n            if low &lt;= pixel[0] &lt; high and low &lt;= pixel[1] &lt; high and low &lt;= pixel[2] &lt; high:\n                good += 1\n    fraction = good / total\n    return fraction\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.calc_pyramid","title":"<code>calc_pyramid(xyzct, npyramid_add=0, pyramid_downsample=2, volumetric_resize=False)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_pyramid(xyzct: tuple, npyramid_add: int = 0, pyramid_downsample: float = 2,\n                 volumetric_resize: bool = False) -&gt; list:\n    x, y, z, c, t = xyzct\n    if volumetric_resize and z &gt; 1:\n        size = (x, y, z)\n    else:\n        size = (x, y)\n    sizes_add = []\n    scale = 1\n    for _ in range(npyramid_add):\n        scale /= pyramid_downsample\n        scaled_size = np.maximum(np.round(np.multiply(size, scale)).astype(int), 1)\n        sizes_add.append(scaled_size)\n    return sizes_add\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.calc_tiles_median","title":"<code>calc_tiles_median(images)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_tiles_median(images):\n    out_image = np.zeros_like(images[0])\n    median_image = np.median(images, 0, out_image)\n    return median_image\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.calc_tiles_quantiles","title":"<code>calc_tiles_quantiles(images, quantiles)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_tiles_quantiles(images, quantiles):\n    out_quantiles = []\n    quantile_images = np.quantile(images, quantiles, 0)\n    for quantile_image in quantile_images:\n        maxval = 2 ** (8 * images[0].dtype.itemsize) - 1\n        image = (quantile_image / maxval).astype(np.float32)\n        out_quantiles.append(image)\n    return out_quantiles\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.check_round_significants","title":"<code>check_round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def check_round_significants(a: float, significant_digits: int) -&gt; float:\n    rounded = round_significants(a, significant_digits)\n    if a != 0:\n        dif = 1 - rounded / a\n    else:\n        dif = rounded - a\n    if abs(dif) &lt; 10 ** -significant_digits:\n        return rounded\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.check_versions","title":"<code>check_versions()</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def check_versions():\n    print(f'tifffile {tifffile.__version__}')\n    print(imagecodecs.version())\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.compare_image","title":"<code>compare_image(image0, image1, show=False)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image(image0, image1, show=False) -&gt; float:\n    dif, dif_max, dif_mean, psnr = compare_image_dist(image0, image1)\n    print(f'rgb dist max: {dif_max:.1f} mean: {dif_mean:.1f} PSNR: {psnr:.1f}')\n    if show:\n        show_image(dif)\n        show_image((dif * 10).astype(np.uint8))\n    return dif\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.compare_image_dist","title":"<code>compare_image_dist(image0, image1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image_dist(image0: np.ndarray, image1: np.ndarray) -&gt; tuple:\n    dif = cv.absdiff(image0, image1)\n    psnr = cv.PSNR(image0, image1)\n    if dif.size &gt; 1000000000:\n        # split very large array\n        rgb_maxs = []\n        rgb_means = []\n        for dif1 in np.array_split(dif, 16):\n            rgb_dif = np.linalg.norm(dif1, axis=2)\n            rgb_maxs.append(np.max(rgb_dif))\n            rgb_means.append(np.mean(rgb_dif))\n        rgb_max = np.max(rgb_maxs)\n        rgb_mean = np.mean(rgb_means)\n    else:\n        rgb_dif = np.linalg.norm(dif, axis=2)\n        rgb_max = np.max(rgb_dif)\n        rgb_mean = np.mean(rgb_dif)\n    return dif, rgb_max, rgb_mean, psnr\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.compare_image_dist_simple","title":"<code>compare_image_dist_simple(image0, image1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image_dist_simple(image0: np.ndarray, image1: np.ndarray) -&gt; dict:\n    dif = cv.absdiff(image0, image1)\n    psnr = cv.PSNR(image0, image1)\n    rgb_dif = np.linalg.norm(dif, axis=2)\n    dif_max = np.max(rgb_dif)\n    dif_mean = np.mean(rgb_dif)\n    return {'dif_max': dif_max, 'dif_mean': dif_mean, 'psnr': psnr}\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.convert_image_sign_type","title":"<code>convert_image_sign_type(image, target_dtype)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def convert_image_sign_type(image: np.ndarray, target_dtype: np.dtype) -&gt; np.ndarray:\n    source_dtype = image.dtype\n    if source_dtype.kind == target_dtype.kind:\n        new_image = image\n    elif source_dtype.kind == 'i':\n        new_image = ensure_unsigned_image(image)\n    else:\n        # conversion without overhead\n        offset = 2 ** (8 * target_dtype.itemsize - 1)\n        new_image = (image - offset).astype(target_dtype)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.convert_rational_value","title":"<code>convert_rational_value(value)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def convert_rational_value(value) -&gt; float:\n    if value is not None and isinstance(value, tuple):\n        value = value[0] / value[1]\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.create_compression_codecs","title":"<code>create_compression_codecs(compression)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def create_compression_codecs(compression: list) -&gt; list:\n    codecs = None\n    compression = ensure_list(compression)\n    if compression is not None and len(compression) &gt; 0:\n        compression_type = compression[0].lower()\n        if len(compression) &gt; 1:\n            level = int(compression[1])\n        else:\n            level = None\n        if 'lzw' in compression_type:\n            from imagecodecs.numcodecs import Lzw\n            codecs = [Lzw()]\n        elif '2k' in compression_type or '2000' in compression_type:\n            from imagecodecs.numcodecs import Jpeg2k\n            codecs = [Jpeg2k(level=level)]\n        elif 'jpegls' in compression_type:\n            from imagecodecs.numcodecs import Jpegls\n            codecs = [Jpegls(level=level)]\n        elif 'jpegxr' in compression_type:\n            from imagecodecs.numcodecs import Jpegxr\n            codecs = [Jpegxr(level=level)]\n        elif 'jpegxl' in compression_type:\n            from imagecodecs.numcodecs import Jpegxl\n            codecs = [Jpegxl(level=level)]\n        else:\n            codecs = [compression]\n    return codecs\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.create_compression_filter","title":"<code>create_compression_filter(compression)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def create_compression_filter(compression: list) -&gt; tuple:\n    compressor, compression_filters = None, None\n    compression = ensure_list(compression)\n    if compression is not None and len(compression) &gt; 0:\n        compression_type = compression[0].lower()\n        if len(compression) &gt; 1:\n            level = int(compression[1])\n        else:\n            level = None\n        if 'lzw' in compression_type:\n            from imagecodecs.numcodecs import Lzw\n            compression_filters = [Lzw()]\n        elif '2k' in compression_type or '2000' in compression_type:\n            from imagecodecs.numcodecs import Jpeg2k\n            compression_filters = [Jpeg2k(level=level)]\n        elif 'jpegls' in compression_type:\n            from imagecodecs.numcodecs import Jpegls\n            compression_filters = [Jpegls(level=level)]\n        elif 'jpegxr' in compression_type:\n            from imagecodecs.numcodecs import Jpegxr\n            compression_filters = [Jpegxr(level=level)]\n        elif 'jpegxl' in compression_type:\n            from imagecodecs.numcodecs import Jpegxl\n            compression_filters = [Jpegxl(level=level)]\n        else:\n            compressor = compression\n    return compressor, compression_filters\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.desc_to_dict","title":"<code>desc_to_dict(desc)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def desc_to_dict(desc: str) -&gt; dict:\n    desc_dict = {}\n    if desc.startswith('{'):\n        try:\n            metadata = ast.literal_eval(desc)\n            return metadata\n        except:\n            pass\n    for item in re.split(r'[\\r\\n\\t|]', desc):\n        item_sep = '='\n        if ':' in item:\n            item_sep = ':'\n        if item_sep in item:\n            items = item.split(item_sep)\n            key = items[0].strip()\n            value = items[1].strip()\n            for dtype in (int, float, bool):\n                try:\n                    value = dtype(value)\n                    break\n                except:\n                    pass\n            desc_dict[key] = value\n    return desc_dict\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.ensure_list","title":"<code>ensure_list(x)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def ensure_list(x) -&gt; list:\n    if x is None:\n        return []\n    elif isinstance(x, list):\n        return x\n    else:\n        return [x]\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.ensure_unsigned_image","title":"<code>ensure_unsigned_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def ensure_unsigned_image(image: np.ndarray) -&gt; np.ndarray:\n    source_dtype = image.dtype\n    dtype = ensure_unsigned_type(source_dtype)\n    if dtype != source_dtype:\n        # conversion without overhead\n        offset = 2 ** (8 * dtype.itemsize - 1)\n        new_image = image.astype(dtype) + offset\n    else:\n        new_image = image\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.ensure_unsigned_type","title":"<code>ensure_unsigned_type(dtype)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def ensure_unsigned_type(dtype: np.dtype) -&gt; np.dtype:\n    new_dtype = dtype\n    if dtype.kind == 'i' or dtype.byteorder == '&gt;' or dtype.byteorder == '&lt;':\n        new_dtype = np.dtype(f'u{dtype.itemsize}')\n    return new_dtype\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.file_to_dict","title":"<code>file_to_dict(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def file_to_dict(filename: str) -&gt; dict:\n    ext = os.path.splitext(filename)[1]\n    content = open(filename, 'r').read()\n    if ext == '.xml':\n        data = xmltodict.parse(content)\n    elif ext in ['.yml', '.yaml']:\n        data = yaml.safe_load(content)\n    else:   # assume json\n        data = json.loads(content)\n    return data\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.filter_dict","title":"<code>filter_dict(dict0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def filter_dict(dict0: dict) -&gt; dict:\n    new_dict = {}\n    for key, value0 in dict0.items():\n        if value0 is not None:\n            values = []\n            for value in ensure_list(value0):\n                if isinstance(value, dict):\n                    value = filter_dict(value)\n                values.append(value)\n            if len(values) == 1:\n                values = values[0]\n            new_dict[key] = values\n    return new_dict\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.float2int_image","title":"<code>float2int_image(image, target_dtype=np.dtype(np.uint8))</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def float2int_image(image, target_dtype=np.dtype(np.uint8)):\n    source_dtype = image.dtype\n    if source_dtype.kind not in ('i', 'u') and not target_dtype.kind == 'f':\n        maxval = 2 ** (8 * target_dtype.itemsize) - 1\n        return (image * maxval).astype(target_dtype)\n    else:\n        return image\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.get_default","title":"<code>get_default(x, default)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_default(x, default):\n    return default if x is None else x\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.get_filetitle","title":"<code>get_filetitle(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_filetitle(filename: str) -&gt; str:\n    filebase = os.path.basename(filename)\n    title = os.path.splitext(filebase)[0].rstrip('.ome')\n    return title\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.get_image_quantile","title":"<code>get_image_quantile(image, quantile, axis=None)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_image_quantile(image: np.ndarray, quantile: float, axis=None) -&gt; float:\n    value = np.quantile(image, quantile, axis=axis).astype(image.dtype)\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.get_image_size_info","title":"<code>get_image_size_info(sizes_xyzct, pixel_nbytes, pixel_type, channels)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_image_size_info(sizes_xyzct: list, pixel_nbytes: int, pixel_type: np.dtype, channels: list) -&gt; str:\n    image_size_info = 'XYZCT:'\n    size = 0\n    for i, size_xyzct in enumerate(sizes_xyzct):\n        w, h, zs, cs, ts = size_xyzct\n        size += np.int64(pixel_nbytes) * w * h * zs * cs * ts\n        if i &gt; 0:\n            image_size_info += ','\n        image_size_info += f' {w} {h} {zs} {cs} {ts}'\n    image_size_info += f' Pixel type: {pixel_type} Uncompressed: {print_hbytes(size)}'\n    if sizes_xyzct[0][3] == 3:\n        channel_info = 'rgb'\n    else:\n        channel_info = ','.join([channel.get('Name', '') for channel in channels])\n    if channel_info != '':\n        image_size_info += f' Channels: {channel_info}'\n    return image_size_info\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.get_numpy_slicing","title":"<code>get_numpy_slicing(dimension_order, **slicing)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_numpy_slicing(dimension_order, **slicing):\n    slices = []\n    for axis in dimension_order:\n        index = slicing.get(axis)\n        index0 = slicing.get(axis + '0')\n        index1 = slicing.get(axis + '1')\n        if index0 is not None and index1 is not None:\n            slice1 = slice(int(index0), int(index1))\n        elif index is not None:\n            slice1 = int(index)\n        else:\n            slice1 = slice(None)\n        slices.append(slice1)\n    return tuple(slices)\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.get_pil_metadata","title":"<code>get_pil_metadata(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_pil_metadata(image: PIL.Image) -&gt; dict:\n    metadata = {}\n    exifdata = image.getexif()\n    for tag_id in exifdata:\n        tag = TAGS.get(tag_id, tag_id)\n        data = exifdata.get(tag_id)\n        if isinstance(data, bytes):\n            data = data.decode()\n        metadata[tag] = data\n    if metadata == {}:\n        metadata = image.info\n    return metadata\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.get_tiff_pages","title":"<code>get_tiff_pages(tiff)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_tiff_pages(tiff: TiffFile) -&gt; list:\n    # TODO: review so this works for multi-level ome-tiff, tiff-stack, and z pages tiff, then later check for mmstack\n    pages = []\n    found = False\n    if tiff.series and not tiff.is_mmstack:\n        # has series\n        baseline = tiff.series[0]\n        for level in baseline.levels:\n            # has levels\n            level_pages = []\n            for page in level.pages:\n                found = True\n                level_pages.append(page)\n            if level_pages:\n                pages.append(level_pages)\n\n    if not found:\n        for page in tiff.pages:\n            pages.append(page)\n    return pages\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.get_value_units_micrometer","title":"<code>get_value_units_micrometer(value_units0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_value_units_micrometer(value_units0: list) -&gt; list:\n    conversions = {'nm': 1e-3, '\u00b5m': 1, 'um': 1, 'micrometer': 1, 'mm': 1e3, 'cm': 1e4, 'm': 1e6}\n    if value_units0 is None:\n        return None\n\n    values_um = []\n    for value_unit in value_units0:\n        if not (isinstance(value_unit, int) or isinstance(value_unit, float)):\n            value_um = value_unit[0] * conversions.get(value_unit[1], 1)\n        else:\n            value_um = value_unit\n        values_um.append(value_um)\n    return values_um\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.image_reshape","title":"<code>image_reshape(image, target_size)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def image_reshape(image: np.ndarray, target_size: tuple) -&gt; np.ndarray:\n    tw, th = target_size\n    sh, sw = image.shape[0:2]\n    if sw &lt; tw or sh &lt; th:\n        dw = max(tw - sw, 0)\n        dh = max(th - sh, 0)\n        padding = [(0, dh), (0, dw)]\n        if len(image.shape) == 3:\n            padding += [(0, 0)]\n        image = np.pad(image, padding, 'edge')\n    if tw &lt; sw or th &lt; sh:\n        image = image[0:th, 0:tw]\n    return image\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.image_resize","title":"<code>image_resize(image, target_size0, dimension_order='yxc')</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def image_resize(image: np.ndarray, target_size0: tuple, dimension_order: str = 'yxc') -&gt; np.ndarray:\n    shape = image.shape\n    x_index = dimension_order.index('x')\n    y_index = dimension_order.index('y')\n    c_is_at_end = ('c' in dimension_order and dimension_order.endswith('c'))\n    size = shape[x_index], shape[y_index]\n    if np.mean(np.divide(size, target_size0)) &lt; 1:\n        interpolation = cv.INTER_CUBIC\n    else:\n        interpolation = cv.INTER_AREA\n    dtype0 = image.dtype\n    image = ensure_unsigned_image(image)\n    target_size = tuple(np.maximum(np.round(target_size0).astype(int), 1))\n    if dimension_order in ['yxc', 'yx']:\n        new_image = cv.resize(np.asarray(image), target_size, interpolation=interpolation)\n    elif dimension_order == 'cyx':\n        new_image = np.moveaxis(image, 0, -1)\n        new_image = cv.resize(np.asarray(new_image), target_size, interpolation=interpolation)\n        new_image = np.moveaxis(new_image, -1, 0)\n    else:\n        ts = image.shape[dimension_order.index('t')] if 't' in dimension_order else 1\n        zs = image.shape[dimension_order.index('z')] if 'z' in dimension_order else 1\n        target_shape = list(image.shape).copy()\n        target_shape[x_index] = target_size[0]\n        target_shape[y_index] = target_size[1]\n        new_image = np.zeros(target_shape, dtype=image.dtype)\n        for t in range(ts):\n            for z in range(zs):\n                slices = get_numpy_slicing(dimension_order, z=z, t=t)\n                image1 = image[slices]\n                if not c_is_at_end:\n                    image1 = np.moveaxis(image1, 0, -1)\n                new_image1 = np.atleast_3d(cv.resize(np.asarray(image1), target_size, interpolation=interpolation))\n                if not c_is_at_end:\n                    new_image1 = np.moveaxis(new_image1, -1, 0)\n                new_image[slices] = new_image1\n    new_image = convert_image_sign_type(new_image, dtype0)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.int2float_image","title":"<code>int2float_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def int2float_image(image):\n    source_dtype = image.dtype\n    if not source_dtype.kind == 'f':\n        maxval = 2 ** (8 * source_dtype.itemsize) - 1\n        return image / np.float32(maxval)\n    else:\n        return image\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.normalise_values","title":"<code>normalise_values(image, min_value, max_value)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def normalise_values(image: np.ndarray, min_value: float, max_value: float) -&gt; np.ndarray:\n    return np.clip((image.astype(np.float32) - min_value) / (max_value - min_value), 0, 1)\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.pilmode_to_pixelinfo","title":"<code>pilmode_to_pixelinfo(mode)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def pilmode_to_pixelinfo(mode: str) -&gt; tuple:\n    pixelinfo = (np.uint8, 8, 1)\n    mode_types = {\n        'I': (np.uint32, 32, 1),\n        'F': (np.float32, 32, 1),\n        'RGB': (np.uint8, 24, 3),\n        'RGBA': (np.uint8, 32, 4),\n        'CMYK': (np.uint8, 32, 4),\n        'YCbCr': (np.uint8, 24, 3),\n        'LAB': (np.uint8, 24, 3),\n        'HSV': (np.uint8, 24, 3),\n    }\n    if '16' in mode:\n        pixelinfo = (np.uint16, 16, 1)\n    elif '32' in mode:\n        pixelinfo = (np.uint32, 32, 1)\n    elif mode in mode_types:\n        pixelinfo = mode_types[mode]\n    pixelinfo = (np.dtype(pixelinfo[0]), pixelinfo[1])\n    return pixelinfo\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.precise_resize","title":"<code>precise_resize(image, factors)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def precise_resize(image: np.ndarray, factors) -&gt; np.ndarray:\n    if image.ndim &gt; len(factors):\n        factors = list(factors) + [1]\n    new_image = downscale_local_mean(np.asarray(image), tuple(factors)).astype(image.dtype)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.print_dict","title":"<code>print_dict(dct, indent=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_dict(dct: dict, indent: int = 0) -&gt; str:\n    s = ''\n    if isinstance(dct, dict):\n        for key, value in dct.items():\n            s += '\\n'\n            if not isinstance(value, list):\n                s += '\\t' * indent + str(key) + ': '\n            if isinstance(value, dict):\n                s += print_dict(value, indent=indent + 1)\n            elif isinstance(value, list):\n                for v in value:\n                    s += print_dict(v)\n            else:\n                s += str(value)\n    else:\n        s += str(dct)\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.print_hbytes","title":"<code>print_hbytes(nbytes)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_hbytes(nbytes: int) -&gt; str:\n    exps = ['', 'K', 'M', 'G', 'T']\n    div = 1024\n    exp = 0\n\n    while nbytes &gt; div:\n        nbytes /= div\n        exp += 1\n    return f'{nbytes:.1f}{exps[exp]}B'\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.redimension_data","title":"<code>redimension_data(data, old_order, new_order, **indices)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def redimension_data(data, old_order, new_order, **indices):\n    # able to provide optional dimension values e.g. t=0, z=0\n    if new_order == old_order:\n        return data\n\n    new_data = data\n    order = old_order\n    # remove\n    for o in old_order:\n        if o not in new_order:\n            index = order.index(o)\n            dim_value = indices.get(o, 0)\n            new_data = np.take(new_data, indices=dim_value, axis=index)\n            order = order[:index] + order[index + 1:]\n    # add\n    for o in new_order:\n        if o not in order:\n            new_data = np.expand_dims(new_data, 0)\n            order = o + order\n    # move\n    old_indices = [order.index(o) for o in new_order]\n    new_indices = list(range(len(new_order)))\n    new_data = np.moveaxis(new_data, old_indices, new_indices)\n    return new_data\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.reorder","title":"<code>reorder(items, old_order, new_order, default_value=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def reorder(items: list, old_order: str, new_order: str, default_value: int = 0) -&gt; list:\n    new_items = []\n    for label in new_order:\n        if label in old_order:\n            item = items[old_order.index(label)]\n        else:\n            item = default_value\n        new_items.append(item)\n    return new_items\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.round_significants","title":"<code>round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def round_significants(a: float, significant_digits: int) -&gt; float:\n    if a != 0:\n        round_decimals = significant_digits - int(np.floor(np.log10(abs(a)))) - 1\n        return round(a, round_decimals)\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.save_image","title":"<code>save_image(image, filename, output_params={})</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def save_image(image: np.ndarray, filename: str, output_params: dict = {}):\n    compression = output_params.get('compression')\n    PIL.Image.fromarray(image).save(filename, compression=compression)\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.show_image","title":"<code>show_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def show_image(image: np.ndarray):\n    plt.imshow(image)\n    plt.show()\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.show_image_gray","title":"<code>show_image_gray(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def show_image_gray(image: np.ndarray):\n    plt.imshow(image, cmap='gray')\n    plt.show()\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.split_num_text","title":"<code>split_num_text(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_num_text(text: str) -&gt; list:\n    num_texts = []\n    block = ''\n    is_num0 = None\n    if text is None:\n        return None\n\n    for c in text:\n        is_num = (c.isnumeric() or c == '.')\n        if is_num0 is not None and is_num != is_num0:\n            num_texts.append(block)\n            block = ''\n        block += c\n        is_num0 = is_num\n    if block != '':\n        num_texts.append(block)\n\n    num_texts2 = []\n    for block in num_texts:\n        block = block.strip()\n        try:\n            block = float(block)\n        except:\n            pass\n        if block not in [' ', ',', '|']:\n            num_texts2.append(block)\n    return num_texts2\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.split_value_unit_list","title":"<code>split_value_unit_list(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_value_unit_list(text: str) -&gt; list:\n    value_units = []\n    if text is None:\n        return None\n\n    items = split_num_text(text)\n    if isinstance(items[-1], str):\n        def_unit = items[-1]\n    else:\n        def_unit = ''\n\n    i = 0\n    while i &lt; len(items):\n        value = items[i]\n        if i + 1 &lt; len(items):\n            unit = items[i + 1]\n        else:\n            unit = ''\n        if not isinstance(value, str):\n            if isinstance(unit, str):\n                i += 1\n            else:\n                unit = def_unit\n            value_units.append((value, unit))\n        i += 1\n    return value_units\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.tags_to_dict","title":"<code>tags_to_dict(tags)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tags_to_dict(tags: tifffile.TiffTags) -&gt; dict:\n    tag_dict = {}\n    for tag in tags.values():\n        tag_dict[tag.name] = tag.value\n    return tag_dict\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.tiff_info","title":"<code>tiff_info(filename)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tiff_info(filename: str) -&gt; str:\n    s = ''\n    nom_size = 0\n    tiff = TiffFile(filename)\n    real_size = tiff.fstat.st_size\n    s += str(tiff) + '\\n'\n    if tiff.ome_metadata:\n        print(tiff.ome_metadata)\n        s += f'OME: {print_dict(tifffile.xml2dict(tiff.ome_metadata))}\\n'\n    if tiff.metaseries_metadata:\n        s += f'Series: {tiff.metaseries_metadata}\\n'\n    if tiff.imagej_metadata:\n        s += f'ImageJ: {tiff.imagej_metadata}\\n'\n\n    for page0 in get_tiff_pages(tiff):\n        page = page0[0] if isinstance(page0, list) else page0\n        s += str(page) + '\\n'\n        s += f'Size: {np.flip(page.shape)} ({print_hbytes(page.size)})\\n'\n        if page.is_tiled:\n            s += f'Tiling: {page.tilewidth} {page.tilelength} {page.tiledepth}\\n'\n        s += f'Compression: {str(page.compression)} jpegtables: {page.jpegtables is not None}\\n'\n        tag_dict = tags_to_dict(page.tags)\n        if 'TileOffsets' in tag_dict:\n            tag_dict.pop('TileOffsets')\n        if 'TileByteCounts' in tag_dict:\n            tag_dict.pop('TileByteCounts')\n        if 'ImageDescription' in tag_dict and tag_dict['ImageDescription'].startswith('&lt;?xml'):\n            # redundant\n            tag_dict.pop('ImageDescription')\n        s += print_dict(tag_dict) + '\\n\\n'\n        nom_size += page.size\n\n    s += f'Overall compression: 1:{nom_size / real_size:.1f}'\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.image_util.tiff_info_short","title":"<code>tiff_info_short(filename)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tiff_info_short(filename: str) -&gt; str:\n    nom_size = 0\n    tiff = TiffFile(filename)\n    s = str(filename)\n    real_size = tiff.fstat.st_size\n    for page in tiff.pages:\n        s += ' ' + str(page)\n        nom_size += page.size\n    s += f' Image size:{nom_size} File size:{real_size} Overall compression: 1:{nom_size / real_size:.1f}'\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata","title":"<code>ome_metadata</code>","text":""},{"location":"references/#OmeSliCC.ome_metadata.OME_SCHEMA_LOC","title":"<code>OME_SCHEMA_LOC = f'{OME_URI} {OME_URI}/ome.xsd'</code>  <code>module-attribute</code>","text":""},{"location":"references/#OmeSliCC.ome_metadata.OME_URI","title":"<code>OME_URI = 'http://www.openmicroscopy.org/Schemas/OME/2016-06'</code>  <code>module-attribute</code>","text":""},{"location":"references/#OmeSliCC.ome_metadata.OME_XSI","title":"<code>OME_XSI = 'http://www.w3.org/2001/XMLSchema-instance'</code>  <code>module-attribute</code>","text":""},{"location":"references/#OmeSliCC.ome_metadata.blur_image","title":"<code>blur_image(image, sigma)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def blur_image(image, sigma):\n    nchannels = image.shape[2] if image.ndim == 3 else 1\n    if nchannels not in [1, 3]:\n        new_image = np.zeros_like(image)\n        for channeli in range(nchannels):\n            new_image[..., channeli] = blur_image_single(image[..., channeli], sigma)\n    else:\n        new_image = blur_image_single(image, sigma)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.blur_image_single","title":"<code>blur_image_single(image, sigma)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def blur_image_single(image, sigma):\n    return gaussian_filter(image, sigma)\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.calc_fraction_used","title":"<code>calc_fraction_used(image, threshold=0.1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_fraction_used(image: np.ndarray, threshold: float = 0.1) -&gt; float:\n    low = int(round(threshold * 255))\n    high = int(round((1 - threshold) * 255))\n    shape = image.shape\n    total = shape[0] * shape[1]\n    good = 0\n    for y in range(shape[0]):\n        for x in range(shape[1]):\n            pixel = image[y, x]\n            if low &lt;= pixel[0] &lt; high and low &lt;= pixel[1] &lt; high and low &lt;= pixel[2] &lt; high:\n                good += 1\n    fraction = good / total\n    return fraction\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.calc_pyramid","title":"<code>calc_pyramid(xyzct, npyramid_add=0, pyramid_downsample=2, volumetric_resize=False)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_pyramid(xyzct: tuple, npyramid_add: int = 0, pyramid_downsample: float = 2,\n                 volumetric_resize: bool = False) -&gt; list:\n    x, y, z, c, t = xyzct\n    if volumetric_resize and z &gt; 1:\n        size = (x, y, z)\n    else:\n        size = (x, y)\n    sizes_add = []\n    scale = 1\n    for _ in range(npyramid_add):\n        scale /= pyramid_downsample\n        scaled_size = np.maximum(np.round(np.multiply(size, scale)).astype(int), 1)\n        sizes_add.append(scaled_size)\n    return sizes_add\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.calc_tiles_median","title":"<code>calc_tiles_median(images)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_tiles_median(images):\n    out_image = np.zeros_like(images[0])\n    median_image = np.median(images, 0, out_image)\n    return median_image\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.calc_tiles_quantiles","title":"<code>calc_tiles_quantiles(images, quantiles)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_tiles_quantiles(images, quantiles):\n    out_quantiles = []\n    quantile_images = np.quantile(images, quantiles, 0)\n    for quantile_image in quantile_images:\n        maxval = 2 ** (8 * images[0].dtype.itemsize) - 1\n        image = (quantile_image / maxval).astype(np.float32)\n        out_quantiles.append(image)\n    return out_quantiles\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.check_round_significants","title":"<code>check_round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def check_round_significants(a: float, significant_digits: int) -&gt; float:\n    rounded = round_significants(a, significant_digits)\n    if a != 0:\n        dif = 1 - rounded / a\n    else:\n        dif = rounded - a\n    if abs(dif) &lt; 10 ** -significant_digits:\n        return rounded\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.check_versions","title":"<code>check_versions()</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def check_versions():\n    print(f'tifffile {tifffile.__version__}')\n    print(imagecodecs.version())\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.compare_image","title":"<code>compare_image(image0, image1, show=False)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image(image0, image1, show=False) -&gt; float:\n    dif, dif_max, dif_mean, psnr = compare_image_dist(image0, image1)\n    print(f'rgb dist max: {dif_max:.1f} mean: {dif_mean:.1f} PSNR: {psnr:.1f}')\n    if show:\n        show_image(dif)\n        show_image((dif * 10).astype(np.uint8))\n    return dif\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.compare_image_dist","title":"<code>compare_image_dist(image0, image1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image_dist(image0: np.ndarray, image1: np.ndarray) -&gt; tuple:\n    dif = cv.absdiff(image0, image1)\n    psnr = cv.PSNR(image0, image1)\n    if dif.size &gt; 1000000000:\n        # split very large array\n        rgb_maxs = []\n        rgb_means = []\n        for dif1 in np.array_split(dif, 16):\n            rgb_dif = np.linalg.norm(dif1, axis=2)\n            rgb_maxs.append(np.max(rgb_dif))\n            rgb_means.append(np.mean(rgb_dif))\n        rgb_max = np.max(rgb_maxs)\n        rgb_mean = np.mean(rgb_means)\n    else:\n        rgb_dif = np.linalg.norm(dif, axis=2)\n        rgb_max = np.max(rgb_dif)\n        rgb_mean = np.mean(rgb_dif)\n    return dif, rgb_max, rgb_mean, psnr\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.compare_image_dist_simple","title":"<code>compare_image_dist_simple(image0, image1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image_dist_simple(image0: np.ndarray, image1: np.ndarray) -&gt; dict:\n    dif = cv.absdiff(image0, image1)\n    psnr = cv.PSNR(image0, image1)\n    rgb_dif = np.linalg.norm(dif, axis=2)\n    dif_max = np.max(rgb_dif)\n    dif_mean = np.mean(rgb_dif)\n    return {'dif_max': dif_max, 'dif_mean': dif_mean, 'psnr': psnr}\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.convert_image_sign_type","title":"<code>convert_image_sign_type(image, target_dtype)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def convert_image_sign_type(image: np.ndarray, target_dtype: np.dtype) -&gt; np.ndarray:\n    source_dtype = image.dtype\n    if source_dtype.kind == target_dtype.kind:\n        new_image = image\n    elif source_dtype.kind == 'i':\n        new_image = ensure_unsigned_image(image)\n    else:\n        # conversion without overhead\n        offset = 2 ** (8 * target_dtype.itemsize - 1)\n        new_image = (image - offset).astype(target_dtype)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.convert_rational_value","title":"<code>convert_rational_value(value)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def convert_rational_value(value) -&gt; float:\n    if value is not None and isinstance(value, tuple):\n        value = value[0] / value[1]\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.create_compression_codecs","title":"<code>create_compression_codecs(compression)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def create_compression_codecs(compression: list) -&gt; list:\n    codecs = None\n    compression = ensure_list(compression)\n    if compression is not None and len(compression) &gt; 0:\n        compression_type = compression[0].lower()\n        if len(compression) &gt; 1:\n            level = int(compression[1])\n        else:\n            level = None\n        if 'lzw' in compression_type:\n            from imagecodecs.numcodecs import Lzw\n            codecs = [Lzw()]\n        elif '2k' in compression_type or '2000' in compression_type:\n            from imagecodecs.numcodecs import Jpeg2k\n            codecs = [Jpeg2k(level=level)]\n        elif 'jpegls' in compression_type:\n            from imagecodecs.numcodecs import Jpegls\n            codecs = [Jpegls(level=level)]\n        elif 'jpegxr' in compression_type:\n            from imagecodecs.numcodecs import Jpegxr\n            codecs = [Jpegxr(level=level)]\n        elif 'jpegxl' in compression_type:\n            from imagecodecs.numcodecs import Jpegxl\n            codecs = [Jpegxl(level=level)]\n        else:\n            codecs = [compression]\n    return codecs\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.create_compression_filter","title":"<code>create_compression_filter(compression)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def create_compression_filter(compression: list) -&gt; tuple:\n    compressor, compression_filters = None, None\n    compression = ensure_list(compression)\n    if compression is not None and len(compression) &gt; 0:\n        compression_type = compression[0].lower()\n        if len(compression) &gt; 1:\n            level = int(compression[1])\n        else:\n            level = None\n        if 'lzw' in compression_type:\n            from imagecodecs.numcodecs import Lzw\n            compression_filters = [Lzw()]\n        elif '2k' in compression_type or '2000' in compression_type:\n            from imagecodecs.numcodecs import Jpeg2k\n            compression_filters = [Jpeg2k(level=level)]\n        elif 'jpegls' in compression_type:\n            from imagecodecs.numcodecs import Jpegls\n            compression_filters = [Jpegls(level=level)]\n        elif 'jpegxr' in compression_type:\n            from imagecodecs.numcodecs import Jpegxr\n            compression_filters = [Jpegxr(level=level)]\n        elif 'jpegxl' in compression_type:\n            from imagecodecs.numcodecs import Jpegxl\n            compression_filters = [Jpegxl(level=level)]\n        else:\n            compressor = compression\n    return compressor, compression_filters\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.create_ome_metadata","title":"<code>create_ome_metadata(source, output_filename, combine_rgb=True, pyramid_sizes_add=[])</code>","text":"Source code in <code>OmeSliCC\\ome_metadata.py</code> <pre><code>def create_ome_metadata(source: OmeSource,\n                        output_filename: str,\n                        combine_rgb: bool = True,\n                        pyramid_sizes_add: list = []) -&gt; str:\n\n    file_name = os.path.basename(output_filename)\n    file_title = get_filetitle(file_name)\n    uuid = f'urn:uuid:{uuid4()}'\n    software_name = toml.load(\"pyproject.toml\")[\"project\"][\"name\"]\n    software_version = toml.load(\"pyproject.toml\")[\"project\"][\"version\"]\n\n    ome = source.get_metadata().copy() if source.has_ome_metadata else XmlDict()\n    ome['@xmlns'] = OME_URI\n    ome['@xmlns:xsi'] = OME_XSI\n    ome['@xsi:schemaLocation'] = OME_SCHEMA_LOC\n    ome['@UUID'] = uuid\n    ome['@Creator'] = f'{software_name} {software_version}'\n\n    experimenter = ome.get('Experimenter')\n\n    mag = source.get_mag()\n    instrument = ome.get('Instrument')\n    objective = ome.get('Instrument', {}).get('Objective')\n    if isinstance(objective, list):\n        objective = objective[0]\n    if mag != 0:\n        if instrument is None:\n            instrument = {'@ID': 'Instrument:0'}\n        if objective is None:\n            objective = {'@ID': 'Objective:0'}\n            instrument['Objective'] = objective\n        objective['@NominalMagnification'] = mag\n        ome['Instrument'] = instrument\n\n    # currently only supporting single image\n    nimages = 1\n\n    images = []\n    for imagei in range(nimages):\n        images0 = ensure_list(ome.get('Image', []))\n        if len(images0) &gt; 0:\n            image0 = images0[imagei]\n        else:\n            image0 = {}\n        pixels0 = image0.get('Pixels', {})\n\n        nchannels = source.get_nchannels()\n        channels0 = source.get_channels()\n        n = len(channels0)\n        samples_per_pixel = nchannels // n\n\n        channels = []\n        for channeli, channel0 in enumerate(channels0):\n            channel = XmlDict({'@Name': channel0.get('label', ''),\n                               '@SamplesPerPixel': samples_per_pixel})\n            color = channel0.get('color')\n            if color:\n                channel['@Color'] = rgba_to_int(color)\n            channels.append(channel)\n\n        if combine_rgb and len(channels) == 3:\n            channel = channels[0].copy()\n            channel['@SamplesPerPixel'] = nchannels\n            channel.pop('@Color', None)\n            channels = [channel]\n        elif not combine_rgb and len(channels) &lt; nchannels:\n            channel = channels[0].copy()\n            if '@Color' in channel:\n                channel['@Color'] = rgba_to_int(channel['@Color'])\n            channel['@SamplesPerPixel'] = 1\n            channels = [channel] * nchannels\n\n        for channeli, channel in enumerate(channels):\n            channel['@ID'] = f'Channel:{imagei}:{channeli}'\n\n        image = {\n            '@ID': f'Image:{imagei}',\n            '@Name': file_title,\n        }\n\n        xyzct = source.get_size_xyzct()\n        pixels = {\n            '@ID': f'Pixels:{imagei}',\n            '@SizeX': xyzct[0],\n            '@SizeY': xyzct[1],\n            '@SizeZ': xyzct[2],\n            '@SizeC': nchannels,\n            '@SizeT': xyzct[4],\n            '@Type': str(ensure_unsigned_type(source.get_pixel_type())),\n            '@DimensionOrder': 'XYZCT',\n            'Channel': channels,\n            'TiffData': {'UUID': {'@FileName': file_name, '#text': uuid}},\n        }\n\n        pixel_size = source.get_pixel_size()\n        if len(pixel_size) &gt; 0 and pixel_size[0][0] != 0:\n            pixels['@PhysicalSizeX'] = pixel_size[0][0]\n        if len(pixel_size) &gt; 1 and pixel_size[1][0] != 0:\n            pixels['@PhysicalSizeY'] = pixel_size[1][0]\n        if len(pixel_size) &gt; 2 and pixel_size[2][0] != 0:\n            pixels['@PhysicalSizeZ'] = pixel_size[2][0]\n        if len(pixel_size) &gt; 0 and pixel_size[0][1] != '':\n            pixels['@PhysicalSizeXUnit'] = pixel_size[0][1]\n        if len(pixel_size) &gt; 1 and pixel_size[1][1] != '':\n            pixels['@PhysicalSizeYUnit'] = pixel_size[1][1]\n        if len(pixel_size) &gt; 2 and pixel_size[2][1] != '':\n            pixels['@PhysicalSizeZUnit'] = pixel_size[2][1]\n\n        # TODO: create plane metadata if not exists\n        planes = ensure_list(pixels0.get('Plane', []))\n        if len(planes) &gt; 0:\n            pixels['Plane'] = planes\n\n        if 'AcquisitionDate' in image0:\n            image['AcquisitionDate'] = image0['AcquisitionDate']\n        if 'Description' in image0:\n            image['Description'] = image0['Description']\n        # Set image refs\n        if experimenter:\n            image['ExperimenterRef'] = {'@ID': experimenter['@ID']}\n        if instrument:\n            image['InstrumentRef'] = {'@ID': instrument['@ID']}\n        if objective:\n            image['ObjectiveSettings'] = {'@ID': objective['@ID']}\n        # (end image refs)\n        if 'StageLabel' in image0:\n            image['StageLabel'] = image0['StageLabel']\n        image['Pixels'] = pixels\n        images.append(image)\n\n    ome['Image'] = images\n\n    if 'StructuredAnnotations' not in ome:\n        ome['StructuredAnnotations'] = {}\n\n    # filter source pyramid sizes\n    map_annotations0 = ensure_list(ome['StructuredAnnotations'].get('MapAnnotation', []))\n    map_annotations = [annotation for annotation in map_annotations0\n                       if 'resolution' not in annotation.get('ID', '').lower()]\n    # add pyramid sizes\n    if pyramid_sizes_add:\n        key_value_map = {'M': [{'@K': i + 1, '#text': f'{\" \".join([str(size) for size in pyramid_size])}'}\n                               for i, pyramid_size in enumerate(pyramid_sizes_add)]}\n        map_annotations.insert(0, {\n            '@ID': 'Annotation:Resolution:0',\n            '@Namespace': 'openmicroscopy.org/PyramidResolution',\n            'Value': key_value_map\n        })\n    ome['StructuredAnnotations']['MapAnnotation'] = map_annotations\n\n    # filter original metadata elements\n    xml_annotations0 = ensure_list(ome.get('StructuredAnnotations', {}).get('XMLAnnotation', []))\n    xml_annotations = [annotation for annotation in xml_annotations0\n                       if 'originalmetadata' not in annotation.get('Namespace', '').lower()]\n    ome['StructuredAnnotations']['XMLAnnotation'] = xml_annotations\n\n    return dict2xml({'OME': ome})\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.desc_to_dict","title":"<code>desc_to_dict(desc)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def desc_to_dict(desc: str) -&gt; dict:\n    desc_dict = {}\n    if desc.startswith('{'):\n        try:\n            metadata = ast.literal_eval(desc)\n            return metadata\n        except:\n            pass\n    for item in re.split(r'[\\r\\n\\t|]', desc):\n        item_sep = '='\n        if ':' in item:\n            item_sep = ':'\n        if item_sep in item:\n            items = item.split(item_sep)\n            key = items[0].strip()\n            value = items[1].strip()\n            for dtype in (int, float, bool):\n                try:\n                    value = dtype(value)\n                    break\n                except:\n                    pass\n            desc_dict[key] = value\n    return desc_dict\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.ensure_list","title":"<code>ensure_list(x)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def ensure_list(x) -&gt; list:\n    if x is None:\n        return []\n    elif isinstance(x, list):\n        return x\n    else:\n        return [x]\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.ensure_unsigned_image","title":"<code>ensure_unsigned_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def ensure_unsigned_image(image: np.ndarray) -&gt; np.ndarray:\n    source_dtype = image.dtype\n    dtype = ensure_unsigned_type(source_dtype)\n    if dtype != source_dtype:\n        # conversion without overhead\n        offset = 2 ** (8 * dtype.itemsize - 1)\n        new_image = image.astype(dtype) + offset\n    else:\n        new_image = image\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.ensure_unsigned_type","title":"<code>ensure_unsigned_type(dtype)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def ensure_unsigned_type(dtype: np.dtype) -&gt; np.dtype:\n    new_dtype = dtype\n    if dtype.kind == 'i' or dtype.byteorder == '&gt;' or dtype.byteorder == '&lt;':\n        new_dtype = np.dtype(f'u{dtype.itemsize}')\n    return new_dtype\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.file_to_dict","title":"<code>file_to_dict(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def file_to_dict(filename: str) -&gt; dict:\n    ext = os.path.splitext(filename)[1]\n    content = open(filename, 'r').read()\n    if ext == '.xml':\n        data = xmltodict.parse(content)\n    elif ext in ['.yml', '.yaml']:\n        data = yaml.safe_load(content)\n    else:   # assume json\n        data = json.loads(content)\n    return data\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.filter_dict","title":"<code>filter_dict(dict0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def filter_dict(dict0: dict) -&gt; dict:\n    new_dict = {}\n    for key, value0 in dict0.items():\n        if value0 is not None:\n            values = []\n            for value in ensure_list(value0):\n                if isinstance(value, dict):\n                    value = filter_dict(value)\n                values.append(value)\n            if len(values) == 1:\n                values = values[0]\n            new_dict[key] = values\n    return new_dict\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.float2int_image","title":"<code>float2int_image(image, target_dtype=np.dtype(np.uint8))</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def float2int_image(image, target_dtype=np.dtype(np.uint8)):\n    source_dtype = image.dtype\n    if source_dtype.kind not in ('i', 'u') and not target_dtype.kind == 'f':\n        maxval = 2 ** (8 * target_dtype.itemsize) - 1\n        return (image * maxval).astype(target_dtype)\n    else:\n        return image\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.get_default","title":"<code>get_default(x, default)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_default(x, default):\n    return default if x is None else x\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.get_filetitle","title":"<code>get_filetitle(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_filetitle(filename: str) -&gt; str:\n    filebase = os.path.basename(filename)\n    title = os.path.splitext(filebase)[0].rstrip('.ome')\n    return title\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.get_image_quantile","title":"<code>get_image_quantile(image, quantile, axis=None)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_image_quantile(image: np.ndarray, quantile: float, axis=None) -&gt; float:\n    value = np.quantile(image, quantile, axis=axis).astype(image.dtype)\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.get_image_size_info","title":"<code>get_image_size_info(sizes_xyzct, pixel_nbytes, pixel_type, channels)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_image_size_info(sizes_xyzct: list, pixel_nbytes: int, pixel_type: np.dtype, channels: list) -&gt; str:\n    image_size_info = 'XYZCT:'\n    size = 0\n    for i, size_xyzct in enumerate(sizes_xyzct):\n        w, h, zs, cs, ts = size_xyzct\n        size += np.int64(pixel_nbytes) * w * h * zs * cs * ts\n        if i &gt; 0:\n            image_size_info += ','\n        image_size_info += f' {w} {h} {zs} {cs} {ts}'\n    image_size_info += f' Pixel type: {pixel_type} Uncompressed: {print_hbytes(size)}'\n    if sizes_xyzct[0][3] == 3:\n        channel_info = 'rgb'\n    else:\n        channel_info = ','.join([channel.get('Name', '') for channel in channels])\n    if channel_info != '':\n        image_size_info += f' Channels: {channel_info}'\n    return image_size_info\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.get_numpy_slicing","title":"<code>get_numpy_slicing(dimension_order, **slicing)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_numpy_slicing(dimension_order, **slicing):\n    slices = []\n    for axis in dimension_order:\n        index = slicing.get(axis)\n        index0 = slicing.get(axis + '0')\n        index1 = slicing.get(axis + '1')\n        if index0 is not None and index1 is not None:\n            slice1 = slice(int(index0), int(index1))\n        elif index is not None:\n            slice1 = int(index)\n        else:\n            slice1 = slice(None)\n        slices.append(slice1)\n    return tuple(slices)\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.get_pil_metadata","title":"<code>get_pil_metadata(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_pil_metadata(image: PIL.Image) -&gt; dict:\n    metadata = {}\n    exifdata = image.getexif()\n    for tag_id in exifdata:\n        tag = TAGS.get(tag_id, tag_id)\n        data = exifdata.get(tag_id)\n        if isinstance(data, bytes):\n            data = data.decode()\n        metadata[tag] = data\n    if metadata == {}:\n        metadata = image.info\n    return metadata\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.get_tiff_pages","title":"<code>get_tiff_pages(tiff)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_tiff_pages(tiff: TiffFile) -&gt; list:\n    # TODO: review so this works for multi-level ome-tiff, tiff-stack, and z pages tiff, then later check for mmstack\n    pages = []\n    found = False\n    if tiff.series and not tiff.is_mmstack:\n        # has series\n        baseline = tiff.series[0]\n        for level in baseline.levels:\n            # has levels\n            level_pages = []\n            for page in level.pages:\n                found = True\n                level_pages.append(page)\n            if level_pages:\n                pages.append(level_pages)\n\n    if not found:\n        for page in tiff.pages:\n            pages.append(page)\n    return pages\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.get_value_units_micrometer","title":"<code>get_value_units_micrometer(value_units0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_value_units_micrometer(value_units0: list) -&gt; list:\n    conversions = {'nm': 1e-3, '\u00b5m': 1, 'um': 1, 'micrometer': 1, 'mm': 1e3, 'cm': 1e4, 'm': 1e6}\n    if value_units0 is None:\n        return None\n\n    values_um = []\n    for value_unit in value_units0:\n        if not (isinstance(value_unit, int) or isinstance(value_unit, float)):\n            value_um = value_unit[0] * conversions.get(value_unit[1], 1)\n        else:\n            value_um = value_unit\n        values_um.append(value_um)\n    return values_um\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.hexrgb_to_rgba","title":"<code>hexrgb_to_rgba(hexrgb)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def hexrgb_to_rgba(hexrgb: str) -&gt; list:\n    rgba = int_to_rgba(eval('0x' + hexrgb + 'FF'))\n    return rgba\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.image_reshape","title":"<code>image_reshape(image, target_size)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def image_reshape(image: np.ndarray, target_size: tuple) -&gt; np.ndarray:\n    tw, th = target_size\n    sh, sw = image.shape[0:2]\n    if sw &lt; tw or sh &lt; th:\n        dw = max(tw - sw, 0)\n        dh = max(th - sh, 0)\n        padding = [(0, dh), (0, dw)]\n        if len(image.shape) == 3:\n            padding += [(0, 0)]\n        image = np.pad(image, padding, 'edge')\n    if tw &lt; sw or th &lt; sh:\n        image = image[0:th, 0:tw]\n    return image\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.image_resize","title":"<code>image_resize(image, target_size0, dimension_order='yxc')</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def image_resize(image: np.ndarray, target_size0: tuple, dimension_order: str = 'yxc') -&gt; np.ndarray:\n    shape = image.shape\n    x_index = dimension_order.index('x')\n    y_index = dimension_order.index('y')\n    c_is_at_end = ('c' in dimension_order and dimension_order.endswith('c'))\n    size = shape[x_index], shape[y_index]\n    if np.mean(np.divide(size, target_size0)) &lt; 1:\n        interpolation = cv.INTER_CUBIC\n    else:\n        interpolation = cv.INTER_AREA\n    dtype0 = image.dtype\n    image = ensure_unsigned_image(image)\n    target_size = tuple(np.maximum(np.round(target_size0).astype(int), 1))\n    if dimension_order in ['yxc', 'yx']:\n        new_image = cv.resize(np.asarray(image), target_size, interpolation=interpolation)\n    elif dimension_order == 'cyx':\n        new_image = np.moveaxis(image, 0, -1)\n        new_image = cv.resize(np.asarray(new_image), target_size, interpolation=interpolation)\n        new_image = np.moveaxis(new_image, -1, 0)\n    else:\n        ts = image.shape[dimension_order.index('t')] if 't' in dimension_order else 1\n        zs = image.shape[dimension_order.index('z')] if 'z' in dimension_order else 1\n        target_shape = list(image.shape).copy()\n        target_shape[x_index] = target_size[0]\n        target_shape[y_index] = target_size[1]\n        new_image = np.zeros(target_shape, dtype=image.dtype)\n        for t in range(ts):\n            for z in range(zs):\n                slices = get_numpy_slicing(dimension_order, z=z, t=t)\n                image1 = image[slices]\n                if not c_is_at_end:\n                    image1 = np.moveaxis(image1, 0, -1)\n                new_image1 = np.atleast_3d(cv.resize(np.asarray(image1), target_size, interpolation=interpolation))\n                if not c_is_at_end:\n                    new_image1 = np.moveaxis(new_image1, -1, 0)\n                new_image[slices] = new_image1\n    new_image = convert_image_sign_type(new_image, dtype0)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.int2float_image","title":"<code>int2float_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def int2float_image(image):\n    source_dtype = image.dtype\n    if not source_dtype.kind == 'f':\n        maxval = 2 ** (8 * source_dtype.itemsize) - 1\n        return image / np.float32(maxval)\n    else:\n        return image\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.int_to_rgba","title":"<code>int_to_rgba(intrgba)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def int_to_rgba(intrgba: int) -&gt; list:\n    signed = (intrgba &lt; 0)\n    rgba = [x / 255 for x in intrgba.to_bytes(4, signed=signed, byteorder=\"big\")]\n    if rgba[-1] == 0:\n        rgba[-1] = 1\n    return rgba\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.normalise_values","title":"<code>normalise_values(image, min_value, max_value)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def normalise_values(image: np.ndarray, min_value: float, max_value: float) -&gt; np.ndarray:\n    return np.clip((image.astype(np.float32) - min_value) / (max_value - min_value), 0, 1)\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.pilmode_to_pixelinfo","title":"<code>pilmode_to_pixelinfo(mode)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def pilmode_to_pixelinfo(mode: str) -&gt; tuple:\n    pixelinfo = (np.uint8, 8, 1)\n    mode_types = {\n        'I': (np.uint32, 32, 1),\n        'F': (np.float32, 32, 1),\n        'RGB': (np.uint8, 24, 3),\n        'RGBA': (np.uint8, 32, 4),\n        'CMYK': (np.uint8, 32, 4),\n        'YCbCr': (np.uint8, 24, 3),\n        'LAB': (np.uint8, 24, 3),\n        'HSV': (np.uint8, 24, 3),\n    }\n    if '16' in mode:\n        pixelinfo = (np.uint16, 16, 1)\n    elif '32' in mode:\n        pixelinfo = (np.uint32, 32, 1)\n    elif mode in mode_types:\n        pixelinfo = mode_types[mode]\n    pixelinfo = (np.dtype(pixelinfo[0]), pixelinfo[1])\n    return pixelinfo\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.precise_resize","title":"<code>precise_resize(image, factors)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def precise_resize(image: np.ndarray, factors) -&gt; np.ndarray:\n    if image.ndim &gt; len(factors):\n        factors = list(factors) + [1]\n    new_image = downscale_local_mean(np.asarray(image), tuple(factors)).astype(image.dtype)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.print_dict","title":"<code>print_dict(dct, indent=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_dict(dct: dict, indent: int = 0) -&gt; str:\n    s = ''\n    if isinstance(dct, dict):\n        for key, value in dct.items():\n            s += '\\n'\n            if not isinstance(value, list):\n                s += '\\t' * indent + str(key) + ': '\n            if isinstance(value, dict):\n                s += print_dict(value, indent=indent + 1)\n            elif isinstance(value, list):\n                for v in value:\n                    s += print_dict(v)\n            else:\n                s += str(value)\n    else:\n        s += str(dct)\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.print_hbytes","title":"<code>print_hbytes(nbytes)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_hbytes(nbytes: int) -&gt; str:\n    exps = ['', 'K', 'M', 'G', 'T']\n    div = 1024\n    exp = 0\n\n    while nbytes &gt; div:\n        nbytes /= div\n        exp += 1\n    return f'{nbytes:.1f}{exps[exp]}B'\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.redimension_data","title":"<code>redimension_data(data, old_order, new_order, **indices)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def redimension_data(data, old_order, new_order, **indices):\n    # able to provide optional dimension values e.g. t=0, z=0\n    if new_order == old_order:\n        return data\n\n    new_data = data\n    order = old_order\n    # remove\n    for o in old_order:\n        if o not in new_order:\n            index = order.index(o)\n            dim_value = indices.get(o, 0)\n            new_data = np.take(new_data, indices=dim_value, axis=index)\n            order = order[:index] + order[index + 1:]\n    # add\n    for o in new_order:\n        if o not in order:\n            new_data = np.expand_dims(new_data, 0)\n            order = o + order\n    # move\n    old_indices = [order.index(o) for o in new_order]\n    new_indices = list(range(len(new_order)))\n    new_data = np.moveaxis(new_data, old_indices, new_indices)\n    return new_data\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.reorder","title":"<code>reorder(items, old_order, new_order, default_value=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def reorder(items: list, old_order: str, new_order: str, default_value: int = 0) -&gt; list:\n    new_items = []\n    for label in new_order:\n        if label in old_order:\n            item = items[old_order.index(label)]\n        else:\n            item = default_value\n        new_items.append(item)\n    return new_items\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.rgba_to_hexrgb","title":"<code>rgba_to_hexrgb(rgba)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def rgba_to_hexrgb(rgba: list) -&gt; str:\n    hexrgb = ''.join([hex(int(x * 255))[2:].upper().zfill(2) for x in rgba[:3]])\n    return hexrgb\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.rgba_to_int","title":"<code>rgba_to_int(rgba)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def rgba_to_int(rgba: list) -&gt; int:\n    intrgba = int.from_bytes([int(x * 255) for x in rgba], signed=True, byteorder=\"big\")\n    return intrgba\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.round_significants","title":"<code>round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def round_significants(a: float, significant_digits: int) -&gt; float:\n    if a != 0:\n        round_decimals = significant_digits - int(np.floor(np.log10(abs(a)))) - 1\n        return round(a, round_decimals)\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.save_image","title":"<code>save_image(image, filename, output_params={})</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def save_image(image: np.ndarray, filename: str, output_params: dict = {}):\n    compression = output_params.get('compression')\n    PIL.Image.fromarray(image).save(filename, compression=compression)\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.show_image","title":"<code>show_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def show_image(image: np.ndarray):\n    plt.imshow(image)\n    plt.show()\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.show_image_gray","title":"<code>show_image_gray(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def show_image_gray(image: np.ndarray):\n    plt.imshow(image, cmap='gray')\n    plt.show()\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.split_num_text","title":"<code>split_num_text(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_num_text(text: str) -&gt; list:\n    num_texts = []\n    block = ''\n    is_num0 = None\n    if text is None:\n        return None\n\n    for c in text:\n        is_num = (c.isnumeric() or c == '.')\n        if is_num0 is not None and is_num != is_num0:\n            num_texts.append(block)\n            block = ''\n        block += c\n        is_num0 = is_num\n    if block != '':\n        num_texts.append(block)\n\n    num_texts2 = []\n    for block in num_texts:\n        block = block.strip()\n        try:\n            block = float(block)\n        except:\n            pass\n        if block not in [' ', ',', '|']:\n            num_texts2.append(block)\n    return num_texts2\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.split_value_unit_list","title":"<code>split_value_unit_list(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_value_unit_list(text: str) -&gt; list:\n    value_units = []\n    if text is None:\n        return None\n\n    items = split_num_text(text)\n    if isinstance(items[-1], str):\n        def_unit = items[-1]\n    else:\n        def_unit = ''\n\n    i = 0\n    while i &lt; len(items):\n        value = items[i]\n        if i + 1 &lt; len(items):\n            unit = items[i + 1]\n        else:\n            unit = ''\n        if not isinstance(value, str):\n            if isinstance(unit, str):\n                i += 1\n            else:\n                unit = def_unit\n            value_units.append((value, unit))\n        i += 1\n    return value_units\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.tags_to_dict","title":"<code>tags_to_dict(tags)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tags_to_dict(tags: tifffile.TiffTags) -&gt; dict:\n    tag_dict = {}\n    for tag in tags.values():\n        tag_dict[tag.name] = tag.value\n    return tag_dict\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.tiff_info","title":"<code>tiff_info(filename)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tiff_info(filename: str) -&gt; str:\n    s = ''\n    nom_size = 0\n    tiff = TiffFile(filename)\n    real_size = tiff.fstat.st_size\n    s += str(tiff) + '\\n'\n    if tiff.ome_metadata:\n        print(tiff.ome_metadata)\n        s += f'OME: {print_dict(tifffile.xml2dict(tiff.ome_metadata))}\\n'\n    if tiff.metaseries_metadata:\n        s += f'Series: {tiff.metaseries_metadata}\\n'\n    if tiff.imagej_metadata:\n        s += f'ImageJ: {tiff.imagej_metadata}\\n'\n\n    for page0 in get_tiff_pages(tiff):\n        page = page0[0] if isinstance(page0, list) else page0\n        s += str(page) + '\\n'\n        s += f'Size: {np.flip(page.shape)} ({print_hbytes(page.size)})\\n'\n        if page.is_tiled:\n            s += f'Tiling: {page.tilewidth} {page.tilelength} {page.tiledepth}\\n'\n        s += f'Compression: {str(page.compression)} jpegtables: {page.jpegtables is not None}\\n'\n        tag_dict = tags_to_dict(page.tags)\n        if 'TileOffsets' in tag_dict:\n            tag_dict.pop('TileOffsets')\n        if 'TileByteCounts' in tag_dict:\n            tag_dict.pop('TileByteCounts')\n        if 'ImageDescription' in tag_dict and tag_dict['ImageDescription'].startswith('&lt;?xml'):\n            # redundant\n            tag_dict.pop('ImageDescription')\n        s += print_dict(tag_dict) + '\\n\\n'\n        nom_size += page.size\n\n    s += f'Overall compression: 1:{nom_size / real_size:.1f}'\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.ome_metadata.tiff_info_short","title":"<code>tiff_info_short(filename)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tiff_info_short(filename: str) -&gt; str:\n    nom_size = 0\n    tiff = TiffFile(filename)\n    s = str(filename)\n    real_size = tiff.fstat.st_size\n    for page in tiff.pages:\n        s += ' ' + str(page)\n        nom_size += page.size\n    s += f' Image size:{nom_size} File size:{real_size} Overall compression: 1:{nom_size / real_size:.1f}'\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.ome_zarr_util","title":"<code>ome_zarr_util</code>","text":""},{"location":"references/#OmeSliCC.ome_zarr_util.create_axes_metadata","title":"<code>create_axes_metadata(dimension_order)</code>","text":"Source code in <code>OmeSliCC\\ome_zarr_util.py</code> <pre><code>def create_axes_metadata(dimension_order):\n    axes = []\n    for dimension in dimension_order:\n        unit1 = None\n        if dimension == 't':\n            type1 = 'time'\n            unit1 = 'millisecond'\n        elif dimension == 'c':\n            type1 = 'channel'\n        else:\n            type1 = 'space'\n            unit1 = 'micrometer'\n        axis = {'name': dimension, 'type': type1}\n        if unit1 is not None and unit1 != '':\n            axis['unit'] = unit1\n        axes.append(axis)\n    return axes\n</code></pre>"},{"location":"references/#OmeSliCC.ome_zarr_util.create_channel_metadata","title":"<code>create_channel_metadata(source, ome_version)</code>","text":"Source code in <code>OmeSliCC\\ome_zarr_util.py</code> <pre><code>def create_channel_metadata(source, ome_version):\n    channels = source.get_channels()\n    nchannels = source.get_nchannels()\n\n    if len(channels) &lt; nchannels == 3:\n        labels = ['Red', 'Green', 'Blue']\n        colors = [(1, 0, 0, 1), (0, 1, 0, 1), (0, 0, 1, 1)]\n        channels = [{'label': label, 'color': color} for label, color in zip(labels, colors)]\n\n    omezarr_channels = []\n    for channeli, channel0 in enumerate(channels):\n        channel = channel0.copy()\n        color = channel.get('color', (1, 1, 1, 1))\n        channel['color'] = rgba_to_hexrgb(color)\n        if 'window' not in channel:\n            channel['window'] = source.get_channel_window(channeli)\n        omezarr_channels.append(channel)\n\n    metadata = {\n        'version': ome_version,\n        'channels': omezarr_channels,\n    }\n    return metadata\n</code></pre>"},{"location":"references/#OmeSliCC.ome_zarr_util.create_transformation_metadata","title":"<code>create_transformation_metadata(dimension_order, pixel_size_um, scale, translation_um=[])</code>","text":"Source code in <code>OmeSliCC\\ome_zarr_util.py</code> <pre><code>def create_transformation_metadata(dimension_order, pixel_size_um, scale, translation_um=[]):\n    metadata = []\n    pixel_size_scale = []\n    translation_scale = []\n    for dimension in dimension_order:\n        if dimension == 'z' and len(pixel_size_um) &gt; 2:\n            pixel_size_scale1 = pixel_size_um[2]\n        elif dimension == 'y' and len(pixel_size_um) &gt; 1:\n            pixel_size_scale1 = pixel_size_um[1] / scale\n        elif dimension == 'x' and len(pixel_size_um) &gt; 0:\n            pixel_size_scale1 = pixel_size_um[0] / scale\n        else:\n            pixel_size_scale1 = 1\n        if pixel_size_scale1 == 0:\n            pixel_size_scale1 = 1\n        pixel_size_scale.append(pixel_size_scale1)\n\n        if dimension == 'z' and len(translation_um) &gt; 2:\n            translation1 = translation_um[2]\n        elif dimension == 'y' and len(translation_um) &gt; 1:\n            translation1 = translation_um[1] * scale\n        elif dimension == 'x' and len(translation_um) &gt; 0:\n            translation1 = translation_um[0] * scale\n        else:\n            translation1 = 0\n        translation_scale.append(translation1)\n\n    metadata.append({'type': 'scale', 'scale': pixel_size_scale})\n    if not all(v == 0 for v in translation_scale):\n        metadata.append({'type': 'translation', 'translation': translation_scale})\n    return metadata\n</code></pre>"},{"location":"references/#OmeSliCC.ome_zarr_util.hexrgb_to_rgba","title":"<code>hexrgb_to_rgba(hexrgb)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def hexrgb_to_rgba(hexrgb: str) -&gt; list:\n    rgba = int_to_rgba(eval('0x' + hexrgb + 'FF'))\n    return rgba\n</code></pre>"},{"location":"references/#OmeSliCC.ome_zarr_util.int_to_rgba","title":"<code>int_to_rgba(intrgba)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def int_to_rgba(intrgba: int) -&gt; list:\n    signed = (intrgba &lt; 0)\n    rgba = [x / 255 for x in intrgba.to_bytes(4, signed=signed, byteorder=\"big\")]\n    if rgba[-1] == 0:\n        rgba[-1] = 1\n    return rgba\n</code></pre>"},{"location":"references/#OmeSliCC.ome_zarr_util.rgba_to_hexrgb","title":"<code>rgba_to_hexrgb(rgba)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def rgba_to_hexrgb(rgba: list) -&gt; str:\n    hexrgb = ''.join([hex(int(x * 255))[2:].upper().zfill(2) for x in rgba[:3]])\n    return hexrgb\n</code></pre>"},{"location":"references/#OmeSliCC.ome_zarr_util.rgba_to_int","title":"<code>rgba_to_int(rgba)</code>","text":"Source code in <code>OmeSliCC\\color_conversion.py</code> <pre><code>def rgba_to_int(rgba: list) -&gt; int:\n    intrgba = int.from_bytes([int(x * 255) for x in rgba], signed=True, byteorder=\"big\")\n    return intrgba\n</code></pre>"},{"location":"references/#OmeSliCC.ome_zarr_util.scale_dimensions_dict","title":"<code>scale_dimensions_dict(shape0, scale)</code>","text":"Source code in <code>OmeSliCC\\ome_zarr_util.py</code> <pre><code>def scale_dimensions_dict(shape0, scale):\n    shape = {}\n    if scale == 1:\n        return shape0\n    for dimension, shape1 in shape0.items():\n        if dimension[0] in ['x', 'y']:\n            shape1 = int(shape1 * scale)\n        shape[dimension] = shape1\n    return shape\n</code></pre>"},{"location":"references/#OmeSliCC.ome_zarr_util.scale_dimensions_xy","title":"<code>scale_dimensions_xy(shape0, dimension_order, scale)</code>","text":"Source code in <code>OmeSliCC\\ome_zarr_util.py</code> <pre><code>def scale_dimensions_xy(shape0, dimension_order, scale):\n    shape = []\n    if scale == 1:\n        return shape0\n    for shape1, dimension in zip(shape0, dimension_order):\n        if dimension[0] in ['x', 'y']:\n            shape1 = int(shape1 * scale)\n        shape.append(shape1)\n    return shape\n</code></pre>"},{"location":"references/#OmeSliCC.omero_credentials","title":"<code>omero_credentials</code>","text":""},{"location":"references/#OmeSliCC.omero_credentials.create_credentials_file","title":"<code>create_credentials_file(public_key_filename, credentials_filename)</code>","text":"Source code in <code>OmeSliCC\\omero_credentials.py</code> <pre><code>def create_credentials_file(public_key_filename: str, credentials_filename: str):\n    with open(public_key_filename, 'r') as key_file, open(credentials_filename, 'wb') as enc_file:\n        keydata = key_file.read().encode()\n        pub_key = rsa.PublicKey.load_pkcs1(keydata)\n        enc_cred = rsa.encrypt((input('Username: ') + '\\t' + getpass('Password: ')).encode(), pub_key)\n        enc_file.write(enc_cred)\n        print('credentials file generated')\n</code></pre>"},{"location":"references/#OmeSliCC.omero_credentials.decrypt_credentials","title":"<code>decrypt_credentials(private_key_filename, credentials_filename)</code>","text":"Source code in <code>OmeSliCC\\omero_credentials.py</code> <pre><code>def decrypt_credentials(private_key_filename: str, credentials_filename: str) -&gt; tuple:\n    with open(credentials_filename, 'rb') as cred_f, open(private_key_filename, 'rb') as key_file:\n        keydata = key_file.read()\n        pri_key = rsa.PrivateKey.load_pkcs1(keydata)\n        cred = cred_f.read()\n        dec_cred = rsa.decrypt(cred, pri_key).decode().split()\n        usr = dec_cred[0]\n        pwd = dec_cred[1]\n    return usr, pwd\n</code></pre>"},{"location":"references/#OmeSliCC.omero_credentials.generate_asymmetric_keys","title":"<code>generate_asymmetric_keys(private_key_filename, public_key_filename)</code>","text":"Source code in <code>OmeSliCC\\omero_credentials.py</code> <pre><code>def generate_asymmetric_keys(private_key_filename: str, public_key_filename: str):\n    pub_key, pri_key = rsa.newkeys(2048)\n    with open(public_key_filename, 'w') as pub_file, open(private_key_filename, 'w') as pri_file:\n        pub_file.write(pub_key.save_pkcs1().decode())\n        pri_file.write(pri_key.save_pkcs1().decode())\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata","title":"<code>omero_metadata</code>","text":""},{"location":"references/#OmeSliCC.omero_metadata.OME_SCHEMA_LOC","title":"<code>OME_SCHEMA_LOC = f'{OME_URI} {OME_URI}/ome.xsd'</code>  <code>module-attribute</code>","text":""},{"location":"references/#OmeSliCC.omero_metadata.OME_URI","title":"<code>OME_URI = 'http://www.openmicroscopy.org/Schemas/OME/2016-06'</code>  <code>module-attribute</code>","text":""},{"location":"references/#OmeSliCC.omero_metadata.OME_XSI","title":"<code>OME_XSI = 'http://www.w3.org/2001/XMLSchema-instance'</code>  <code>module-attribute</code>","text":""},{"location":"references/#OmeSliCC.omero_metadata.blur_image","title":"<code>blur_image(image, sigma)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def blur_image(image, sigma):\n    nchannels = image.shape[2] if image.ndim == 3 else 1\n    if nchannels not in [1, 3]:\n        new_image = np.zeros_like(image)\n        for channeli in range(nchannels):\n            new_image[..., channeli] = blur_image_single(image[..., channeli], sigma)\n    else:\n        new_image = blur_image_single(image, sigma)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.blur_image_single","title":"<code>blur_image_single(image, sigma)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def blur_image_single(image, sigma):\n    return gaussian_filter(image, sigma)\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.calc_fraction_used","title":"<code>calc_fraction_used(image, threshold=0.1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_fraction_used(image: np.ndarray, threshold: float = 0.1) -&gt; float:\n    low = int(round(threshold * 255))\n    high = int(round((1 - threshold) * 255))\n    shape = image.shape\n    total = shape[0] * shape[1]\n    good = 0\n    for y in range(shape[0]):\n        for x in range(shape[1]):\n            pixel = image[y, x]\n            if low &lt;= pixel[0] &lt; high and low &lt;= pixel[1] &lt; high and low &lt;= pixel[2] &lt; high:\n                good += 1\n    fraction = good / total\n    return fraction\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.calc_pyramid","title":"<code>calc_pyramid(xyzct, npyramid_add=0, pyramid_downsample=2, volumetric_resize=False)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_pyramid(xyzct: tuple, npyramid_add: int = 0, pyramid_downsample: float = 2,\n                 volumetric_resize: bool = False) -&gt; list:\n    x, y, z, c, t = xyzct\n    if volumetric_resize and z &gt; 1:\n        size = (x, y, z)\n    else:\n        size = (x, y)\n    sizes_add = []\n    scale = 1\n    for _ in range(npyramid_add):\n        scale /= pyramid_downsample\n        scaled_size = np.maximum(np.round(np.multiply(size, scale)).astype(int), 1)\n        sizes_add.append(scaled_size)\n    return sizes_add\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.calc_tiles_median","title":"<code>calc_tiles_median(images)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_tiles_median(images):\n    out_image = np.zeros_like(images[0])\n    median_image = np.median(images, 0, out_image)\n    return median_image\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.calc_tiles_quantiles","title":"<code>calc_tiles_quantiles(images, quantiles)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def calc_tiles_quantiles(images, quantiles):\n    out_quantiles = []\n    quantile_images = np.quantile(images, quantiles, 0)\n    for quantile_image in quantile_images:\n        maxval = 2 ** (8 * images[0].dtype.itemsize) - 1\n        image = (quantile_image / maxval).astype(np.float32)\n        out_quantiles.append(image)\n    return out_quantiles\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.check_round_significants","title":"<code>check_round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def check_round_significants(a: float, significant_digits: int) -&gt; float:\n    rounded = round_significants(a, significant_digits)\n    if a != 0:\n        dif = 1 - rounded / a\n    else:\n        dif = rounded - a\n    if abs(dif) &lt; 10 ** -significant_digits:\n        return rounded\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.check_versions","title":"<code>check_versions()</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def check_versions():\n    print(f'tifffile {tifffile.__version__}')\n    print(imagecodecs.version())\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.compare_image","title":"<code>compare_image(image0, image1, show=False)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image(image0, image1, show=False) -&gt; float:\n    dif, dif_max, dif_mean, psnr = compare_image_dist(image0, image1)\n    print(f'rgb dist max: {dif_max:.1f} mean: {dif_mean:.1f} PSNR: {psnr:.1f}')\n    if show:\n        show_image(dif)\n        show_image((dif * 10).astype(np.uint8))\n    return dif\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.compare_image_dist","title":"<code>compare_image_dist(image0, image1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image_dist(image0: np.ndarray, image1: np.ndarray) -&gt; tuple:\n    dif = cv.absdiff(image0, image1)\n    psnr = cv.PSNR(image0, image1)\n    if dif.size &gt; 1000000000:\n        # split very large array\n        rgb_maxs = []\n        rgb_means = []\n        for dif1 in np.array_split(dif, 16):\n            rgb_dif = np.linalg.norm(dif1, axis=2)\n            rgb_maxs.append(np.max(rgb_dif))\n            rgb_means.append(np.mean(rgb_dif))\n        rgb_max = np.max(rgb_maxs)\n        rgb_mean = np.mean(rgb_means)\n    else:\n        rgb_dif = np.linalg.norm(dif, axis=2)\n        rgb_max = np.max(rgb_dif)\n        rgb_mean = np.mean(rgb_dif)\n    return dif, rgb_max, rgb_mean, psnr\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.compare_image_dist_simple","title":"<code>compare_image_dist_simple(image0, image1)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def compare_image_dist_simple(image0: np.ndarray, image1: np.ndarray) -&gt; dict:\n    dif = cv.absdiff(image0, image1)\n    psnr = cv.PSNR(image0, image1)\n    rgb_dif = np.linalg.norm(dif, axis=2)\n    dif_max = np.max(rgb_dif)\n    dif_mean = np.mean(rgb_dif)\n    return {'dif_max': dif_max, 'dif_mean': dif_mean, 'psnr': psnr}\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.convert_image_sign_type","title":"<code>convert_image_sign_type(image, target_dtype)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def convert_image_sign_type(image: np.ndarray, target_dtype: np.dtype) -&gt; np.ndarray:\n    source_dtype = image.dtype\n    if source_dtype.kind == target_dtype.kind:\n        new_image = image\n    elif source_dtype.kind == 'i':\n        new_image = ensure_unsigned_image(image)\n    else:\n        # conversion without overhead\n        offset = 2 ** (8 * target_dtype.itemsize - 1)\n        new_image = (image - offset).astype(target_dtype)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.convert_rational_value","title":"<code>convert_rational_value(value)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def convert_rational_value(value) -&gt; float:\n    if value is not None and isinstance(value, tuple):\n        value = value[0] / value[1]\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.create_compression_codecs","title":"<code>create_compression_codecs(compression)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def create_compression_codecs(compression: list) -&gt; list:\n    codecs = None\n    compression = ensure_list(compression)\n    if compression is not None and len(compression) &gt; 0:\n        compression_type = compression[0].lower()\n        if len(compression) &gt; 1:\n            level = int(compression[1])\n        else:\n            level = None\n        if 'lzw' in compression_type:\n            from imagecodecs.numcodecs import Lzw\n            codecs = [Lzw()]\n        elif '2k' in compression_type or '2000' in compression_type:\n            from imagecodecs.numcodecs import Jpeg2k\n            codecs = [Jpeg2k(level=level)]\n        elif 'jpegls' in compression_type:\n            from imagecodecs.numcodecs import Jpegls\n            codecs = [Jpegls(level=level)]\n        elif 'jpegxr' in compression_type:\n            from imagecodecs.numcodecs import Jpegxr\n            codecs = [Jpegxr(level=level)]\n        elif 'jpegxl' in compression_type:\n            from imagecodecs.numcodecs import Jpegxl\n            codecs = [Jpegxl(level=level)]\n        else:\n            codecs = [compression]\n    return codecs\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.create_compression_filter","title":"<code>create_compression_filter(compression)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def create_compression_filter(compression: list) -&gt; tuple:\n    compressor, compression_filters = None, None\n    compression = ensure_list(compression)\n    if compression is not None and len(compression) &gt; 0:\n        compression_type = compression[0].lower()\n        if len(compression) &gt; 1:\n            level = int(compression[1])\n        else:\n            level = None\n        if 'lzw' in compression_type:\n            from imagecodecs.numcodecs import Lzw\n            compression_filters = [Lzw()]\n        elif '2k' in compression_type or '2000' in compression_type:\n            from imagecodecs.numcodecs import Jpeg2k\n            compression_filters = [Jpeg2k(level=level)]\n        elif 'jpegls' in compression_type:\n            from imagecodecs.numcodecs import Jpegls\n            compression_filters = [Jpegls(level=level)]\n        elif 'jpegxr' in compression_type:\n            from imagecodecs.numcodecs import Jpegxr\n            compression_filters = [Jpegxr(level=level)]\n        elif 'jpegxl' in compression_type:\n            from imagecodecs.numcodecs import Jpegxl\n            compression_filters = [Jpegxl(level=level)]\n        else:\n            compressor = compression\n    return compressor, compression_filters\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.create_ome_metadata_from_omero","title":"<code>create_ome_metadata_from_omero(source, image_object, output_filename, combine_rgb=True, pyramid_sizes_add=None)</code>","text":"Source code in <code>OmeSliCC\\omero_metadata.py</code> <pre><code>def create_ome_metadata_from_omero(source: OmeSource,\n                                   image_object: omero.gateway.ImageWrapper,\n                                   output_filename: str,\n                                   combine_rgb: bool = True,\n                                   pyramid_sizes_add: list = None) -&gt; str:\n\n    file_name = os.path.basename(output_filename)\n    file_title = get_filetitle(file_name)\n    uuid = f'urn:uuid:{uuid4()}'\n    software_name = toml.load(\"pyproject.toml\")[\"project\"][\"name\"]\n    software_version = toml.load(\"pyproject.toml\")[\"project\"][\"version\"]\n\n    ome = XmlDict()\n    ome['@xmlns'] = OME_URI\n    ome['@xmlns:xsi'] = OME_XSI\n    ome['@xsi:schemaLocation'] = OME_SCHEMA_LOC\n    ome['@UUID'] = uuid\n    ome['@Creator'] = f'{software_name} {software_version}'\n\n    instrument = None\n    objective = None\n    instrument0 = image_object.getInstrument()\n    if instrument0 is not None:\n        instrument = {'@ID': 'Instrument:0'}\n        objectives0 = instrument0.getObjectives()\n        if objectives0 is not None:\n            objective0 = objectives0[0]\n            wd = objective0.getWorkingDistance()\n            if wd is not None:\n                working_distance = wd.getValue()\n                working_distance_unit = wd.getSymbol()\n            else:\n                working_distance = None\n                working_distance_unit = None\n            objective = {\n                '@ID': 'Objective:0',\n                '@Manufacturer': objective0.getManufacturer(),\n                '@Model': objective0.getModel(),\n                '@LotNumber': objective0.getLotNumber(),\n                '@SerialNumber': objective0.getSerialNumber(),\n                '@NominalMagnification': source.get_mag(),\n                '@CalibratedMagnification': source.get_mag(),\n                '@LensNA': objective0.getLensNA(),\n                '@WorkingDistance': working_distance,\n                '@WorkingDistanceUnit': working_distance_unit,\n                '@Iris': objective0.getIris(),\n            }\n            correction = objective0.getCorrection().getValue()\n            if correction is not None and correction.lower() not in ['', 'unknown']:\n                objective['@Correction'] = correction\n            immersion = objective0.getImmersion().getValue()\n            if immersion is not None and immersion.lower() not in ['', 'unknown']:\n                objective['@Immersion'] = immersion\n            instrument['Objective'] = objective\n        ome['Instrument'] = instrument\n\n    # currently only supporting single image\n    nimages = 1\n\n    images = []\n    for imagei in range(nimages):\n        channels = []\n        planes = []\n\n        pixels0 = image_object.getPrimaryPixels()\n\n        stage0 = image_object.getStageLabel()\n        if stage0:\n            for plane0 in pixels0.copyPlaneInfo():\n                planes.append({\n                    '@TheC': plane0.getTheC(),\n                    '@TheT': plane0.getTheT(),\n                    '@TheZ': plane0.getTheZ(),\n                    'DeltaT': plane0.getDeltaT(),\n                    'ExposureTime': plane0.getExposureTime(),\n                    'PositionX': stage0.getPositionX().getValue(),\n                    'PositionY': stage0.getPositionY().getValue(),\n                    'PositionZ': stage0.getPositionZ().getValue(),\n                    'PositionXUnit': stage0.getPositionX().getSymbol(),\n                    'PositionYUnit': stage0.getPositionY().getSymbol(),\n                    'PositionZUnit': stage0.getPositionZ().getSymbol(),\n                })\n\n        channelso = image_object.getChannels()\n        for channeli, channelo in enumerate(channelso):\n            channell = channelo.getLogicalChannel()\n            light_path = channell.getLightPath()\n            if light_path is None:\n                light_path = {}\n            channel = {\n                '@ID': f'Channel:{imagei}:{channeli}',\n                '@Name': channelo.getName(),\n                '@Color': channelo.getColor().getInt(),\n                '@EmissionWave': channelo.getEmissionWave(),\n                '@ExcitationWave': channelo.getExcitationWave(),\n                '@PockelCellSetting': channell.getPockelCellSetting(),\n                '@Fluor': channell.getFluor(),\n                '@ContrastMethod': channell.getContrastMethod(),\n                '@PinHoleSize': channell.getPinHoleSize(),\n                '@SamplesPerPixel': channell.getSamplesPerPixel(),\n                '@NDFilter': channell.getNdFilter(),\n                'LightPath': light_path,\n            }\n            channels.append(channel)\n\n        nchannels = source.get_nchannels()\n        if combine_rgb and len(channels) == 3:\n            channel = channels[0].copy()\n            channel['@SamplesPerPixel'] = nchannels\n            channel.pop('@Color', None)\n            channels = [channel]\n        elif not combine_rgb and len(channels) &lt; nchannels:\n            channel = channels[0].copy()\n            if '@Color' in channel:\n                channel['@Color'] = rgba_to_int(channel['@Color'])\n            channel['@SamplesPerPixel'] = 1\n            channels = [channel] * nchannels\n\n        image = {\n            '@ID': f'Image:{imagei}',\n            '@Name': file_title,\n            'AcquisitionDate': image_object.getAcquisitionDate().isoformat(),\n            'Description': image_object.getDescription(),\n        }\n\n        xyzct = source.get_size_xyzct()\n        pixels = {\n            '@ID': f'Pixels:{imagei}',\n            '@SizeX': xyzct[0],\n            '@SizeY': xyzct[1],\n            '@SizeZ': xyzct[2],\n            '@SizeC': nchannels,\n            '@SizeT': xyzct[4],\n            '@Type': str(ensure_unsigned_type(source.get_pixel_type())),\n            '@DimensionOrder': 'XYZCT',\n            'Channel': channels,\n            'TiffData': {'UUID': {'@FileName': file_name, '#text': uuid}},\n        }\n        pixel_size = source.get_pixel_size()\n        if len(pixel_size) &gt; 0 and pixel_size[0][0] != 0:\n            pixels['@PhysicalSizeX'] = pixel_size[0][0]\n        if len(pixel_size) &gt; 1 and pixel_size[1][0] != 0:\n            pixels['@PhysicalSizeY'] = pixel_size[1][0]\n        if len(pixel_size) &gt; 2 and pixel_size[2][0] != 0:\n            pixels['@PhysicalSizeZ'] = pixel_size[2][0]\n        if len(pixel_size) &gt; 0 and pixel_size[0][1] != '':\n            pixels['@PhysicalSizeXUnit'] = pixel_size[0][1]\n        if len(pixel_size) &gt; 1 and pixel_size[1][1] != '':\n            pixels['@PhysicalSizeYUnit'] = pixel_size[1][1]\n        if len(pixel_size) &gt; 2 and pixel_size[2][1] != '':\n            pixels['@PhysicalSizeZUnit'] = pixel_size[2][1]\n\n        if len(planes) &gt; 0:\n            pixels['Plane'] = planes\n\n        # Set image refs\n        if instrument:\n            image['InstrumentRef'] = {'@ID': instrument['@ID']}\n        if objective:\n            image['ObjectiveSettings'] = {'@ID': objective['@ID']}\n        # (end image refs)\n        if stage0:\n            image['StageLabel'] = {'@Name': stage0.getName()}\n        image['Pixels'] = pixels\n        images.append(image)\n\n    ome['Image'] = images\n\n    annotations = {}\n    for annotations0 in image_object.listAnnotations():\n        annotation_type = annotations0.OMERO_TYPE.__name__\n        if annotation_type.endswith('I'):\n            annotation_type = annotation_type[:-1]\n        if annotation_type not in annotations:\n            annotations[annotation_type] = []\n        value = annotations0.getValue()\n        if annotation_type == 'MapAnnotation':\n            value = {'M': [{'@K': k, '#text': v} for k, v in value]}\n        annotations[annotation_type].append({\n            '@ID': f'Annotation:{len(annotations[annotation_type])}',\n            '@Namespace': annotations0.getNs(),\n            'Value': value\n        })\n    # add pyramid sizes\n    if pyramid_sizes_add:\n        if 'MapAnnotation' not in annotations:\n            annotations['MapAnnotation'] = []\n        key_value_map = {'M': [{'@K': i + 1, '#text': f'{\" \".join([str(size) for size in pyramid_size])}'}\n                               for i, pyramid_size in enumerate(pyramid_sizes_add)]}\n        annotations['MapAnnotation'].insert(0, {\n            '@ID': 'Annotation:Resolution:0',\n            '@Namespace': 'openmicroscopy.org/PyramidResolution',\n            'Value': key_value_map\n        })\n\n    ome['StructuredAnnotations'] = annotations\n\n    return dict2xml({'OME': filter_dict(ome)})\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.desc_to_dict","title":"<code>desc_to_dict(desc)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def desc_to_dict(desc: str) -&gt; dict:\n    desc_dict = {}\n    if desc.startswith('{'):\n        try:\n            metadata = ast.literal_eval(desc)\n            return metadata\n        except:\n            pass\n    for item in re.split(r'[\\r\\n\\t|]', desc):\n        item_sep = '='\n        if ':' in item:\n            item_sep = ':'\n        if item_sep in item:\n            items = item.split(item_sep)\n            key = items[0].strip()\n            value = items[1].strip()\n            for dtype in (int, float, bool):\n                try:\n                    value = dtype(value)\n                    break\n                except:\n                    pass\n            desc_dict[key] = value\n    return desc_dict\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.ensure_list","title":"<code>ensure_list(x)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def ensure_list(x) -&gt; list:\n    if x is None:\n        return []\n    elif isinstance(x, list):\n        return x\n    else:\n        return [x]\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.ensure_unsigned_image","title":"<code>ensure_unsigned_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def ensure_unsigned_image(image: np.ndarray) -&gt; np.ndarray:\n    source_dtype = image.dtype\n    dtype = ensure_unsigned_type(source_dtype)\n    if dtype != source_dtype:\n        # conversion without overhead\n        offset = 2 ** (8 * dtype.itemsize - 1)\n        new_image = image.astype(dtype) + offset\n    else:\n        new_image = image\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.ensure_unsigned_type","title":"<code>ensure_unsigned_type(dtype)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def ensure_unsigned_type(dtype: np.dtype) -&gt; np.dtype:\n    new_dtype = dtype\n    if dtype.kind == 'i' or dtype.byteorder == '&gt;' or dtype.byteorder == '&lt;':\n        new_dtype = np.dtype(f'u{dtype.itemsize}')\n    return new_dtype\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.file_to_dict","title":"<code>file_to_dict(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def file_to_dict(filename: str) -&gt; dict:\n    ext = os.path.splitext(filename)[1]\n    content = open(filename, 'r').read()\n    if ext == '.xml':\n        data = xmltodict.parse(content)\n    elif ext in ['.yml', '.yaml']:\n        data = yaml.safe_load(content)\n    else:   # assume json\n        data = json.loads(content)\n    return data\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.filter_dict","title":"<code>filter_dict(dict0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def filter_dict(dict0: dict) -&gt; dict:\n    new_dict = {}\n    for key, value0 in dict0.items():\n        if value0 is not None:\n            values = []\n            for value in ensure_list(value0):\n                if isinstance(value, dict):\n                    value = filter_dict(value)\n                values.append(value)\n            if len(values) == 1:\n                values = values[0]\n            new_dict[key] = values\n    return new_dict\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.float2int_image","title":"<code>float2int_image(image, target_dtype=np.dtype(np.uint8))</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def float2int_image(image, target_dtype=np.dtype(np.uint8)):\n    source_dtype = image.dtype\n    if source_dtype.kind not in ('i', 'u') and not target_dtype.kind == 'f':\n        maxval = 2 ** (8 * target_dtype.itemsize) - 1\n        return (image * maxval).astype(target_dtype)\n    else:\n        return image\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.get_default","title":"<code>get_default(x, default)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_default(x, default):\n    return default if x is None else x\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.get_filetitle","title":"<code>get_filetitle(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_filetitle(filename: str) -&gt; str:\n    filebase = os.path.basename(filename)\n    title = os.path.splitext(filebase)[0].rstrip('.ome')\n    return title\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.get_image_quantile","title":"<code>get_image_quantile(image, quantile, axis=None)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_image_quantile(image: np.ndarray, quantile: float, axis=None) -&gt; float:\n    value = np.quantile(image, quantile, axis=axis).astype(image.dtype)\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.get_image_size_info","title":"<code>get_image_size_info(sizes_xyzct, pixel_nbytes, pixel_type, channels)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_image_size_info(sizes_xyzct: list, pixel_nbytes: int, pixel_type: np.dtype, channels: list) -&gt; str:\n    image_size_info = 'XYZCT:'\n    size = 0\n    for i, size_xyzct in enumerate(sizes_xyzct):\n        w, h, zs, cs, ts = size_xyzct\n        size += np.int64(pixel_nbytes) * w * h * zs * cs * ts\n        if i &gt; 0:\n            image_size_info += ','\n        image_size_info += f' {w} {h} {zs} {cs} {ts}'\n    image_size_info += f' Pixel type: {pixel_type} Uncompressed: {print_hbytes(size)}'\n    if sizes_xyzct[0][3] == 3:\n        channel_info = 'rgb'\n    else:\n        channel_info = ','.join([channel.get('Name', '') for channel in channels])\n    if channel_info != '':\n        image_size_info += f' Channels: {channel_info}'\n    return image_size_info\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.get_numpy_slicing","title":"<code>get_numpy_slicing(dimension_order, **slicing)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_numpy_slicing(dimension_order, **slicing):\n    slices = []\n    for axis in dimension_order:\n        index = slicing.get(axis)\n        index0 = slicing.get(axis + '0')\n        index1 = slicing.get(axis + '1')\n        if index0 is not None and index1 is not None:\n            slice1 = slice(int(index0), int(index1))\n        elif index is not None:\n            slice1 = int(index)\n        else:\n            slice1 = slice(None)\n        slices.append(slice1)\n    return tuple(slices)\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.get_pil_metadata","title":"<code>get_pil_metadata(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_pil_metadata(image: PIL.Image) -&gt; dict:\n    metadata = {}\n    exifdata = image.getexif()\n    for tag_id in exifdata:\n        tag = TAGS.get(tag_id, tag_id)\n        data = exifdata.get(tag_id)\n        if isinstance(data, bytes):\n            data = data.decode()\n        metadata[tag] = data\n    if metadata == {}:\n        metadata = image.info\n    return metadata\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.get_tiff_pages","title":"<code>get_tiff_pages(tiff)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def get_tiff_pages(tiff: TiffFile) -&gt; list:\n    # TODO: review so this works for multi-level ome-tiff, tiff-stack, and z pages tiff, then later check for mmstack\n    pages = []\n    found = False\n    if tiff.series and not tiff.is_mmstack:\n        # has series\n        baseline = tiff.series[0]\n        for level in baseline.levels:\n            # has levels\n            level_pages = []\n            for page in level.pages:\n                found = True\n                level_pages.append(page)\n            if level_pages:\n                pages.append(level_pages)\n\n    if not found:\n        for page in tiff.pages:\n            pages.append(page)\n    return pages\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.get_value_units_micrometer","title":"<code>get_value_units_micrometer(value_units0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_value_units_micrometer(value_units0: list) -&gt; list:\n    conversions = {'nm': 1e-3, '\u00b5m': 1, 'um': 1, 'micrometer': 1, 'mm': 1e3, 'cm': 1e4, 'm': 1e6}\n    if value_units0 is None:\n        return None\n\n    values_um = []\n    for value_unit in value_units0:\n        if not (isinstance(value_unit, int) or isinstance(value_unit, float)):\n            value_um = value_unit[0] * conversions.get(value_unit[1], 1)\n        else:\n            value_um = value_unit\n        values_um.append(value_um)\n    return values_um\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.image_reshape","title":"<code>image_reshape(image, target_size)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def image_reshape(image: np.ndarray, target_size: tuple) -&gt; np.ndarray:\n    tw, th = target_size\n    sh, sw = image.shape[0:2]\n    if sw &lt; tw or sh &lt; th:\n        dw = max(tw - sw, 0)\n        dh = max(th - sh, 0)\n        padding = [(0, dh), (0, dw)]\n        if len(image.shape) == 3:\n            padding += [(0, 0)]\n        image = np.pad(image, padding, 'edge')\n    if tw &lt; sw or th &lt; sh:\n        image = image[0:th, 0:tw]\n    return image\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.image_resize","title":"<code>image_resize(image, target_size0, dimension_order='yxc')</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def image_resize(image: np.ndarray, target_size0: tuple, dimension_order: str = 'yxc') -&gt; np.ndarray:\n    shape = image.shape\n    x_index = dimension_order.index('x')\n    y_index = dimension_order.index('y')\n    c_is_at_end = ('c' in dimension_order and dimension_order.endswith('c'))\n    size = shape[x_index], shape[y_index]\n    if np.mean(np.divide(size, target_size0)) &lt; 1:\n        interpolation = cv.INTER_CUBIC\n    else:\n        interpolation = cv.INTER_AREA\n    dtype0 = image.dtype\n    image = ensure_unsigned_image(image)\n    target_size = tuple(np.maximum(np.round(target_size0).astype(int), 1))\n    if dimension_order in ['yxc', 'yx']:\n        new_image = cv.resize(np.asarray(image), target_size, interpolation=interpolation)\n    elif dimension_order == 'cyx':\n        new_image = np.moveaxis(image, 0, -1)\n        new_image = cv.resize(np.asarray(new_image), target_size, interpolation=interpolation)\n        new_image = np.moveaxis(new_image, -1, 0)\n    else:\n        ts = image.shape[dimension_order.index('t')] if 't' in dimension_order else 1\n        zs = image.shape[dimension_order.index('z')] if 'z' in dimension_order else 1\n        target_shape = list(image.shape).copy()\n        target_shape[x_index] = target_size[0]\n        target_shape[y_index] = target_size[1]\n        new_image = np.zeros(target_shape, dtype=image.dtype)\n        for t in range(ts):\n            for z in range(zs):\n                slices = get_numpy_slicing(dimension_order, z=z, t=t)\n                image1 = image[slices]\n                if not c_is_at_end:\n                    image1 = np.moveaxis(image1, 0, -1)\n                new_image1 = np.atleast_3d(cv.resize(np.asarray(image1), target_size, interpolation=interpolation))\n                if not c_is_at_end:\n                    new_image1 = np.moveaxis(new_image1, -1, 0)\n                new_image[slices] = new_image1\n    new_image = convert_image_sign_type(new_image, dtype0)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.int2float_image","title":"<code>int2float_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def int2float_image(image):\n    source_dtype = image.dtype\n    if not source_dtype.kind == 'f':\n        maxval = 2 ** (8 * source_dtype.itemsize) - 1\n        return image / np.float32(maxval)\n    else:\n        return image\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.normalise_values","title":"<code>normalise_values(image, min_value, max_value)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def normalise_values(image: np.ndarray, min_value: float, max_value: float) -&gt; np.ndarray:\n    return np.clip((image.astype(np.float32) - min_value) / (max_value - min_value), 0, 1)\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.pilmode_to_pixelinfo","title":"<code>pilmode_to_pixelinfo(mode)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def pilmode_to_pixelinfo(mode: str) -&gt; tuple:\n    pixelinfo = (np.uint8, 8, 1)\n    mode_types = {\n        'I': (np.uint32, 32, 1),\n        'F': (np.float32, 32, 1),\n        'RGB': (np.uint8, 24, 3),\n        'RGBA': (np.uint8, 32, 4),\n        'CMYK': (np.uint8, 32, 4),\n        'YCbCr': (np.uint8, 24, 3),\n        'LAB': (np.uint8, 24, 3),\n        'HSV': (np.uint8, 24, 3),\n    }\n    if '16' in mode:\n        pixelinfo = (np.uint16, 16, 1)\n    elif '32' in mode:\n        pixelinfo = (np.uint32, 32, 1)\n    elif mode in mode_types:\n        pixelinfo = mode_types[mode]\n    pixelinfo = (np.dtype(pixelinfo[0]), pixelinfo[1])\n    return pixelinfo\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.precise_resize","title":"<code>precise_resize(image, factors)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def precise_resize(image: np.ndarray, factors) -&gt; np.ndarray:\n    if image.ndim &gt; len(factors):\n        factors = list(factors) + [1]\n    new_image = downscale_local_mean(np.asarray(image), tuple(factors)).astype(image.dtype)\n    return new_image\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.print_dict","title":"<code>print_dict(dct, indent=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_dict(dct: dict, indent: int = 0) -&gt; str:\n    s = ''\n    if isinstance(dct, dict):\n        for key, value in dct.items():\n            s += '\\n'\n            if not isinstance(value, list):\n                s += '\\t' * indent + str(key) + ': '\n            if isinstance(value, dict):\n                s += print_dict(value, indent=indent + 1)\n            elif isinstance(value, list):\n                for v in value:\n                    s += print_dict(v)\n            else:\n                s += str(value)\n    else:\n        s += str(dct)\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.print_hbytes","title":"<code>print_hbytes(nbytes)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_hbytes(nbytes: int) -&gt; str:\n    exps = ['', 'K', 'M', 'G', 'T']\n    div = 1024\n    exp = 0\n\n    while nbytes &gt; div:\n        nbytes /= div\n        exp += 1\n    return f'{nbytes:.1f}{exps[exp]}B'\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.redimension_data","title":"<code>redimension_data(data, old_order, new_order, **indices)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def redimension_data(data, old_order, new_order, **indices):\n    # able to provide optional dimension values e.g. t=0, z=0\n    if new_order == old_order:\n        return data\n\n    new_data = data\n    order = old_order\n    # remove\n    for o in old_order:\n        if o not in new_order:\n            index = order.index(o)\n            dim_value = indices.get(o, 0)\n            new_data = np.take(new_data, indices=dim_value, axis=index)\n            order = order[:index] + order[index + 1:]\n    # add\n    for o in new_order:\n        if o not in order:\n            new_data = np.expand_dims(new_data, 0)\n            order = o + order\n    # move\n    old_indices = [order.index(o) for o in new_order]\n    new_indices = list(range(len(new_order)))\n    new_data = np.moveaxis(new_data, old_indices, new_indices)\n    return new_data\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.reorder","title":"<code>reorder(items, old_order, new_order, default_value=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def reorder(items: list, old_order: str, new_order: str, default_value: int = 0) -&gt; list:\n    new_items = []\n    for label in new_order:\n        if label in old_order:\n            item = items[old_order.index(label)]\n        else:\n            item = default_value\n        new_items.append(item)\n    return new_items\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.round_significants","title":"<code>round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def round_significants(a: float, significant_digits: int) -&gt; float:\n    if a != 0:\n        round_decimals = significant_digits - int(np.floor(np.log10(abs(a)))) - 1\n        return round(a, round_decimals)\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.save_image","title":"<code>save_image(image, filename, output_params={})</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def save_image(image: np.ndarray, filename: str, output_params: dict = {}):\n    compression = output_params.get('compression')\n    PIL.Image.fromarray(image).save(filename, compression=compression)\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.show_image","title":"<code>show_image(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def show_image(image: np.ndarray):\n    plt.imshow(image)\n    plt.show()\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.show_image_gray","title":"<code>show_image_gray(image)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def show_image_gray(image: np.ndarray):\n    plt.imshow(image, cmap='gray')\n    plt.show()\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.split_num_text","title":"<code>split_num_text(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_num_text(text: str) -&gt; list:\n    num_texts = []\n    block = ''\n    is_num0 = None\n    if text is None:\n        return None\n\n    for c in text:\n        is_num = (c.isnumeric() or c == '.')\n        if is_num0 is not None and is_num != is_num0:\n            num_texts.append(block)\n            block = ''\n        block += c\n        is_num0 = is_num\n    if block != '':\n        num_texts.append(block)\n\n    num_texts2 = []\n    for block in num_texts:\n        block = block.strip()\n        try:\n            block = float(block)\n        except:\n            pass\n        if block not in [' ', ',', '|']:\n            num_texts2.append(block)\n    return num_texts2\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.split_value_unit_list","title":"<code>split_value_unit_list(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_value_unit_list(text: str) -&gt; list:\n    value_units = []\n    if text is None:\n        return None\n\n    items = split_num_text(text)\n    if isinstance(items[-1], str):\n        def_unit = items[-1]\n    else:\n        def_unit = ''\n\n    i = 0\n    while i &lt; len(items):\n        value = items[i]\n        if i + 1 &lt; len(items):\n            unit = items[i + 1]\n        else:\n            unit = ''\n        if not isinstance(value, str):\n            if isinstance(unit, str):\n                i += 1\n            else:\n                unit = def_unit\n            value_units.append((value, unit))\n        i += 1\n    return value_units\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.tags_to_dict","title":"<code>tags_to_dict(tags)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tags_to_dict(tags: tifffile.TiffTags) -&gt; dict:\n    tag_dict = {}\n    for tag in tags.values():\n        tag_dict[tag.name] = tag.value\n    return tag_dict\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.tiff_info","title":"<code>tiff_info(filename)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tiff_info(filename: str) -&gt; str:\n    s = ''\n    nom_size = 0\n    tiff = TiffFile(filename)\n    real_size = tiff.fstat.st_size\n    s += str(tiff) + '\\n'\n    if tiff.ome_metadata:\n        print(tiff.ome_metadata)\n        s += f'OME: {print_dict(tifffile.xml2dict(tiff.ome_metadata))}\\n'\n    if tiff.metaseries_metadata:\n        s += f'Series: {tiff.metaseries_metadata}\\n'\n    if tiff.imagej_metadata:\n        s += f'ImageJ: {tiff.imagej_metadata}\\n'\n\n    for page0 in get_tiff_pages(tiff):\n        page = page0[0] if isinstance(page0, list) else page0\n        s += str(page) + '\\n'\n        s += f'Size: {np.flip(page.shape)} ({print_hbytes(page.size)})\\n'\n        if page.is_tiled:\n            s += f'Tiling: {page.tilewidth} {page.tilelength} {page.tiledepth}\\n'\n        s += f'Compression: {str(page.compression)} jpegtables: {page.jpegtables is not None}\\n'\n        tag_dict = tags_to_dict(page.tags)\n        if 'TileOffsets' in tag_dict:\n            tag_dict.pop('TileOffsets')\n        if 'TileByteCounts' in tag_dict:\n            tag_dict.pop('TileByteCounts')\n        if 'ImageDescription' in tag_dict and tag_dict['ImageDescription'].startswith('&lt;?xml'):\n            # redundant\n            tag_dict.pop('ImageDescription')\n        s += print_dict(tag_dict) + '\\n\\n'\n        nom_size += page.size\n\n    s += f'Overall compression: 1:{nom_size / real_size:.1f}'\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.omero_metadata.tiff_info_short","title":"<code>tiff_info_short(filename)</code>","text":"Source code in <code>OmeSliCC\\image_util.py</code> <pre><code>def tiff_info_short(filename: str) -&gt; str:\n    nom_size = 0\n    tiff = TiffFile(filename)\n    s = str(filename)\n    real_size = tiff.fstat.st_size\n    for page in tiff.pages:\n        s += ' ' + str(page)\n        nom_size += page.size\n    s += f' Image size:{nom_size} File size:{real_size} Overall compression: 1:{nom_size / real_size:.1f}'\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.parameters","title":"<code>parameters</code>","text":""},{"location":"references/#OmeSliCC.parameters.IMAGE_DIR","title":"<code>IMAGE_DIR = RESOURCE_DIR + 'images/'</code>  <code>module-attribute</code>","text":""},{"location":"references/#OmeSliCC.parameters.PARAMETER_FILE","title":"<code>PARAMETER_FILE = RESOURCE_DIR + 'params.yml'</code>  <code>module-attribute</code>","text":""},{"location":"references/#OmeSliCC.parameters.RESOURCE_DIR","title":"<code>RESOURCE_DIR = 'resources/'</code>  <code>module-attribute</code>","text":""},{"location":"references/#OmeSliCC.parameters.ChannelOperation","title":"<code>ChannelOperation</code>","text":"<p>               Bases: <code>Enum</code></p> Source code in <code>OmeSliCC\\parameters.py</code> <pre><code>class ChannelOperation(Enum):\n    NONE = 0\n    COMBINE = 1\n    SPLIT = 2\n</code></pre>"},{"location":"references/#OmeSliCC.parameters.ChannelOperation.COMBINE","title":"<code>COMBINE = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.parameters.ChannelOperation.NONE","title":"<code>NONE = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.parameters.ChannelOperation.SPLIT","title":"<code>SPLIT = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"references/#OmeSliCC.util","title":"<code>util</code>","text":""},{"location":"references/#OmeSliCC.util.check_round_significants","title":"<code>check_round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def check_round_significants(a: float, significant_digits: int) -&gt; float:\n    rounded = round_significants(a, significant_digits)\n    if a != 0:\n        dif = 1 - rounded / a\n    else:\n        dif = rounded - a\n    if abs(dif) &lt; 10 ** -significant_digits:\n        return rounded\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.util.convert_rational_value","title":"<code>convert_rational_value(value)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def convert_rational_value(value) -&gt; float:\n    if value is not None and isinstance(value, tuple):\n        value = value[0] / value[1]\n    return value\n</code></pre>"},{"location":"references/#OmeSliCC.util.desc_to_dict","title":"<code>desc_to_dict(desc)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def desc_to_dict(desc: str) -&gt; dict:\n    desc_dict = {}\n    if desc.startswith('{'):\n        try:\n            metadata = ast.literal_eval(desc)\n            return metadata\n        except:\n            pass\n    for item in re.split(r'[\\r\\n\\t|]', desc):\n        item_sep = '='\n        if ':' in item:\n            item_sep = ':'\n        if item_sep in item:\n            items = item.split(item_sep)\n            key = items[0].strip()\n            value = items[1].strip()\n            for dtype in (int, float, bool):\n                try:\n                    value = dtype(value)\n                    break\n                except:\n                    pass\n            desc_dict[key] = value\n    return desc_dict\n</code></pre>"},{"location":"references/#OmeSliCC.util.ensure_list","title":"<code>ensure_list(x)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def ensure_list(x) -&gt; list:\n    if x is None:\n        return []\n    elif isinstance(x, list):\n        return x\n    else:\n        return [x]\n</code></pre>"},{"location":"references/#OmeSliCC.util.file_to_dict","title":"<code>file_to_dict(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def file_to_dict(filename: str) -&gt; dict:\n    ext = os.path.splitext(filename)[1]\n    content = open(filename, 'r').read()\n    if ext == '.xml':\n        data = xmltodict.parse(content)\n    elif ext in ['.yml', '.yaml']:\n        data = yaml.safe_load(content)\n    else:   # assume json\n        data = json.loads(content)\n    return data\n</code></pre>"},{"location":"references/#OmeSliCC.util.filter_dict","title":"<code>filter_dict(dict0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def filter_dict(dict0: dict) -&gt; dict:\n    new_dict = {}\n    for key, value0 in dict0.items():\n        if value0 is not None:\n            values = []\n            for value in ensure_list(value0):\n                if isinstance(value, dict):\n                    value = filter_dict(value)\n                values.append(value)\n            if len(values) == 1:\n                values = values[0]\n            new_dict[key] = values\n    return new_dict\n</code></pre>"},{"location":"references/#OmeSliCC.util.get_default","title":"<code>get_default(x, default)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_default(x, default):\n    return default if x is None else x\n</code></pre>"},{"location":"references/#OmeSliCC.util.get_filetitle","title":"<code>get_filetitle(filename)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_filetitle(filename: str) -&gt; str:\n    filebase = os.path.basename(filename)\n    title = os.path.splitext(filebase)[0].rstrip('.ome')\n    return title\n</code></pre>"},{"location":"references/#OmeSliCC.util.get_value_units_micrometer","title":"<code>get_value_units_micrometer(value_units0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def get_value_units_micrometer(value_units0: list) -&gt; list:\n    conversions = {'nm': 1e-3, '\u00b5m': 1, 'um': 1, 'micrometer': 1, 'mm': 1e3, 'cm': 1e4, 'm': 1e6}\n    if value_units0 is None:\n        return None\n\n    values_um = []\n    for value_unit in value_units0:\n        if not (isinstance(value_unit, int) or isinstance(value_unit, float)):\n            value_um = value_unit[0] * conversions.get(value_unit[1], 1)\n        else:\n            value_um = value_unit\n        values_um.append(value_um)\n    return values_um\n</code></pre>"},{"location":"references/#OmeSliCC.util.print_dict","title":"<code>print_dict(dct, indent=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_dict(dct: dict, indent: int = 0) -&gt; str:\n    s = ''\n    if isinstance(dct, dict):\n        for key, value in dct.items():\n            s += '\\n'\n            if not isinstance(value, list):\n                s += '\\t' * indent + str(key) + ': '\n            if isinstance(value, dict):\n                s += print_dict(value, indent=indent + 1)\n            elif isinstance(value, list):\n                for v in value:\n                    s += print_dict(v)\n            else:\n                s += str(value)\n    else:\n        s += str(dct)\n    return s\n</code></pre>"},{"location":"references/#OmeSliCC.util.print_hbytes","title":"<code>print_hbytes(nbytes)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def print_hbytes(nbytes: int) -&gt; str:\n    exps = ['', 'K', 'M', 'G', 'T']\n    div = 1024\n    exp = 0\n\n    while nbytes &gt; div:\n        nbytes /= div\n        exp += 1\n    return f'{nbytes:.1f}{exps[exp]}B'\n</code></pre>"},{"location":"references/#OmeSliCC.util.reorder","title":"<code>reorder(items, old_order, new_order, default_value=0)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def reorder(items: list, old_order: str, new_order: str, default_value: int = 0) -&gt; list:\n    new_items = []\n    for label in new_order:\n        if label in old_order:\n            item = items[old_order.index(label)]\n        else:\n            item = default_value\n        new_items.append(item)\n    return new_items\n</code></pre>"},{"location":"references/#OmeSliCC.util.round_significants","title":"<code>round_significants(a, significant_digits)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def round_significants(a: float, significant_digits: int) -&gt; float:\n    if a != 0:\n        round_decimals = significant_digits - int(np.floor(np.log10(abs(a)))) - 1\n        return round(a, round_decimals)\n    return a\n</code></pre>"},{"location":"references/#OmeSliCC.util.split_num_text","title":"<code>split_num_text(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_num_text(text: str) -&gt; list:\n    num_texts = []\n    block = ''\n    is_num0 = None\n    if text is None:\n        return None\n\n    for c in text:\n        is_num = (c.isnumeric() or c == '.')\n        if is_num0 is not None and is_num != is_num0:\n            num_texts.append(block)\n            block = ''\n        block += c\n        is_num0 = is_num\n    if block != '':\n        num_texts.append(block)\n\n    num_texts2 = []\n    for block in num_texts:\n        block = block.strip()\n        try:\n            block = float(block)\n        except:\n            pass\n        if block not in [' ', ',', '|']:\n            num_texts2.append(block)\n    return num_texts2\n</code></pre>"},{"location":"references/#OmeSliCC.util.split_value_unit_list","title":"<code>split_value_unit_list(text)</code>","text":"Source code in <code>OmeSliCC\\util.py</code> <pre><code>def split_value_unit_list(text: str) -&gt; list:\n    value_units = []\n    if text is None:\n        return None\n\n    items = split_num_text(text)\n    if isinstance(items[-1], str):\n        def_unit = items[-1]\n    else:\n        def_unit = ''\n\n    i = 0\n    while i &lt; len(items):\n        value = items[i]\n        if i + 1 &lt; len(items):\n            unit = items[i + 1]\n        else:\n            unit = ''\n        if not isinstance(value, str):\n            if isinstance(unit, str):\n                i += 1\n            else:\n                unit = def_unit\n            value_units.append((value, unit))\n        i += 1\n    return value_units\n</code></pre>"}]}